[{"title":"Lambda","summary":"","rawIndexableTextContent":" ","headings":[],"kind":"symbol","location":{"reference":{"url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/Lambda","interfaceLanguage":"swift"},"type":"topLevelPage"}},{"headings":[],"rawIndexableTextContent":" ","title":"run()","kind":"symbol","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/LambdaRuntime\/run()","interfaceLanguage":"swift"}},"summary":""},{"title":"env(_:)","summary":"Utility to access\/read environment variables","headings":[],"rawIndexableTextContent":"Utility to access\/read environment variables ","location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/Lambda\/env(_:)"}},"kind":"symbol"},{"kind":"symbol","summary":"The ARN of the Lambda function, version, or alias that’s specified in the invocation.","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/LambdaContext\/invokedFunctionARN","interfaceLanguage":"swift"}},"rawIndexableTextContent":"The ARN of the Lambda function, version, or alias that’s specified in the invocation. ","title":"invokedFunctionARN","headings":[]},{"title":"cognitoIdentity","headings":[],"rawIndexableTextContent":"For invocations from the AWS Mobile SDK, data about the Amazon Cognito identity provider. ","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/LambdaContext\/cognitoIdentity","interfaceLanguage":"swift"}},"kind":"symbol","summary":"For invocations from the AWS Mobile SDK, data about the Amazon Cognito identity provider."},{"headings":["Discussion"],"location":{"type":"topLevelPage","reference":{"url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/LambdaContext\/logger","interfaceLanguage":"swift"}},"rawIndexableTextContent":"Logger to log with.  Discussion The LogLevel can be configured using the LOG_LEVEL environment variable.","title":"logger","summary":"Logger to log with.","kind":"symbol"},{"title":"Getting Started Quickly","location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/quick-setup"}},"rawIndexableTextContent":"Learn how to create your first project in 3 minutes. Overview Follow these instructions to get a high-level overview of the steps to write, test, and deploy your first Lambda function written in Swift. For a detailed step-by-step instruction, follow the tutorial instead. Your First Lambda Function Written in Swift For the impatient, keep reading. High-level instructions Follow these 6 steps to write, test, and deploy a Lambda function in Swift. Create a Swift project for an executable target  Add dependencies on AWSLambdaRuntime library  Write your function code. Create an instance of LambdaRuntime and pass a function as a closure. The function has this signature: (_: Event, context: LambdaContext) async throws -> Output (as defined in the LambdaHandler protocol). Event must be Decodable. Output must be Encodable. If your Lambda function is invoked by another AWS service, use the AWSLambdaEvent library at https:\/\/github.com\/swift-server\/swift-aws-lambda-events to represent the input event. Finally, call runtime.run() to start the event loop.  Test your code locally  Build and package your code for AWS Lambda AWS Lambda runtime runs on Amazon Linux. You must compile your code for Amazon Linux. Be sure to have Docker installed for this step.  Deploy on AWS Lambda Be sure to have an AWS Account to follow these steps. Connect to the AWS Console Navigate to Lambda Create a function Select Provide your own bootstrap on Amazon Linux 2 as Runtime Select an Architecture that matches the one of the machine where you build the code. Select x86_64 when you build on Intel-based Macs or arm64 for Apple Silicon-based Macs. Upload the ZIP create during step 5 Select the Test tab, enter a test event such as {\"name\": \"Seb\", \"age\": 50} and select Test If the test succeeds, you will see the result: {\"greetings\":\"Hello Seb. You look younger than your age.\"}. Congratulations 🎉! You just wrote, test, build, and deployed a Lambda function written in Swift.","headings":["Overview","High-level instructions"],"kind":"article","summary":"Learn how to create your first project in 3 minutes."},{"kind":"symbol","rawIndexableTextContent":"Initialize an instance with a LambdaHandler defined in the form of a closure with a non-Void return type, an encoder, and a decoder.  The encoder object that will be used to encode the generic Output into a ByteBuffer. The decoder object that will be used to decode the incoming ByteBuffer event into the generic Event type. The handler in the form of a closure.","summary":"Initialize an instance with a LambdaHandler defined in the form of a closure with a non-Void return type, an encoder, and a decoder.","title":"init(encoder:decoder:body:)","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/LambdaRuntime\/init(encoder:decoder:body:)","interfaceLanguage":"swift"}},"headings":[]},{"location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/AWSLambdaRuntimeCore\/tutorials\/AWSLambdaRuntimeCore\/03-prerequisites"}},"kind":"article","title":"Prerequisites","headings":[],"summary":"","rawIndexableTextContent":" This tutorial has been tested on macOS, since this is what most Swift developers work on. It should also work on Linux. To follow the instructions provided by this tutorial you’ll need to meet a couple of prerequisites. We expect you to have a basic understanding of the Swift programming language and be somewhat familiar with the terminal\/console. You can follow this guided tour to have an overview of Swift. You can follow this short tutorial to learn about macOS commands and the Terminal. You’ll need to have a text editor and the Swift toolchain installed.  On macOS, you can use Xcode. On Linux, you must install the Swift runtime and toolchain. On macOS and Linux, you may also use VSCode and the Swift extension for VSCode. To compile your Lambda function to run on AWS Lambda, you will need to install Docker. This tutorial doesn’t go into much detail what Docker is and what it does. Just remember that AWS Lambda functions run on Linux. Therefore, you have to compile your Swift Lambda function code for Linux. Docker allows you to start a Linux virtual machine where you will compile your Swift code before to deploy it on AWS Lambda. This tutorial contains all the commands you will have to type to interact with Docker. Follow the instructions provided by Docker to install Docker on your machine. To deploy your Lambda function on AWS you need an Amazon Web Service (AWS) account. Follow these instructions to create an AWS account."},{"location":{"type":"topLevelPage","reference":{"url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/LambdaHandler","interfaceLanguage":"swift"}},"kind":"symbol","rawIndexableTextContent":"This handler protocol is intended to serve the most common use-cases. This protocol is completely agnostic to any encoding\/decoding – decoding the received event invocation into an Event object and encoding the returned Output object is handled by the library. Thehandle(_:context:) function simply receives the generic Event object as input and returns the generic Output object.  Overview This handler protocol does not support response streaming because the output has to be encoded prior to it being sent, e.g. it is not possible to encode a partial\/incomplete JSON string. This protocol also does not support the execution of background work after the response has been returned – the LambdaWithBackgroundProcessingHandler protocol caters for such use-cases.","title":"LambdaHandler","headings":["Overview"],"summary":"This handler protocol is intended to serve the most common use-cases. This protocol is completely agnostic to any encoding\/decoding – decoding the received event invocation into an Event object and encoding the returned Output object is handled by the library. Thehandle(_:context:) function simply receives the generic Event object as input and returns the generic Output object."},{"rawIndexableTextContent":"A handle(_:responseWriter:context:) wrapper.  Discussion event: The received event. outputWriter: The writer to write the computed response to. context: The LambdaContext containing the invocation’s metadata.","headings":["Discussion"],"location":{"reference":{"url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/LambdaCodableAdapter\/handle(_:responseWriter:context:)","interfaceLanguage":"swift"},"type":"topLevelPage"},"kind":"symbol","title":"handle(_:responseWriter:context:)","summary":"A handle(_:responseWriter:context:) wrapper."},{"title":"Overview","location":{"reference":{"interfaceLanguage":"swift","url":"doc:\/\/AWSLambdaRuntimeCore\/tutorials\/AWSLambdaRuntimeCore\/01-overview"},"type":"topLevelPage"},"headings":[],"summary":"","rawIndexableTextContent":" This tutorial helps you to get started writing your first AWS Lambda function in Swift. You will use the AWSLambdaRuntime package to write code that can be deployed on AWS Lambda. You will learn three things: How to implement simple Lambda function and test it locally How to build a Lambda function for deployment on AWS How to deploy your Lambda function on AWS and invoke it It’s a beginners’ tutorial. The business logic of the function is very simple, it computes the square of a number passed as input parameter. This simplicity allows you to focus on the project setup and the deployment. You will deploy your code using the AWS Management Console. It is the easiest way to get started with AWS Lambda. If you have any questions or recommendations, please leave your feedback on GitHub so that you can get your question answered and this tutorial can be improved. The following instructions were recorded on January 2025 and the AWS Management Console may have changed since then. Feel free to raise an issue if you spot differences with our screenshots","kind":"article"},{"rawIndexableTextContent":" ","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/LambdaResponseWriter\/Output","interfaceLanguage":"swift"}},"kind":"symbol","title":"Output","summary":"","headings":[]},{"summary":"","kind":"symbol","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/LambdaOutputEncoder\/Output","interfaceLanguage":"swift"}},"headings":[],"title":"Output","rawIndexableTextContent":" "},{"title":"handle(_:outputWriter:context:)","location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/LambdaWithBackgroundProcessingHandler\/handle(_:outputWriter:context:)"}},"headings":[],"rawIndexableTextContent":"Implement the business logic of the Lambda function here.  The generic Event object representing the invocation’s input data. The writer to send the computed response to. A call to outputWriter.write(_:) will return the response to the AWS Lambda response endpoint. Any background work can then be executed before returning. The LambdaContext containing the invocation’s metadata.","summary":"Implement the business logic of the Lambda function here.","kind":"symbol"},{"rawIndexableTextContent":"Generic output type. This is the return type of the handle(_:context:) function. ","title":"Output","summary":"Generic output type. This is the return type of the handle(_:context:) function.","kind":"symbol","location":{"reference":{"interfaceLanguage":"swift","url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/LambdaHandler\/Output"},"type":"topLevelPage"},"headings":[]},{"kind":"symbol","rawIndexableTextContent":"Generic input type. The body of the request sent to Lambda will be decoded into this type for the handler to consume. ","summary":"Generic input type. The body of the request sent to Lambda will be decoded into this type for the handler to consume.","title":"Event","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/LambdaHandler\/Event","interfaceLanguage":"swift"}},"headings":[]},{"title":"init(handler:)","summary":"Initializes an instance given a concrete handler.","kind":"symbol","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/LambdaHandlerAdapter\/init(handler:)","interfaceLanguage":"swift"}},"headings":[],"rawIndexableTextContent":"Initializes an instance given a concrete handler.  The LambdaHandler conforming handler that is to be adapted to LambdaWithBackgroundProcessingHandler."},{"location":{"type":"topLevelPage","reference":{"url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/VoidEncoder\/Output","interfaceLanguage":"swift"}},"title":"VoidEncoder.Output","headings":[],"kind":"symbol","summary":"Inherited from LambdaOutputEncoder.Output.","rawIndexableTextContent":"Inherited from LambdaOutputEncoder.Output. "},{"headings":[],"summary":"A LambdaHandler conforming handler object that can be constructed with a closure. Allows for a handler to be defined in a clean manner, leveraging Swift’s trailing closure syntax.","rawIndexableTextContent":"A LambdaHandler conforming handler object that can be constructed with a closure. Allows for a handler to be defined in a clean manner, leveraging Swift’s trailing closure syntax. ","kind":"symbol","title":"ClosureHandler","location":{"reference":{"interfaceLanguage":"swift","url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/ClosureHandler"},"type":"topLevelPage"}},{"rawIndexableTextContent":" ","title":"getRemainingTime()","kind":"symbol","summary":"","location":{"reference":{"interfaceLanguage":"swift","url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/LambdaContext\/getRemainingTime()"},"type":"topLevelPage"},"headings":[]},{"rawIndexableTextContent":" ","title":"init()","kind":"symbol","location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/VoidEncoder\/init()"}},"summary":"","headings":[]},{"summary":"Encode the generic type Output the handler has returned into a ByteBuffer.","kind":"symbol","rawIndexableTextContent":"Encode the generic type Output the handler has returned into a ByteBuffer.  The object to encode into a ByteBuffer. The ByteBuffer where the encoded value will be written to.","location":{"reference":{"interfaceLanguage":"swift","url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/LambdaOutputEncoder\/encode(_:into:)"},"type":"topLevelPage"},"headings":[],"title":"encode(_:into:)"},{"location":{"type":"topLevelPage","reference":{"url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/ClosureHandler\/handle(_:context:)","interfaceLanguage":"swift"}},"headings":[],"title":"handle(_:context:)","summary":"Calls the provided self.body closure with the generic Event object representing the incoming event, and the LambdaContext","rawIndexableTextContent":"Calls the provided self.body closure with the generic Event object representing the incoming event, and the LambdaContext  The generic Event object representing the invocation’s input data. The LambdaContext containing the invocation’s metadata.","kind":"symbol"},{"kind":"symbol","title":"write(_:)","summary":"Write a response part into the stream. Bytes written are streamed continually.","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/LambdaResponseStreamWriter\/write(_:)","interfaceLanguage":"swift"}},"rawIndexableTextContent":"Write a response part into the stream. Bytes written are streamed continually.  The buffer to write.","headings":[]},{"location":{"type":"topLevelPage","reference":{"url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/LambdaHandlerAdapter\/handle(_:outputWriter:context:)","interfaceLanguage":"swift"}},"title":"handle(_:outputWriter:context:)","kind":"symbol","summary":"Passes the generic Event object to the handle(_:context:) function, and the resulting output is then written to LambdaWithBackgroundProcessingHandler’s outputWriter.","headings":[],"rawIndexableTextContent":"Passes the generic Event object to the handle(_:context:) function, and the resulting output is then written to LambdaWithBackgroundProcessingHandler’s outputWriter.  The received event. The writer to write the computed response to. The LambdaContext containing the invocation’s metadata."},{"kind":"symbol","summary":"A StreamingLambdaHandler conforming handler object that can be constructed with a closure. Allows for a handler to be defined in a clean manner, leveraging Swift’s trailing closure syntax.","title":"StreamingClosureHandler","headings":[],"rawIndexableTextContent":"A StreamingLambdaHandler conforming handler object that can be constructed with a closure. Allows for a handler to be defined in a clean manner, leveraging Swift’s trailing closure syntax. ","location":{"reference":{"interfaceLanguage":"swift","url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/StreamingClosureHandler"},"type":"topLevelPage"}},{"rawIndexableTextContent":"This protocol is exactly like LambdaHandler, with the only difference being the added support for executing background work after the result has been sent to the AWS Lambda control plane. This is achieved by not having a return type in the handle function. The output is instead written into a LambdaResponseWriterthat is passed in as an argument, meaning that the handle(_:outputWriter:context:) function is then free to implement any background work after the result has been sent to the AWS Lambda control plane. ","title":"LambdaWithBackgroundProcessingHandler","headings":[],"kind":"symbol","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/LambdaWithBackgroundProcessingHandler","interfaceLanguage":"swift"}},"summary":"This protocol is exactly like LambdaHandler, with the only difference being the added support for executing background work after the result has been sent to the AWS Lambda control plane. This is achieved by not having a return type in the handle function. The output is instead written into a LambdaResponseWriterthat is passed in as an argument, meaning that the handle(_:outputWriter:context:) function is then free to implement any background work after the result has been sent to the AWS Lambda control plane."},{"location":{"type":"topLevelPage","reference":{"url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/StreamingClosureHandler\/handle(_:responseWriter:context:)","interfaceLanguage":"swift"}},"summary":"Calls the provided self.body closure with the ByteBuffer invocation event, the LambdaResponseStreamWriter, and the LambdaContext","headings":[],"rawIndexableTextContent":"Calls the provided self.body closure with the ByteBuffer invocation event, the LambdaResponseStreamWriter, and the LambdaContext  The invocation’s input data. A LambdaResponseStreamWriter to write the invocation’s response to. If no response or error is written to responseWriter an error will be reported to the invoker. The LambdaContext containing the invocation’s metadata.","title":"handle(_:responseWriter:context:)","kind":"symbol"},{"kind":"symbol","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/StreamingClosureHandler\/init(body:)","interfaceLanguage":"swift"}},"rawIndexableTextContent":"Initialize an instance from a handler function in the form of a closure.  The handler function written as a closure.","summary":"Initialize an instance from a handler function in the form of a closure.","title":"init(body:)","headings":[]},{"rawIndexableTextContent":"The request ID, which identifies the request that triggered the function invocation. ","headings":[],"kind":"symbol","summary":"The request ID, which identifies the request that triggered the function invocation.","title":"requestID","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/LambdaContext\/requestID","interfaceLanguage":"swift"}}},{"location":{"reference":{"url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/LambdaResponseStreamWriter","interfaceLanguage":"swift"},"type":"topLevelPage"},"kind":"symbol","title":"LambdaResponseStreamWriter","summary":"A writer object to write the Lambda response stream into. The HTTP response is started lazily. before the first call to write(_:) or writeAndFinish(_:).","headings":[],"rawIndexableTextContent":"A writer object to write the Lambda response stream into. The HTTP response is started lazily. before the first call to write(_:) or writeAndFinish(_:). "},{"rawIndexableTextContent":"Initializes an instance given an encoder, decoder, and a handler with a non-Void output.  The encoder object that will be used to encode the generic Output obtained from the handler’s outputWriter into a ByteBuffer. The decoder object that will be used to decode the received ByteBuffer event into the generic Event type served to the handler. The handler object.","kind":"symbol","location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/LambdaCodableAdapter\/init(encoder:decoder:handler:)"}},"title":"init(encoder:decoder:handler:)","summary":"Initializes an instance given an encoder, decoder, and a handler with a non-Void output.","headings":[]},{"title":"writeAndFinish(_:)","summary":"Write a response part into the stream and then end the stream as well as the underlying HTTP response.","headings":[],"kind":"symbol","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/LambdaResponseStreamWriter\/writeAndFinish(_:)","interfaceLanguage":"swift"}},"rawIndexableTextContent":"Write a response part into the stream and then end the stream as well as the underlying HTTP response.  The buffer to write."},{"summary":"Adapts a LambdaHandler conforming handler to conform to LambdaWithBackgroundProcessingHandler.","rawIndexableTextContent":"Adapts a LambdaHandler conforming handler to conform to LambdaWithBackgroundProcessingHandler. ","location":{"reference":{"interfaceLanguage":"swift","url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/LambdaHandlerAdapter"},"type":"topLevelPage"},"kind":"symbol","headings":[],"title":"LambdaHandlerAdapter"},{"location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/LambdaContext\/traceID"}},"kind":"symbol","rawIndexableTextContent":"The AWS X-Ray tracing header. ","summary":"The AWS X-Ray tracing header.","title":"traceID","headings":[]},{"location":{"reference":{"url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/LambdaHandler\/handle(_:context:)","interfaceLanguage":"swift"},"type":"topLevelPage"},"title":"handle(_:context:)","kind":"symbol","summary":"Implement the business logic of the Lambda function here.","headings":["Return Value"],"rawIndexableTextContent":"Implement the business logic of the Lambda function here.  The generic Event object representing the invocation’s input data. The LambdaContext containing the invocation’s metadata. Return Value A generic Output object representing the computed result."},{"summary":"Sends the generic Output object (representing the computed result of the handler) to the AWS Lambda response endpoint. This function simply serves as a mechanism to return the computed result from a handler function without an explicit return.","kind":"symbol","headings":[],"rawIndexableTextContent":"Sends the generic Output object (representing the computed result of the handler) to the AWS Lambda response endpoint. This function simply serves as a mechanism to return the computed result from a handler function without an explicit return. ","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/LambdaResponseWriter\/write(_:)","interfaceLanguage":"swift"}},"title":"write(_:)"},{"rawIndexableTextContent":"A LambdaResponseStreamWriter wrapper that conforms to LambdaResponseWriter. ","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/LambdaCodableResponseWriter","interfaceLanguage":"swift"}},"summary":"A LambdaResponseStreamWriter wrapper that conforms to LambdaResponseWriter.","title":"LambdaCodableResponseWriter","kind":"symbol","headings":[]},{"kind":"symbol","title":"init(handler:eventLoop:logger:)","headings":[],"location":{"type":"topLevelPage","reference":{"url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/LambdaRuntime\/init(handler:eventLoop:logger:)","interfaceLanguage":"swift"}},"rawIndexableTextContent":" ","summary":""},{"kind":"symbol","summary":"Used with LambdaWithBackgroundProcessingHandler. A mechanism to “return” an output from handle(_:outputWriter:context:) without the function needing to have a return type and exit at that point. This allows for background work to be executed after a response has been sent to the AWS Lambda response endpoint.","rawIndexableTextContent":"Used with LambdaWithBackgroundProcessingHandler. A mechanism to “return” an output from handle(_:outputWriter:context:) without the function needing to have a return type and exit at that point. This allows for background work to be executed after a response has been sent to the AWS Lambda response endpoint. ","headings":[],"location":{"type":"topLevelPage","reference":{"url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/LambdaResponseWriter","interfaceLanguage":"swift"}},"title":"LambdaResponseWriter"},{"rawIndexableTextContent":"Inherited from CustomDebugStringConvertible.debugDescription. ","kind":"symbol","headings":[],"summary":"Inherited from CustomDebugStringConvertible.debugDescription.","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/LambdaContext\/debugDescription","interfaceLanguage":"swift"}},"title":"debugDescription"},{"headings":[],"kind":"symbol","location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/LambdaCodableAdapter\/init(decoder:handler:)"}},"summary":"Initializes an instance given a decoder, and a handler with a Void output.","title":"init(decoder:handler:)","rawIndexableTextContent":"Initializes an instance given a decoder, and a handler with a Void output.  The decoder object that will be used to decode the received ByteBuffer event into the generic Event type served to the handler. The handler object."},{"rawIndexableTextContent":"A step-by-step tutorial to learn how to implement, build, test, and deploy your first Lambda function written in Swift. ","title":"Your First Lambda Function Written in Swift","kind":"overview","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/AWSLambdaRuntimeCore\/tutorials\/table-of-content","interfaceLanguage":"swift"}},"summary":"A step-by-step tutorial to learn how to implement, build, test, and deploy your first Lambda function written in Swift.","headings":["Before getting started","Your first Lambda function in Swift","Deploy your code to the cloud"]},{"summary":"End the response stream and the underlying HTTP response.","kind":"symbol","headings":[],"location":{"reference":{"interfaceLanguage":"swift","url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/LambdaResponseStreamWriter\/finish()"},"type":"topLevelPage"},"title":"finish()","rawIndexableTextContent":"End the response stream and the underlying HTTP response. "},{"location":{"type":"topLevelPage","reference":{"url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/LambdaContext\/clientContext","interfaceLanguage":"swift"}},"summary":"For invocations from the AWS Mobile SDK, data about the client application and device.","title":"clientContext","headings":[],"rawIndexableTextContent":"For invocations from the AWS Mobile SDK, data about the client application and device. ","kind":"symbol"},{"kind":"symbol","summary":"Inherited from LambdaResponseWriter.write(_:).","rawIndexableTextContent":"Inherited from LambdaResponseWriter.write(_:). ","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/LambdaCodableResponseWriter\/write(_:)","interfaceLanguage":"swift"}},"title":"write(_:)","headings":[]},{"summary":"Lambda runtime context. The Lambda runtime generates and passes the LambdaContext to the Lambda handler as an argument.","title":"LambdaContext","headings":[],"kind":"symbol","location":{"reference":{"url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/LambdaContext","interfaceLanguage":"swift"},"type":"topLevelPage"},"rawIndexableTextContent":"Lambda runtime context. The Lambda runtime generates and passes the LambdaContext to the Lambda handler as an argument. "},{"kind":"symbol","summary":"The protocol an encoder must conform to so that it can be used with LambdaCodableAdapter to encode the generic Output object into a ByteBuffer.","headings":[],"rawIndexableTextContent":"The protocol an encoder must conform to so that it can be used with LambdaCodableAdapter to encode the generic Output object into a ByteBuffer. ","title":"LambdaOutputEncoder","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/LambdaOutputEncoder","interfaceLanguage":"swift"}}},{"headings":[],"rawIndexableTextContent":"The default EventLoop the Lambda is scheduled on. ","kind":"symbol","summary":"The default EventLoop the Lambda is scheduled on.","title":"defaultEventLoop","location":{"reference":{"url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/Lambda\/defaultEventLoop","interfaceLanguage":"swift"},"type":"topLevelPage"}},{"rawIndexableTextContent":"Initialize an instance with a StreamingLambdaHandler in the form of a closure.  The handler in the form of a closure.","title":"init(body:)","location":{"reference":{"interfaceLanguage":"swift","url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/LambdaRuntime\/init(body:)"},"type":"topLevelPage"},"summary":"Initialize an instance with a StreamingLambdaHandler in the form of a closure.","headings":[],"kind":"symbol"},{"headings":["When to use AWS Lambda"],"kind":"article","location":{"reference":{"interfaceLanguage":"swift","url":"doc:\/\/AWSLambdaRuntimeCore\/tutorials\/AWSLambdaRuntimeCore\/02-what-is-lambda"},"type":"topLevelPage"},"title":"What is AWS Lambda","rawIndexableTextContent":" AWS Lambda is a compute service that lets you run code without provisioning or managing servers. Lambda runs your code on a high-availability compute infrastructure and performs all of the administration of the compute resources, including server and operating system maintenance, capacity provisioning and automatic scaling, and logging. With Lambda, you can run code for virtually any type of application or backend service. All you need to do is supply your code in one of the languages that Lambda supports, including Swift. You organize your code into Lambda functions. Lambda runs your function only when needed and scales automatically, from a few requests per day to thousands per second. You pay only for the compute time that you consume—there is no charge when your code is not running. For more information, see AWS Lambda Pricing. Lambda is a highly available service. For more information, see the AWS Lambda Service Level Agreement. When to use AWS Lambda Lambda is an ideal compute service for many application scenarios, as long as you can run your application code using the Lambda standard runtime environment and within the resources that Lambda provides. For example, you can use Lambda for: Mobile backends: Build backends using Lambda and Amazon API Gateway to authenticate and process API requests. Use AWS Amplify to easily integrate your backend with your iOS, Android, Web, and React Native front ends. Web applications: Combine Lambda with other AWS services to build powerful web applications that automatically scale up and down and run in a highly available configuration across multiple data centers. File processing: Use Amazon Simple Storage Service (Amazon S3) to trigger Lambda data processing in real time after an upload. Stream processing: Use Lambda and Amazon Kinesis to process real-time streaming data for application activity tracking, transaction order processing, click stream analysis, data cleansing, log filtering, indexing, social media analysis, Internet of Things (IoT) device data telemetry, and metering. IoT backends: Build serverless backends using Lambda to handle web, mobile, IoT, and third-party API requests. When using Lambda, you are responsible only for your code. Lambda manages the compute fleet that offers a balance of memory, CPU, network, and other resources to run your code. Because Lambda manages these resources, you cannot log in to compute instances or customize the operating system on provided runtimes. Lambda performs operational and administrative activities on your behalf, including managing capacity, monitoring, and logging your Lambda functions.","summary":""},{"title":"LambdaRuntime","headings":[],"summary":"","rawIndexableTextContent":" ","kind":"symbol","location":{"reference":{"url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/LambdaRuntime","interfaceLanguage":"swift"},"type":"topLevelPage"}},{"kind":"symbol","summary":"Initialize an instance with a LambdaHandler defined in the form of a closure with a Void return type, an encoder, and a decoder.","headings":[],"rawIndexableTextContent":"Initialize an instance with a LambdaHandler defined in the form of a closure with a Void return type, an encoder, and a decoder.  The decoder object that will be used to decode the incoming ByteBuffer event into the generic Event type. The handler in the form of a closure.","location":{"reference":{"url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/LambdaRuntime\/init(decoder:body:)","interfaceLanguage":"swift"},"type":"topLevelPage"},"title":"init(decoder:body:)"},{"kind":"symbol","title":"LambdaEventDecoder","headings":[],"rawIndexableTextContent":"The protocol a decoder must conform to so that it can be used with LambdaCodableAdapter to decode incoming ByteBuffer events. ","location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/LambdaEventDecoder"}},"summary":"The protocol a decoder must conform to so that it can be used with LambdaCodableAdapter to decode incoming ByteBuffer events."},{"rawIndexableTextContent":"Decode the ByteBuffer representing the received event into the generic Event type the handler will receive.  The type of the object to decode the buffer into. The buffer to be decoded. Return Value An object containing the decoded data.","headings":["Return Value"],"title":"decode(_:from:)","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/LambdaEventDecoder\/decode(_:from:)","interfaceLanguage":"swift"}},"kind":"symbol","summary":"Decode the ByteBuffer representing the received event into the generic Event type the handler will receive."},{"title":"AWSLambdaRuntimeCore","kind":"symbol","location":{"reference":{"url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore","interfaceLanguage":"swift"},"type":"topLevelPage"},"rawIndexableTextContent":"An AWS Lambda runtime for the Swift programming language Overview Many modern systems have client components like iOS, macOS or watchOS applications as well as server components that those clients interact with. Serverless functions are often the easiest and most efficient way for client application developers to extend their applications into the cloud. Serverless functions are increasingly becoming a popular choice for running event-driven or otherwise ad-hoc compute tasks in the cloud. They power mission critical microservices and data intensive workloads. In many cases, serverless functions allow developers to more easily scale and control compute costs given their on-demand nature. When using serverless functions, attention must be given to resource utilization as it directly impacts the costs of the system. This is where Swift shines! With its low memory footprint, deterministic performance, and quick start time, Swift is a fantastic match for the serverless functions architecture. Combine this with Swift’s developer friendliness, expressiveness, and emphasis on safety, and we have a solution that is great for developers at all skill levels, scalable, and cost effective. Swift AWS Lambda Runtime was designed to make building Lambda functions in Swift simple and safe. The library is an implementation of the AWS Lambda Runtime API and uses an embedded asynchronous HTTP client based on SwiftNIO that is fine-tuned for performance in the AWS Lambda Runtime context. The library provides a multi-tier API that allows building a range of Lambda functions: from quick and simple closures to complex, performance-sensitive event handlers.","summary":"An AWS Lambda runtime for the Swift programming language","headings":["Overview"]},{"location":{"reference":{"url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/ClosureHandler\/init(body:)-9o0yg","interfaceLanguage":"swift"},"type":"topLevelPage"},"headings":[],"rawIndexableTextContent":"Initialize with a closure handler over a generic Input type, and a Void Output.  The handler function written as a closure.","title":"init(body:)","summary":"Initialize with a closure handler over a generic Input type, and a Void Output.","kind":"symbol"},{"location":{"type":"topLevelPage","reference":{"url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/ClosureHandler\/init(body:)-5sz8r","interfaceLanguage":"swift"}},"title":"init(body:)","headings":[],"kind":"symbol","rawIndexableTextContent":"Initialize with a closure handler over generic Input and Output types.  The handler function written as a closure.","summary":"Initialize with a closure handler over generic Input and Output types."},{"headings":["Overview","Prerequisites","Choosing the AWS Region where to deploy","The Lambda execution IAM role","Deploy your Lambda function with the AWS Console","Create the function","Invoke the function","Delete the function","Deploy your Lambda function with the AWS Command Line Interface (CLI)","Create the function","Invoke the function","Delete the function","Deploy your Lambda function with AWS Serverless Application Model (SAM)","Create the function","Invoke the function","Delete the function","Deploy your Lambda function with the AWS Cloud Development Kit (CDK)","Create a CDK project","Deploy the infrastructure","Invoke your Lambda function","Delete the infrastructure","Third-party tools"],"location":{"type":"topLevelPage","reference":{"url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/Deployment","interfaceLanguage":"swift"}},"kind":"article","rawIndexableTextContent":"Learn how to deploy your Swift Lambda functions to AWS. Overview There are multiple ways to deploy your Swift code to AWS Lambda. The very first time, you’ll probably use the AWS Console to create a new Lambda function and upload your code as a zip file. However, as you iterate on your code, you’ll want to automate the deployment process. To take full advantage of the cloud, we recommend using Infrastructure as Code (IaC) tools like the AWS Serverless Application Model (SAM) or AWS Cloud Development Kit (CDK). These tools allow you to define your infrastructure and deployment process as code, which can be version-controlled and automated. In this section, we show you how to deploy your Swift Lambda functions using different AWS Tools. Alternatively, you might also consider using popular third-party tools like Serverless Framework, Terraform, or Pulumi to deploy Lambda functions and create and manage AWS infrastructure. Here is the content of this guide: Prerequisites Choosing the AWS Region where to deploy The Lambda execution IAM role Deploy your Lambda function with the AWS Console Deploy your Lambda function with the AWS Command Line Interface (CLI) Deploy your Lambda function with AWS Serverless Application Model (SAM) Deploy your Lambda function with AWS Cloud Development Kit (CDK) Third-party tools Prerequisites Your AWS Account To deploy a Lambda function on AWS, you need an AWS account. If you don’t have one yet, you can create a new account at aws.amazon.com. It takes a few minutes to register. A credit card is required. We do not recommend using the root credentials you entered at account creation time for day-to-day work. Instead, create an Identity and Access Manager (IAM) user with the necessary permissions and use its credentials. Follow the steps in Create an IAM User in your AWS account. We suggest to attach the AdministratorAccess policy to the user for the initial setup. For production workloads, you should follow the principle of least privilege and grant only the permissions required for your users. The ‘AdministratorAccess’ gives the user permission to manage all resources on the AWS account. AWS Security Credentials AWS Security Credentials are required to access the AWS console, AWS APIs, or to let tools access your AWS account. AWS Security Credentials can be long-term credentials (for example, an Access Key ID and a Secret Access Key attached to your IAM user) or temporary credentials obtained via other AWS API, such as when accessing AWS through single sign-on (SSO) or when assuming an IAM role. To follow the steps in this guide, you need to know your AWS Access Key ID and Secret Access Key. If you don’t have them, you can create them in the AWS Management Console. Follow the steps in Creating access keys for an IAM user. When you use SSO with your enterprise identity tools (such as Microsoft entra ID –formerly Active Directory–, Okta, and others) or when you write scripts or code assuming an IAM role, you receive temporary credentials. These credentials are valid for a limited time, have a limited scope, and are rotated automatically. You can use them in the same way as long-term credentials. In addition to an AWS Access Key and Secret Access Key, temporary credentials include a session token. Here is a typical set of temporary credentials (redacted for security).  A Swift Lambda function to deploy. You need a Swift Lambda function to deploy. If you don’t have one yet, you can use one of the examples in the Examples directory. Compile and package the function using the following command  This command creates a ZIP file with the compiled Swift code. The ZIP file is located in the .build\/plugins\/AWSLambdaPackager\/outputs\/AWSLambdaPackager\/MyLambda\/MyLambda.zip folder. The name of the ZIP file depends on the target name you entered in the Package.swift file. Choosing the AWS Region where to deploy AWS Global infrastructure spans over 34 geographic Regions (and continuously expanding). When you create a resource on AWS, such as a Lambda function, you have to select a geographic region where the resource will be created. The two main factors to consider to select a Region are the physical proximity with your users and geographical compliance. Physical proximity helps you reduce the network latency between the Lambda function and your customers. For example, when the majority of your users are located in South-East Asia, you might consider deploying in the Singapore, the Malaysia, or Jakarta Region. Geographical compliance, also known as data residency compliance, involves following location-specific regulations about how and where data can be stored and processed. The Lambda execution IAM role A Lambda execution role is an AWS Identity and Access Management (IAM) role that grants your Lambda function the necessary permissions to interact with other AWS services and resources. Think of it as a security passport that determines what your function is allowed to do within AWS. For example, if your Lambda function needs to read files from Amazon S3, write logs to Amazon CloudWatch, or access an Amazon DynamoDB table, the execution role must include the appropriate permissions for these actions. When you create a Lambda function, you must specify an execution role. This role contains two main components: a trust policy that allows the Lambda service itself to assume the role, and permission policies that determine what AWS resources the function can access. By default, Lambda functions get basic permissions to write logs to CloudWatch Logs, but any additional permissions (like accessing S3 buckets or sending messages to SQS queues) must be explicitly added to the role’s policies. Following the principle of least privilege, it’s recommended to grant only the minimum permissions necessary for your function to operate, helping maintain the security of your serverless applications. Deploy your Lambda function with the AWS Console In this section, we deploy the HelloWorld example function using the AWS Console. The HelloWorld function is a simple function that takes a String as input and returns a String. Authenticate on the AWS console using your IAM username and password. On the top right side, select the AWS Region where you want to deploy, then navigate to the Lambda section.  Create the function Select Create a function to create a function.  Select Author function from scratch. Enter a Function name (HelloWorld) and select Amazon Linux 2 as Runtime. Select the architecture. When you compile your Swift code on a x84_64 machine, such as an Intel Mac, select x86_64. When you compile your Swift code on an Arm machine, such as the Apple Silicon M1 or more recent, select arm64. Select Create function  On the right side, select Upload from and select .zip file.  Select the zip file created with the swift package archive --allow-network-connections docker command as described in the Prerequisites section. Select Save  You’re now ready to test your function. Invoke the function Select the Test tab in the console and prepare a payload to send to your Lambda function. In this example, you’ve deployed the HelloWorld example function. As explained, the function takes a String as input and returns a String. we will therefore create a test event with a JSON payload that contains a String. Select Create new event. Enter an Event name. Enter \"Swift on Lambda\" as Event JSON. Note that the payload must be a valid JSON document, hence we use surrounding double quotes (\"). Select Test on the upper right side of the screen.  The response of the invocation and additional meta data appear in the green section of the page. You can see the response from the Swift code: Hello Swift on Lambda. The function consumed 109.60ms of execution time, out of this 83.72ms where spent to initialize this new runtime. This initialization time is known as Lambda cold start time. Lambda cold start time refers to the initial delay that occurs when a Lambda function is invoked for the first time or after being idle for a while. Cold starts happen because AWS needs to provision and initialize a new container, load your code, and start your runtime environment (in this case, the Swift runtime). This delay is particularly noticeable for the first invocation, but subsequent invocations (known as “warm starts”) are typically much faster because the container and runtime are already initialized and ready to process requests. Cold starts are an important consideration when architecting serverless applications, especially for latency-sensitive workloads. Usually, compiled languages, such as Swift, Go, and Rust, have shorter cold start times compared to interpreted languages, such as Python, Java, Ruby, and Node.js.  AWS lambda charges usage per number of invocations and the CPU time, rounded to the next millisecond. AWS Lambda offers a generous free-tier of 1 million invocation each month and 400,000 GB-seconds of compute time per month. See Lambda pricing for the details. Delete the function When you’re finished with testing, you can delete the Lambda function and the IAM execution role that the console created automatically. While you are on the HelloWorld function page in the AWS console, select Actions, then Delete function in the menu on the top-right part of the page.  Then, navigate to the IAM section of the AWS console. Select Roles on the right-side menu and search for HelloWorld. The console appended some random characters to role name. The name you see on your console is different that the one on the screenshot. Select the HelloWorld-role-xxxx role and select Delete. Confirm the deletion by entering the role name again, and select Delete on the confirmation box.  Deploy your Lambda function with the AWS Command Line Interface (CLI) You can deploy your Lambda function using the AWS Command Line Interface (CLI). The CLI is a unified tool to manage your AWS services from the command line and automate your operations through scripts. The CLI is available for Windows, macOS, and Linux. Follow the installation and configuration instructions in the AWS CLI User Guide. In this example, we’re building the HelloWorld example from the Examples directory. Create the function To create a function, you must first create the function execution role and define the permission. Then, you create the function with the create-function command. The command assumes you’ve already created the ZIP file with the swift package archive --allow-network-connections docker command, as described in the Prerequisites section.  The --architectures flag is only required when you build the binary on an Apple Silicon machine (Apple M1 or more recent). It defaults to x64. To update the function, use the update-function-code command after you’ve recompiled and archived your code again with the swift package archive command.  Invoke the function Use the invoke-function command to invoke the function. You can pass a well-formed JSON payload as input to the function. The payload must be encoded in base64. The CLI returns the status code and stores the response in a file.  Delete the function To cleanup, first delete the Lambda funtion, then delete the IAM role.  Deploy your Lambda function with AWS Serverless Application Model (SAM) AWS Serverless Application Model (SAM) is an open-source framework for building serverless applications. It provides a simplified way to define the Amazon API Gateway APIs, AWS Lambda functions, and Amazon DynamoDB tables needed by your serverless application. You can define your serverless application in a single file, and SAM will use it to deploy your function and all its dependencies. To use SAM, you need to install the SAM CLI on your machine. The SAM CLI provides a set of commands to package, deploy, and manage your serverless applications. Use SAM when you want to deploy more than a Lambda function. SAM helps you to create additional resources like an API Gateway, an S3 bucket, or a DynamoDB table, and manage the permissions between them. Create the function We assume your Swift function is compiled and packaged, as described in the Prerequisites section. When using SAM, you describe the infrastructure you want to deploy in a YAML file. The file contains the definition of the Lambda function, the IAM role, and the permissions needed by the function. The SAM CLI uses this file to package and deploy your function. You can create a SAM template to define a REST API implemented by AWS API Gateway and a Lambda function with the following command  In this example, the Lambda function must accept an APIGateway v2 JSON payload as input parameter and return a valid APIGAteway v2 JSON response. See the example code in the APIGateway example README file. To deploy the function with SAM, use the sam deploy command. The very first time you deploy a function, you should use the --guided flag to configure the deployment. The command will ask you a series of questions to configure the deployment. Here is the command to deploy the function with SAM:  To update your function or any other AWS service defined in your YAML file, you can use the sam deploy command without the --guided flag. Invoke the function SAM allows you to invoke the function locally and remotely. Local invocations allows you to test your code before uploading it. It requires docker to run.  If you’ve previously authenticated to Amazon ECR Public and your auth token has expired, you may receive an authentication error when attempting to do unauthenticated docker pulls from Amazon ECR Public. To resolve this issue, it may be necessary to run docker logout public.ecr.aws to avoid the error. This will result in an unauthenticated pull. For more information, see Authentication issues. Remote invocations are done with the sam remote invoke command.  SAM allows you to access the function logs from Amazon Cloudwatch.  You can also tail the logs with the -t, --tail flag. Delete the function SAM allows you to delete your function and all infrastructure that is defined in the YAML template with just one command.  Deploy your Lambda function with the AWS Cloud Development Kit (CDK) The AWS Cloud Development Kit is an open-source software development framework to define cloud infrastructure in code and provision it through AWS CloudFormation. The CDK provides high-level constructs that preconfigure AWS resources with best practices, and you can use familiar programming languages like TypeScript, Javascript, Python, Java, C#, and Go to define your infrastructure. To use the CDK, you need to install the CDK CLI on your machine. The CDK CLI provides a set of commands to manage your CDK projects. Use the CDK when you want to define your infrastructure in code and manage the deployment of your Lambda function and other AWS services. This example deploys the [APIGateway]((https:\/\/github.com\/swift-server\/swift-aws-lambda-runtime\/blob\/main\/Examples\/APIGateway\/) example code.  It comprises a Lambda function that implements a REST API and an API Gateway to expose the function over HTTPS. Create a CDK project To create a new CDK project, use the cdk init command. The command creates a new directory with the project structure and the necessary files to define your infrastructure.  In this example, the code to create a Swift Lambda function with the CDK is written in TypeScript. The following code creates a new Lambda function with the swift runtime. It requires the @aws-cdk\/aws-lambda package to define the Lambda function. You can install the dependency with the following command:  Then, in the lib folder, create a new file named swift-lambda-stack.ts with the following content:  The code assumes you already built and packaged the APIGateway Lambda function with the swift package archive --allow-network-connections docker command, as described in the Prerequisites section. You can write code to add an API Gateway to invoke your Lambda function. The following code creates an HTTP API Gateway that triggers the Lambda function.  Deploy the infrastructure To deploy the infrastructure, type the following commands.  Invoke your Lambda function To invoke the Lambda function, use this curl command line.  Be sure to replace the URL with the API Gateway endpoint returned in the previous step. This should print a JSON similar to  If you have jq installed, you can use it to pretty print the output.  Delete the infrastructure When done testing, you can delete the infrastructure with this command.  Third-party tools We welcome contributions to this section. If you have experience deploying Swift Lambda functions with third-party tools like Serverless Framework, Terraform, or Pulumi, please share your knowledge with the community.","title":"Deploying your Swift Lambda functions","summary":"Learn how to deploy your Swift Lambda functions to AWS."},{"headings":[],"summary":"Initializes an instance given an encoder and an underlying LambdaResponseStreamWriter.","title":"init(encoder:streamWriter:)","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/LambdaCodableResponseWriter\/init(encoder:streamWriter:)","interfaceLanguage":"swift"}},"kind":"symbol","rawIndexableTextContent":"Initializes an instance given an encoder and an underlying LambdaResponseStreamWriter.  The encoder object that will be used to encode the generic Output into a ByteBuffer, which will then be passed to streamWriter. The underlying LambdaResponseStreamWriter that will be wrapped."},{"location":{"reference":{"url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/StreamingLambdaHandler","interfaceLanguage":"swift"},"type":"topLevelPage"},"summary":"The base handler protocol that receives a ByteBuffer representing the incoming event and returns the response as a ByteBuffer too. This handler protocol supports response streaming. Bytes can be streamed outwards through the LambdaResponseStreamWriter passed as an argument in the handle(_:responseWriter:context:) function. Background work can also be executed after returning the response. After closing the response stream by calling finish() or writeAndFinish(_:), the handle(_:responseWriter:context:) function is free to execute any background work.","rawIndexableTextContent":"The base handler protocol that receives a ByteBuffer representing the incoming event and returns the response as a ByteBuffer too. This handler protocol supports response streaming. Bytes can be streamed outwards through the LambdaResponseStreamWriter passed as an argument in the handle(_:responseWriter:context:) function. Background work can also be executed after returning the response. After closing the response stream by calling finish() or writeAndFinish(_:), the handle(_:responseWriter:context:) function is free to execute any background work. ","title":"StreamingLambdaHandler","headings":[],"kind":"symbol"},{"location":{"type":"topLevelPage","reference":{"url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/StreamingLambdaHandler\/handle(_:responseWriter:context:)","interfaceLanguage":"swift"}},"headings":[],"rawIndexableTextContent":"The handler function – implement the business logic of the Lambda function here.  The invocation’s input data. A LambdaResponseStreamWriter to write the invocation’s response to. If no response or error is written to responseWriter an error will be reported to the invoker. The LambdaContext containing the invocation’s metadata.","kind":"symbol","title":"handle(_:responseWriter:context:)","summary":"The handler function – implement the business logic of the Lambda function here."},{"title":"LambdaCodableAdapter","summary":"Adapts a LambdaWithBackgroundProcessingHandler conforming handler to conform to StreamingLambdaHandler.","rawIndexableTextContent":"Adapts a LambdaWithBackgroundProcessingHandler conforming handler to conform to StreamingLambdaHandler. ","location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/LambdaCodableAdapter"}},"headings":[],"kind":"symbol"},{"headings":[],"rawIndexableTextContent":"The timestamp that the function times out. ","summary":"The timestamp that the function times out.","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/LambdaContext\/deadline","interfaceLanguage":"swift"}},"title":"deadline","kind":"symbol"},{"kind":"symbol","location":{"reference":{"url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/LambdaWithBackgroundProcessingHandler\/Event","interfaceLanguage":"swift"},"type":"topLevelPage"},"title":"Event","summary":"Generic input type. The body of the request sent to Lambda will be decoded into this type for the handler to consume.","headings":[],"rawIndexableTextContent":"Generic input type. The body of the request sent to Lambda will be decoded into this type for the handler to consume. "},{"location":{"type":"topLevelPage","reference":{"url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/VoidEncoder\/encode(_:into:)","interfaceLanguage":"swift"}},"summary":"Inherited from LambdaOutputEncoder.encode(_:into:).","headings":[],"kind":"symbol","rawIndexableTextContent":"Inherited from LambdaOutputEncoder.encode(_:into:). ","title":"encode(_:into:)"},{"summary":"","headings":[],"rawIndexableTextContent":" ","kind":"symbol","title":"VoidEncoder","location":{"reference":{"url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/VoidEncoder","interfaceLanguage":"swift"},"type":"topLevelPage"}},{"title":"Output","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/LambdaWithBackgroundProcessingHandler\/Output","interfaceLanguage":"swift"}},"kind":"symbol","summary":"Generic output type. This is the type that the handle function will send through the LambdaResponseWriter.","headings":[],"rawIndexableTextContent":"Generic output type. This is the type that the handle function will send through the LambdaResponseWriter. "},{"location":{"type":"topLevelPage","reference":{"url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/0001-v2-api","interfaceLanguage":"swift"}},"title":"v2 API proposal for swift-aws-lambda-runtime","headings":["Overview","Motivation","Current Limitations","EventLoop interfaces","No ownership of the main() function","Non-trivial transition from SimpleLambdaHandler to LambdaHandler","Does not integrate well with swift-service-lifecycle in a structured concurrency manner","Verbose Codable support","New features","Support response streaming","Scheduling background work","Proposed Solution","async\/await-first API","Providing ownership of main() and support for swift-service-lifecycle","Simplifying Codable support","Detailed Solution","LambdaResponseStreamWriter","LambdaContext","Handlers","StreamingLambdaHandler","LambdaHandler:","LambdaWithBackgroundProcessingHandler:","Example Usage:","Handler Adapters","LambdaRuntime","Lambda","Codable support","LambdaHandlerAdapter","LambdaCodableAdapter","LambdaEventDecoder and LambdaOutputEncoder protocols","Handler as a Closure","ClosureHandler","Alternatives considered","[UInt8] instead of ByteBuffer","Users create a LambdaResponse, that supports streaming instead of being passed a LambdaResponseStreamWriter","Adding a function `addBackgroundTask(_ body: sending @escaping () async -> ())` in `LambdaContext`","Making LambdaResponseStreamWriter and LambdaResponseWriter ~Copyable","A word about versioning"],"rawIndexableTextContent":"swift-aws-lambda-runtime is an important library for the Swift on Server ecosystem. The initial API was written before async\/await was introduced to Swift. When async\/await was introduced, shims were added to bridge between the underlying SwiftNIO EventLoop interfaces and async\/await. However, just like gRPC-swift and postgres-nio, we now want to shift to solely using async\/await instead of EventLoop interfaces. For this, large parts of the current API have to be reconsidered. Overview Versions: v1 (2024-08-07): Initial version v1.1: Remove the reportError(_:) method from LambdaResponseStreamWriter and instead make the handle(...) method of StreamingLambdaHandler throwing. Remove the addBackgroundTask(_:) method from LambdaContext due to structured concurrency concerns and introduce the LambdaWithBackgroundProcessingHandler protocol as a solution. Introduce LambdaHandlerAdapter, which adapts handlers conforming to LambdaHandler with LambdaWithBackgroundProcessingHandler. Update LambdaCodableAdapter to now be generic over any handler conforming to LambdaWithBackgroundProcessingHandler instead of LambdaHandler. v1.2: Remove ~Copyable from LambdaResponseStreamWriter and LambdaResponseWriter. Instead throw an error when finish() is called multiple times or when write\/writeAndFinish is called after finish(). Motivation Current Limitations EventLoop interfaces The current API extensively uses the EventLoop family of interfaces from SwiftNIO in many areas. To use these interfaces correctly though, it requires developers to exercise great care and understand the various transform methods that are used to work with EventLoops and EventLoopFutures. This results in a lot of cognitive complexity and makes the code in the current API hard to reason about and maintain. For these reasons, the overarching trend in the Swift on Server ecosystem is to shift to newer, more readable, Swift concurrency constructs and de-couple from SwiftNIO’s EventLoop interfaces. No ownership of the main() function A Lambda function can currently be implemented through conformance to the various handler protocols defined in AWSLambdaRuntimeCore\/LambdaHandler. Each of these protocols have an extension which implements a static func main(). This allows users to annotate their LambdaHandler conforming object with @main. The static func main() calls the internal Lambda.run() function, which starts the Lambda function. Since the Lambda.run() method is internal, users cannot override the default implementation. This has proven challenging for users who want to set up global properties before the Lambda starts-up. Setting up global properties is required to customize the Swift Logging, Metric and Tracing backend. Non-trivial transition from SimpleLambdaHandler to LambdaHandler The SimpleLambdaHandler protocol provides a quick and easy way to implement a basic Lambda function. It only requires an implementation of the handle function where the business logic of the Lambda function can be written. SimpleLambdaHandler is perfectly sufficient for small use-cases as the user does not need to spend much time looking into the library. However, SimpleLambdaHandler cannot be used when services such as a database client need to be initialized before the Lambda runtime starts and then also gracefully shutdown prior to the runtime terminating. This is because the only way to register termination logic is through the LambdaInitializationContext (containing a field terminator: LambdaTerminator) which is created and used internally within LambdaRuntime and never exposed through SimpleLambdaHandler. For such use-cases, other handler protocols like LambdaHandler must be used. LambdaHandler exposes a context argument of type LambdaInitializationContext through its initializer. Within the initializer, required services can be initialized and their graceful shutdown logic can be registered with the context.terminator.register function. Yet, LambdaHandler is quite cumbersome to use in such use-cases as users have to deviate from the established norms of the Swift on Server ecosystem in order to cleanly manage the lifecycle of the services intended to be used. This is because the convenient swift-service-lifecycle v2 library — which is commonly used for cleanly managing the lifecycles of required services and widely supported by many libraries — cannot be used in a structured concurrency manner. Does not integrate well with swift-service-lifecycle in a structured concurrency manner The Lambda runtime can only be started using the internal Lambda.run() function. This function is called by the main() function defined by the LambdaHandler protocol, preventing users from injecting initialized services into the runtime prior to it starting. As shown below, this forces users to use an unstructured concurrency approach and manually initialize services, leading to the issue of the user then perhaps forgetting to gracefully shutdown the initialized services:  Verbose Codable support In the current API, there are extensions and Codable wrapper classes for decoding events and encoding computed responses for each different handler protocol and for both String and JSON formats. This has resulted in a lot of boilerplate code which can very easily be made generic and simplified in v2. New features Support response streaming In April 2023 AWS introduced support for response streaming in Lambda. The current API does not support streaming. For v2 we want to change this. Scheduling background work In May AWS described in a blog post that you can run background tasks in Lambda until the runtime asks for more work from the control plane. We want to support this by adding new API that allows background processing, even after the response has been returned. Proposed Solution async\/await-first API Large parts of Lambda, LambdaHandler, and LambdaRuntime will be re-written to use async\/await constructs in place of the EventLoop family of interfaces. Providing ownership of main() and support for swift-service-lifecycle Instead of conforming to a handler protocol, users can now create a LambdaRuntime by passing in a handler closure. LambdaRuntime conforms to ServiceLifecycle.Service by implementing a run() method that contains initialization and graceful shutdown logic. This allows the lifecycle of the LambdaRuntime to be managed with swift-service-lifecycle alongside and in the same way the lifecycles of the required services are managed, e.g. try await ServiceGroup(services: [postgresClient, ..., lambdaRuntime], ...).run(). Dependencies can now be injected into LambdaRuntime. With swift-service-lifecycle, services will be initialized together with LambdaRuntime. The required services can then be used within the handler in a structured concurrency manner. swift-service-lifecycle takes care of listening for termination signals and terminating the services as well as the LambdaRuntime in correct order. LambdaTerminator can now be eliminated because its role is replaced with swift-service-lifecycle. The termination logic of the Lambda function will be implemented in the conforming run() function of LambdaRuntime. With this, the earlier code snippet can be replaced with something much easier to read, maintain, and debug:  Simplifying Codable support A detailed explanation is provided in the Codable Support section. In short, much of the boilerplate code defined for each handler protocol in Lambda+Codable and Lambda+String will be replaced with a single LambdaCodableAdapter struct. This adapter struct is generic over (1) any handler conforming to a new handler protocol LambdaWithBackgroundProcessingHandler, (2) the user-specified input and output types, and (3) any decoder and encoder conforming to protocols LambdaEventDecoder and LambdaOutputDecoder. The adapter will wrap the underlying handler with encoding\/decoding logic. Detailed Solution Below are explanations for all types that we want to use in AWS Lambda Runtime v2. LambdaResponseStreamWriter We will introduce a new LambdaResponseStreamWriter protocol. It is used in the new StreamingLambdaHandler (defined below), which is the new base protocol for the LambdaRuntime (defined below as well).  If the user does not call finish(), the library will automatically finish the stream after the last write. Appropriate errors will be thrown if finish() is called multiple times, or if write\/writeAndFinish is called after finish(). LambdaContext LambdaContext will be largely unchanged, but the eventLoop property will be removed. The allocator property of type ByteBufferAllocator will also be removed because (1), we generally want to reduce the number of SwiftNIO types exposed in the API, and (2), ByteBufferAllocator does not optimize the allocation strategies. The common pattern observed across many libraries is to re-use existing ByteBuffers as much as possible. This is also what we do for the LambdaCodableAdapter (explained in the Codable Support section) implementation.  Handlers We introduce three handler protocols: StreamingLambdaHandler, LambdaHandler, and LambdaWithBackgroundProcessingHandler. StreamingLambdaHandler The new StreamingLambdaHandler protocol is the base protocol to implement a Lambda function. Most users will not use this protocol and instead use the LambdaHandler protocol defined below.  Using this protocol requires the handle method to receive the incoming event as a ByteBuffer and return the output as a ByteBuffer too. Through the LambdaResponseStreamWriter, which is passed as an argument in the handle function, the response can be streamed by calling the write(_:) function of the LambdaResponseStreamWriter with partial data repeatedly before finally closing the response stream by calling finish(). Users can also choose to return the entire output and not stream the response by calling writeAndFinish(_:). This protocol also allows for background tasks to be run after a result has been reported to the AWS Lambda control plane, since the handle(...) function is free to implement any background work after the call to responseWriter.finish(). The protocol is defined in a way that supports a broad range of use-cases. The handle method is marked as mutating to allow handlers to be implemented with a struct. An implementation that sends the number 1 to 10 every 500ms could look like this:  LambdaHandler: This handler protocol will be the go-to choice for most use-cases because it is completely agnostic to any encoding\/decoding logic – conforming objects simply have to implement the handle function where the input and return types are Swift objects. Note that the handle function does not receive a LambdaResponseStreamWriter as an argument. Response streaming is not viable for LambdaHandler because the output has to be encoded prior to it being sent, e.g. it is not possible to encode a partial\/incomplete JSON string.  LambdaWithBackgroundProcessingHandler: This protocol is exactly like LambdaHandler, with the only difference being the added support for executing background work after the result has been sent to the AWS Lambda control plane. This is achieved by not having a return type in the handle function. The output is instead written into a LambdaResponseWriter that is passed in as an argument, meaning that the handle function is then free to implement any background work after the result has been sent to the AWS Lambda control plane. LambdaResponseWriter has different semantics to the LambdaResponseStreamWriter. Where the write(_:) function of LambdaResponseStreamWriter means writing into a response stream, the write(_:) function of LambdaResponseWriter simply serves as a mechanism to return the output without explicitly returning from the handle function.  Example Usage:  Handler Adapters Since the StreamingLambdaHandler protocol is the base protocol the LambdaRuntime works with, there are adapters to make both LambdaHandler and LambdaWithBackgroundProcessingHandler compatible with StreamingLambdaHandler. LambdaHandlerAdapter accepts a LambdaHandler and conforms it to LambdaWithBackgroundProcessingHandler. This is achieved by taking the generic Output object returned from the handle function of LambdaHandler and passing it to the write(_:) function of the LambdaResponseWriter. LambdaCodableAdapter accepts a LambdaWithBackgroundProcessingHandler and conforms it to StreamingLambdaHandler. This is achieved by wrapping the LambdaResponseWriter with the LambdaResponseStreamWriter provided by StreamingLambdaHandler. A call to the write(_:) function of LambdaResponseWriter is translated into a call to the writeAndFinish(_:) function of LambdaResponseStreamWriter. Both LambdaHandlerAdapter and LambdaCodableAdapter are described in greater detail in the Codable Support section. To summarize, LambdaHandler can be used with the LambdaRuntime by first going through LambdaHandlerAdapter and then through LambdaCodableAdapter. LambdaWithBackgroundHandler just requires LambdaCodableAdapter. For the common JSON-in and JSON-out use-case, there is an extension on LambdaRuntime that abstracts away this wrapping from the user. LambdaRuntime LambdaRuntime is the class that communicates with the Lambda control plane as defined in Building a custom runtime for AWS Lambda and forward the invocations to the provided StreamingLambdaHandler. It will conform to ServiceLifecycle.Service to provide support for swift-service-lifecycle.  The current API allows for a Lambda function to be tested locally through a mock server by requiring an environment variable named LOCAL_LAMBDA_SERVER_ENABLED to be set to true. If this environment variable is not set, the program immediately crashes as the user will not have the AWS_LAMBDA_RUNTIME_API environment variable on their local machine (set automatically when deployed to AWS Lambda). However, making the user set the LOCAL_LAMBDA_SERVER_ENABLED environment variable is an unnecessary step that can be avoided. In the v2 API, the run() function will automatically start the mock server when the AWS_LAMBDA_RUNTIME_API environment variable cannot be found. Lambda We also add an enum to store a static function and a property on. We put this on the static Lambda because LambdaRuntime is generic and thus has bad ergonomics for static properties and functions.  Since the library now provides ownership of the main() function and allows users to initialize services before the LambdaRuntime is initialized, the library cannot implicitly report errors that occur during initialization to the dedicated endpoint AWS exposes like it currently does through the initialize() function of LambdaRunner which wraps the handler’s init(...) and handles any errors thrown by reporting it to the dedicated AWS endpoint. To retain support for initialization error reporting, the Lambda.reportStartupError(any Error) function gives users the option to manually report initialization errors in their closure handler. Although this should ideally happen implicitly like it currently does in v1, we believe this is a small compromise in comparison to the benefits gained in now being able to cleanly manage the lifecycles of required services in a structured concurrency manner.  Assume we want to load a secret for the Lambda function from a secret vault first. If this fails, we want to report the error to the control plane:  Codable support The LambdaHandler and LambdaWithBackgroundProcessingHandler protocols abstract away encoding\/decoding logic from the conformers as they are generic over custom Event and Output types. We introduce two adapters LambdaHandlerAdapter and CodableLambdaAdapter that implement the encoding\/decoding logic and in turn allow the respective handlers to conform to StreamingLambdaHandler. LambdaHandlerAdapter Any handler conforming to LambdaHandler can be conformed to LambdaWithBackgroundProcessingHandler through LambdaHandlerAdapter.  LambdaCodableAdapter LambdaCodableAdapter accepts any generic underlying handler conforming to LambdaWithBackgroundProcessingHandler. It also accepts any encoder and decoder object conforming to the LambdaEventDecoder and LambdaOutputEncoder protocols: LambdaEventDecoder and LambdaOutputEncoder protocols  We provide conformances for Foundation’s JSONDecoder to LambdaEventDecoder and JSONEncoder to LambdaOutputEncoder. LambdaCodableAdapter implements its handle() method by: Decoding the ByteBuffer event into the generic Event type. Wrapping the LambdaResponseStreamWriter with a concrete LambdaResponseWriter such that calls to LambdaResponseWriters write(_:) are mapped to LambdaResponseStreamWriters writeAndFinish(_:). Note that the argument to LambdaResponseWriters write(_:) is a generic Output object whereas LambdaResponseStreamWriters writeAndFinish(_:) requires a ByteBuffer. Therefore, the concrete implementation of LambdaResponseWriter also accepts an encoder. Its write(_:) function first encodes the generic Output object and then passes it to the underlying LambdaResponseStreamWriter. Passing the generic Event instance, the concrete LambdaResponseWriter, as well as the LambdaContext to the underlying handler’s handle() method. LambdaCodableAdapter can implement encoding\/decoding for any handler conforming to LambdaWithBackgroundProcessingHandler if Event is Decodable and the Output is Encodable or Void, meaning that the encoding\/decoding stubs do not need to be implemented by the user.  Handler as a Closure To create a Lambda function using the current API, a user first has to create an object and conform it to one of the handler protocols by implementing the initializer and the handle(...) function. Now that LambdaRuntime is public, this verbosity can very easily be simplified. ClosureHandler This handler is generic over any Event type conforming to Decodable and any Output type conforming to Encodable or Void.  Given that ClosureHandler conforms to LambdaHandler: We can extend the LambdaRuntime initializer such that it accepts a closure as an argument. Within the initializer, the closure handler is wrapped with LambdaCodableAdapter.  We can now significantly reduce the verbosity and leverage Swift’s trailing closure syntax to cleanly create and run a Lambda function, abstracting away the decoding and encoding logic from the user:  We also add a StreamingClosureHandler conforming to StreamingLambdaHandler for use-cases where the user wants to handle encoding\/decoding themselves:  Alternatives considered [UInt8] instead of ByteBuffer We considered using [UInt8] instead of ByteBuffer in the base LambdaHandler API. We decided to use ByteBuffer for two reasons. 99% of use-cases will use the JSON codable API and will not directly get in touch with ByteBuffer anyway. For those users it does not matter if the base API uses ByteBuffer or [UInt8]. The incoming and outgoing data must be in the ByteBuffer format anyway, as Lambda uses SwiftNIO under the hood and SwiftNIO uses ByteBuffer in its APIs. By using ByteBuffer we can save a copies to and from [UInt8]. This will reduce the invocation time for all users. The base LambdaHandler API is most likely mainly being used by developers that want to integrate their web framework with Lambda (examples: Vapor, Hummingbird, …). Those developers will most likely prefer to get the data in the ByteBuffer format anyway, as their lower level networking stack also depends on SwiftNIO. Users create a LambdaResponse, that supports streaming instead of being passed a LambdaResponseStreamWriter Instead of passing the LambdaResponseStreamWriter in the invocation we considered a new type LambdaResponse, that users must return in the StreamingLambdaHandler. Its API would look like this:  The StreamingLambdaHandler would look like this:  There are pros and cons for the API that returns the LambdaResponses and there are pros and cons for the API that receives a LambdaResponseStreamWriter as a parameter. Concerning following structured concurrency principles the approach that receives a LambdaResponseStreamWriter as a parameter has benefits as the lifetime of the handle function is tied to the invocation runtime. The approach that returns a LambdaResponse splits the invocation into two separate function calls. First the handle method is invoked, second the LambdaResponse writer closure is invoked. This means that it is impossible to use Swift APIs that use with style lifecycle management patterns from before creating the response until sending the full response stream off. For example, users instrumenting their lambdas with Swift tracing likely can not use the withSpan API for the full lifetime of the request, if they return a streamed response. However, if it comes to consistency with the larger Swift on server ecosystem, the API that returns a LambdaResponse is likely the better choice. Hummingbird v2, OpenAPI and the new Swift gRPC v2 implementation all use this approach. This might be due to the fact that writing middleware becomes easier, if a Response is explicitly returned. We decided to implement the approach in which a LambdaResponseStreamWriter is passed to the function, since the approach in which a LambdaResponse is returned can trivially be built on top of it. This is not true vice versa. We welcome the discussion on this topic and are open to change our minds and API here. Adding a function `addBackgroundTask(_ body: sending @escaping () async -> ())` in `LambdaContext` Initially we proposed an explicit addBackgroundTask(_:) function in LambdaContext that users could call from their handler object to schedule a background task to be run after the result is reported to AWS. We received feedback that this approach for supporting background tasks does not exhibit structured concurrency, as code could still be in execution after leaving the scope of the handle(...) function. For handlers conforming to the StreamingLambdaHandler, addBackgroundTask(_:) was anyways unnecessary as background work could be executed in a structured concurrency manner within the handle(...) function after the call to LambdaResponseStreamWriter.finish(). For handlers conforming to the LambdaHandler protocol, we considered extending LambdaHandler with a performPostHandleWork(...) function that will be called after the handle function by the library. Users wishing to add background work can override this function in their LambdaHandler conforming object.  Yet this poses difficulties when the user wishes to use any state created in the handle(...) function as part of the background work. In general, the most common use-case for this library will be to implement simple Lambda functions that do not have requirements for response streaming, nor to perform any background work after returning the output. To keep things easy for the common use-case, and with Swift’s principle of progressive disclosure of complexity in mind, we settled on three handler protocols: LambdaHandler: Most common use-case. JSON-in, JSON-out. Does not support background work execution. An intuitive handle(event: Event, context: LambdaContext) -> Output API that is simple to understand, i.e. users are not exposed to the concept of sending their response through a writer. LambdaHandler can be very cleanly implemented and used with LambdaRuntime, especially with ClosureHandler. LambdaWithBackgroundProcessingHandler: If users wish to augment their LambdaHandler with the ability to run background tasks, they can easily migrate. A user simply has to: Change the conformance to LambdaWithBackgroundProcessingHandler. Add an additional outputWriter: some LambdaResponseWriter<Output> argument to the handle function. Replace the return ... with outputWriter.write(...). Implement any background work after outputWriter.write(...). StreamingLambdaHandler: This is the base handler protocol which is intended to be used directly only for advanced use-cases. Users are provided the invocation event as a ByteBuffer and a LambdaResponseStreamWriter where the computed result (as ByteBuffer) can either be streamed (with repeated calls to write(_:)) or sent all at once (with a single call to writeAndFinish(_:)). After closing the LambdaResponseStreamWriter, any background work can be implemented. Making LambdaResponseStreamWriter and LambdaResponseWriter ~Copyable We initially proposed to make the LambdaResponseStreamWriter and LambdaResponseWriter protocols ~Copyable, with the functions that close the response having the consuming ownership keyword. This was so that the compiler could enforce the restriction of not being able to interact with the writer after the response stream has closed. However, non-copyable types do not compose nicely and add complexity for users. Further, for the compiler to actually enforce the consuming restrictions, user’s have to explicitly mark the writer argument as consuming in the handle function. Therefore, throwing appropriate errors to prevent abnormal interaction with the writers seems to be the simplest approach. A word about versioning We are aware that AWS Lambda Runtime has not reached a proper 1.0. We intend to keep the current implementation around at 1.0-alpha. We don’t want to change the current API without releasing a new major. We think there are lots of adopters out there that depend on the API in v1. Because of this we intend to release the proposed API here as AWS Lambda Runtime v2.","kind":"article","summary":"swift-aws-lambda-runtime is an important library for the Swift on Server ecosystem. The initial API was written before async\/await was introduced to Swift. When async\/await was introduced, shims were added to bridge between the underlying SwiftNIO EventLoop interfaces and async\/await. However, just like gRPC-swift and postgres-nio, we now want to shift to solely using async\/await instead of EventLoop interfaces. For this, large parts of the current API have to be reconsidered."},{"summary":"Learn how to create your project, add dependencies, and create and test your first Lambda function in Swift.","headings":[],"kind":"tutorial","rawIndexableTextContent":"Learn how to create your project, add dependencies, and create and test your first Lambda function in Swift. In this example, we will create a Lambda function that receives a text and checks if this text is a palindrome or not. A palindrome is a word or phrase that reads the same forward and backward. Create a new swift project and open Xcode. Start in your development folder. Open a Terminal and create a directory for your Lambda function. Initialize a new Swift package for an executable target. Open Xcode in this newly created directory. Alternatively, if you use VSCode, use the code command to open VSCode in your project repository. In your development environment, expand the project if necessary and open the file Package.swift. If you are an iOS developer, you might wonder what is a Package.swift. In simple terms, your Package.swift defines the dependencies your code has and what products (libraries and\/or executables) your code offers. Prepare Package.swift to define the project targets and dependencies. In the Xcode editor, replace the content of Package.swift with the file on the right side of the screen. It defines a package for a project named Palindrome. The package name only matters when you build a library that is used by other Swift packages. Comments are important here, do not skip them. They define the minimum version of Swift to use. Add the platform section. It defines on which Apple platforms the code can be executed. Since Lambda functions are supposed to be run on Linux servers with Amazon Linux 2, it is reasonable to make them run only on macOS, for debugging for example. It does not make sense to run this code on iOS, iPadOS, tvOS, and watchOS. Add the dependencies section. It defines what external libraries your code depends on. To run code within AWS Lambda you’ll need a runtime that handles the communication with the Lambda Runtime Interface. This is what the AWSLambdaRuntime is for. You import it by specifying its GitHub url: https:\/\/github.com\/swift-server\/swift-aws-lambda-runtime.git. Add the target section. In the targets section you specify your own targets. They are pretty comparable to targets you specify within an Xcode project (that’s probably why they share the name 😎). In our example we only want to create an executable that is called PalindromeLambda. An executable must have an entrypoint. This can be either a main.swift or an object that is marked with @main. For Lambda we will use the @main approach. Add the product section. To advertise our executableTarget as a product of our package, we add it to the products section. Now that our project structure is ready, let’s write the code of your Lambda function. Perform the following steps in Xcode or another IDE of your choice. Open the main.swift file, remove the code generated and write the code to represent the request sent to your Lambda function. Input parameters must conform to the Decodable protocol. This ensures that your Lambda function accepts any JSON input. When your function is triggered by another AWS service, we modeled most of the input and output data format for you. You can add the dependency on https:\/\/github.com\/swift-server\/swift-aws-lambda-events and import AWSLambdaEvents in your code. Write the code to represent the response returned by your Lambda function. Output parameters must conform to the Encodable protocol. This ensures that your Lambda function returns a valid JSON output. Your function might also return Void if it does not return any value. You can also write function that stream a response back to the caller. This is useful when you have a large amount of data to return. See the Lambda Streaming example for more information. Write your business logic. In real life project, this will be the most complex part of your code. It will live in spearate files or libraries. For this example, we will keep it simple and just return true if a String is a palindrome. Add an import statement to import the AWSLambdaRuntime library. Create a LambdaRuntime struct and add a handler function that will be called by the Lambda runtime. This function is passed as a closure to the initializer of the LambdaRuntime struct. It accepts two parameters: the input event and the context. The input event is the JSON payload sent to your Lambda function. The context provides information about the function, such as the function name, memory limit, and log group name. The function returns the output event, which is the JSON payload returned by your Lambda function or Void if your function does not return any value. Add the business logic to the handler function and return the response. In this example, we call the isPalindrome(_:) function to check if the input string is a palindrome. Then, we create a response with the result of the check. Start the runtime by calling the run() function. This function starts the Lambda runtime and listens for incoming requests. When a request is received, it calls the handler function with the input event and context. The handler function processes the request and returns the output event. The runtime sends the output event back to the caller. This function might throw an error if the runtime fails to process an event or if the handler function throws an error. This function is asynchronous and does not return until the runtime is stopped. Before to deploy your Lambda to AWS, you want to ensure that it works on your local machine. The AWSLambdaRuntime embeds a simple web server you can start and use to send your requests to your Lambda function. The embedded web server starts only when compiling in DEBUG mode and when the code is not run inside a Lambda function environment. You will start the test server directly from Xcode. Compile and run your project. Click on the Run button (▶️) in Xcode. Verify the server is correctlys started. You should see the following output in the console. Now that the local server started, open a Terminal and use curl or any other HTTP client to POST your input payload to 127.0.0.1:7000. When you pass '{\"text\": \"Was it a car or a cat I saw?\"}', you should receive the response {\"message\":\"Your text is a palindrome\",\"isPalindrome\":true,\"text\":\"Was it a car or a cat I saw?\"} Do not forget to stop the running scheme in Xcode (⏹️) when you’re done. Alternatively, you can use the command line from the Terminal. Use the command swift run to start the local embedded web server. You should see the following output in the console. Now that the local server started, open a second tab in the Terminal and use curl or any other HTTP client to POST your input payload to 127.0.0.1:7000. Do not forget to stop the local server with CTRL-C when you’re done.","title":"Write your first Lambda function","location":{"reference":{"url":"doc:\/\/AWSLambdaRuntimeCore\/tutorials\/AWSLambdaRuntimeCore\/03-write-function","interfaceLanguage":"swift"},"type":"topLevelPage"}},{"location":{"inPage":{"url":"doc:\/\/AWSLambdaRuntimeCore\/tutorials\/AWSLambdaRuntimeCore\/03-write-function","interfaceLanguage":"swift"},"type":"contained","reference":{"url":"doc:\/\/AWSLambdaRuntimeCore\/tutorials\/AWSLambdaRuntimeCore\/03-write-function#Initialize-a-new-project","interfaceLanguage":"swift"}},"headings":[],"kind":"tutorialSection","rawIndexableTextContent":"Create a new swift project and open Xcode. Start in your development folder. Open a Terminal and create a directory for your Lambda function. Initialize a new Swift package for an executable target. Open Xcode in this newly created directory. Alternatively, if you use VSCode, use the code command to open VSCode in your project repository. In your development environment, expand the project if necessary and open the file Package.swift. If you are an iOS developer, you might wonder what is a Package.swift. In simple terms, your Package.swift defines the dependencies your code has and what products (libraries and\/or executables) your code offers.","summary":"Create a new swift project and open Xcode.","title":"Initialize a new project"},{"rawIndexableTextContent":"Prepare Package.swift to define the project targets and dependencies. In the Xcode editor, replace the content of Package.swift with the file on the right side of the screen. It defines a package for a project named Palindrome. The package name only matters when you build a library that is used by other Swift packages. Comments are important here, do not skip them. They define the minimum version of Swift to use. Add the platform section. It defines on which Apple platforms the code can be executed. Since Lambda functions are supposed to be run on Linux servers with Amazon Linux 2, it is reasonable to make them run only on macOS, for debugging for example. It does not make sense to run this code on iOS, iPadOS, tvOS, and watchOS. Add the dependencies section. It defines what external libraries your code depends on. To run code within AWS Lambda you’ll need a runtime that handles the communication with the Lambda Runtime Interface. This is what the AWSLambdaRuntime is for. You import it by specifying its GitHub url: https:\/\/github.com\/swift-server\/swift-aws-lambda-runtime.git. Add the target section. In the targets section you specify your own targets. They are pretty comparable to targets you specify within an Xcode project (that’s probably why they share the name 😎). In our example we only want to create an executable that is called PalindromeLambda. An executable must have an entrypoint. This can be either a main.swift or an object that is marked with @main. For Lambda we will use the @main approach. Add the product section. To advertise our executableTarget as a product of our package, we add it to the products section.","headings":[],"title":"Add the project dependencies","kind":"tutorialSection","location":{"type":"contained","reference":{"url":"doc:\/\/AWSLambdaRuntimeCore\/tutorials\/AWSLambdaRuntimeCore\/03-write-function#Add-the-project-dependencies","interfaceLanguage":"swift"},"inPage":{"interfaceLanguage":"swift","url":"doc:\/\/AWSLambdaRuntimeCore\/tutorials\/AWSLambdaRuntimeCore\/03-write-function"}},"summary":"Prepare Package.swift to define the project targets and dependencies."},{"location":{"inPage":{"interfaceLanguage":"swift","url":"doc:\/\/AWSLambdaRuntimeCore\/tutorials\/AWSLambdaRuntimeCore\/03-write-function"},"type":"contained","reference":{"url":"doc:\/\/AWSLambdaRuntimeCore\/tutorials\/AWSLambdaRuntimeCore\/03-write-function#Write-the-function-code","interfaceLanguage":"swift"}},"title":"Write the function code","rawIndexableTextContent":"Now that our project structure is ready, let’s write the code of your Lambda function. Perform the following steps in Xcode or another IDE of your choice. Open the main.swift file, remove the code generated and write the code to represent the request sent to your Lambda function. Input parameters must conform to the Decodable protocol. This ensures that your Lambda function accepts any JSON input. When your function is triggered by another AWS service, we modeled most of the input and output data format for you. You can add the dependency on https:\/\/github.com\/swift-server\/swift-aws-lambda-events and import AWSLambdaEvents in your code. Write the code to represent the response returned by your Lambda function. Output parameters must conform to the Encodable protocol. This ensures that your Lambda function returns a valid JSON output. Your function might also return Void if it does not return any value. You can also write function that stream a response back to the caller. This is useful when you have a large amount of data to return. See the Lambda Streaming example for more information. Write your business logic. In real life project, this will be the most complex part of your code. It will live in spearate files or libraries. For this example, we will keep it simple and just return true if a String is a palindrome. Add an import statement to import the AWSLambdaRuntime library. Create a LambdaRuntime struct and add a handler function that will be called by the Lambda runtime. This function is passed as a closure to the initializer of the LambdaRuntime struct. It accepts two parameters: the input event and the context. The input event is the JSON payload sent to your Lambda function. The context provides information about the function, such as the function name, memory limit, and log group name. The function returns the output event, which is the JSON payload returned by your Lambda function or Void if your function does not return any value. Add the business logic to the handler function and return the response. In this example, we call the isPalindrome(_:) function to check if the input string is a palindrome. Then, we create a response with the result of the check. Start the runtime by calling the run() function. This function starts the Lambda runtime and listens for incoming requests. When a request is received, it calls the handler function with the input event and context. The handler function processes the request and returns the output event. The runtime sends the output event back to the caller. This function might throw an error if the runtime fails to process an event or if the handler function throws an error. This function is asynchronous and does not return until the runtime is stopped.","kind":"tutorialSection","summary":"Now that our project structure is ready, let’s write the code of your Lambda function. Perform the following steps in Xcode or another IDE of your choice.","headings":[]},{"kind":"tutorialSection","headings":[],"rawIndexableTextContent":"Before to deploy your Lambda to AWS, you want to ensure that it works on your local machine. The AWSLambdaRuntime embeds a simple web server you can start and use to send your requests to your Lambda function. The embedded web server starts only when compiling in DEBUG mode and when the code is not run inside a Lambda function environment. You will start the test server directly from Xcode. Compile and run your project. Click on the Run button (▶️) in Xcode. Verify the server is correctlys started. You should see the following output in the console. Now that the local server started, open a Terminal and use curl or any other HTTP client to POST your input payload to 127.0.0.1:7000. When you pass '{\"text\": \"Was it a car or a cat I saw?\"}', you should receive the response {\"message\":\"Your text is a palindrome\",\"isPalindrome\":true,\"text\":\"Was it a car or a cat I saw?\"} Do not forget to stop the running scheme in Xcode (⏹️) when you’re done. Alternatively, you can use the command line from the Terminal. Use the command swift run to start the local embedded web server. You should see the following output in the console. Now that the local server started, open a second tab in the Terminal and use curl or any other HTTP client to POST your input payload to 127.0.0.1:7000. Do not forget to stop the local server with CTRL-C when you’re done.","location":{"type":"contained","inPage":{"url":"doc:\/\/AWSLambdaRuntimeCore\/tutorials\/AWSLambdaRuntimeCore\/03-write-function","interfaceLanguage":"swift"},"reference":{"url":"doc:\/\/AWSLambdaRuntimeCore\/tutorials\/AWSLambdaRuntimeCore\/03-write-function#Test-Your-Code-Locally","interfaceLanguage":"swift"}},"summary":"Before to deploy your Lambda to AWS, you want to ensure that it works on your local machine.","title":"Test Your Code Locally"},{"headings":[],"summary":"Learn how to package your code for AWS Lambda and to deploy it using the AWS Management Console","rawIndexableTextContent":"Learn how to package your code for AWS Lambda and to deploy it using the AWS Management Console Learn how to compile your code to run it on Amazon Linux. AWS Lambda runs on top of Amazon Linux 2. You must therefore compile your code for Linux. The AWS Lambda Runtime for Swift uses Docker to do so. Once the code is compiled, it must be assembled in a ZIP file before being deployed in the cloud. The AWS Lambda Runtime for Swift provides a Swift Package Manager plugin to compile and zip your Lambda function in one simple step. Be sure Docker is started on your machine. On macOS, you can check the Docker icon in the menu bar. In a terminal, invoke the archive command to build and zip your Lambda function. The plugin starts a Docker container running Amazon Linux 2 and compile your Lambda function code. It then creates a zip file. When everything goes well, you should see an output similar to this one. Copy the generated zip files to your Desktop or Download directory for easy access. I choose the Desktop. Learn how to create a Lambda function using the AWS Management Console and to deploy your zip file You will now deploy your code to AWS Lambda. To complete the remaining steps in this tutorial, you must have an AWS Account.  You can create an AWS Account by following these instructions. Open a web browser and navigate to https:\/\/console.aws.amazon.com. If you have an IAM user ID and password, select IAM User, otherwise proceed by entering your Root user email address and password. For this tutorial, I sign in using my IAM User ID. On the top right side of the console, select the AWS Region where you want to deploy your Lambda function. You typically choose a Region close to your customers to minimize the network latency. For this demo, I selected Oregon (us-west-2) AWS has multiple Regions across all continents. You can learn more about AWS Global Infrastructure here. On the top left side of the console, select the Lambda service to navigate to the Lambda section of the console. On the top right side of the Lambda page, select Create function. Enter a Function name. I choose PalindromeLambda. Select Provide your own bootstrap on Amazon Linux 2 as Runtime. And select arm64 as Architecture when you build on a Mac with Apple Silicon. Leave all other parameter as default, and select Create function on the bottom right part. The runtime architecture for Lambda (arm64 or x86_64) must match the one of the machine where you compiled the code.  When you compiled on an Intel-based Mac, use x86_64. When compiling on an Apple Silicon-based Mac select arm64. On the next screen, select .zip file from the Upload from selection box on the middle right part of the screen. Select the zip file that was generated earlier and select Save. To verify everything works well, create a test event and invoke the function from the Test tab in the console. Enter MyTestEvent as Event name. Enter {\"text\": \"Was it a car or a cat I saw?\"} as Event JSON. Then, select Test. When the invocation succeeds, you can see the execution details and the result: { \"message\": \"Your text is a palindrome\",\"isPalindrome\": true, \"text\": \"Was it a car or a cat I saw?\"}. The execution result also shares the execution duration, the actual memory consumed and the logs generated by the function. These are important data to help you to fine-tune your function. Providing the function with more memory will also give it more compute power, resulting in lower execution time. Learn how to invoke the Lambda function using the AWS Lambda API and the AWS command line. Typically you will associate an URL to your Lambda function, or you will expose the Lambda function through a REST API. You might use the Serverless Application Model (SAM) to do so. We’ll leave tasks for another tutorial. In the remaining section of this tutorial, you will learn how to invoke your Lambda function from the AWS command-line tool. First, check that you have the aws command line tool installed and configured. You can install the aws CLI with the command brew awscli. You need to configure the aws CLI with your AWS credentials. You may use the command aws configure to configure the CLI. The AWS CLI documentation has more details. Enter the following command to invoke your Lambda function. The command returns with the invocation status. Type cat result.json to see the value returned by your function. When everything goes well, you will see {\"text\":\"Was it a car or a cat I saw?\",\"isPalindrome\":true,\"message\":\"Your text is a palindrome\"}. Congratulation 🎉 !","title":"Deploy your function to AWS Lambda","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/AWSLambdaRuntimeCore\/tutorials\/AWSLambdaRuntimeCore\/04-deploy-function","interfaceLanguage":"swift"}},"kind":"tutorial"},{"headings":[],"rawIndexableTextContent":"Learn how to compile your code to run it on Amazon Linux. AWS Lambda runs on top of Amazon Linux 2. You must therefore compile your code for Linux. The AWS Lambda Runtime for Swift uses Docker to do so. Once the code is compiled, it must be assembled in a ZIP file before being deployed in the cloud. The AWS Lambda Runtime for Swift provides a Swift Package Manager plugin to compile and zip your Lambda function in one simple step. Be sure Docker is started on your machine. On macOS, you can check the Docker icon in the menu bar. In a terminal, invoke the archive command to build and zip your Lambda function. The plugin starts a Docker container running Amazon Linux 2 and compile your Lambda function code. It then creates a zip file. When everything goes well, you should see an output similar to this one. Copy the generated zip files to your Desktop or Download directory for easy access. I choose the Desktop.","title":"Compile for Amazon Linux","kind":"tutorialSection","location":{"inPage":{"url":"doc:\/\/AWSLambdaRuntimeCore\/tutorials\/AWSLambdaRuntimeCore\/04-deploy-function","interfaceLanguage":"swift"},"type":"contained","reference":{"interfaceLanguage":"swift","url":"doc:\/\/AWSLambdaRuntimeCore\/tutorials\/AWSLambdaRuntimeCore\/04-deploy-function#Compile-for-Amazon-Linux"}},"summary":"Learn how to compile your code to run it on Amazon Linux."},{"headings":[],"rawIndexableTextContent":"Learn how to create a Lambda function using the AWS Management Console and to deploy your zip file You will now deploy your code to AWS Lambda. To complete the remaining steps in this tutorial, you must have an AWS Account.  You can create an AWS Account by following these instructions. Open a web browser and navigate to https:\/\/console.aws.amazon.com. If you have an IAM user ID and password, select IAM User, otherwise proceed by entering your Root user email address and password. For this tutorial, I sign in using my IAM User ID. On the top right side of the console, select the AWS Region where you want to deploy your Lambda function. You typically choose a Region close to your customers to minimize the network latency. For this demo, I selected Oregon (us-west-2) AWS has multiple Regions across all continents. You can learn more about AWS Global Infrastructure here. On the top left side of the console, select the Lambda service to navigate to the Lambda section of the console. On the top right side of the Lambda page, select Create function. Enter a Function name. I choose PalindromeLambda. Select Provide your own bootstrap on Amazon Linux 2 as Runtime. And select arm64 as Architecture when you build on a Mac with Apple Silicon. Leave all other parameter as default, and select Create function on the bottom right part. The runtime architecture for Lambda (arm64 or x86_64) must match the one of the machine where you compiled the code.  When you compiled on an Intel-based Mac, use x86_64. When compiling on an Apple Silicon-based Mac select arm64. On the next screen, select .zip file from the Upload from selection box on the middle right part of the screen. Select the zip file that was generated earlier and select Save. To verify everything works well, create a test event and invoke the function from the Test tab in the console. Enter MyTestEvent as Event name. Enter {\"text\": \"Was it a car or a cat I saw?\"} as Event JSON. Then, select Test. When the invocation succeeds, you can see the execution details and the result: { \"message\": \"Your text is a palindrome\",\"isPalindrome\": true, \"text\": \"Was it a car or a cat I saw?\"}. The execution result also shares the execution duration, the actual memory consumed and the logs generated by the function. These are important data to help you to fine-tune your function. Providing the function with more memory will also give it more compute power, resulting in lower execution time.","title":"Create an Lambda Function","summary":"Learn how to create a Lambda function using the AWS Management Console and to deploy your zip file","kind":"tutorialSection","location":{"type":"contained","reference":{"interfaceLanguage":"swift","url":"doc:\/\/AWSLambdaRuntimeCore\/tutorials\/AWSLambdaRuntimeCore\/04-deploy-function#Create-an-Lambda-Function"},"inPage":{"interfaceLanguage":"swift","url":"doc:\/\/AWSLambdaRuntimeCore\/tutorials\/AWSLambdaRuntimeCore\/04-deploy-function"}}},{"title":"Invoke your Lambda function","summary":"Learn how to invoke the Lambda function using the AWS Lambda API and the AWS command line.","location":{"type":"contained","inPage":{"url":"doc:\/\/AWSLambdaRuntimeCore\/tutorials\/AWSLambdaRuntimeCore\/04-deploy-function","interfaceLanguage":"swift"},"reference":{"interfaceLanguage":"swift","url":"doc:\/\/AWSLambdaRuntimeCore\/tutorials\/AWSLambdaRuntimeCore\/04-deploy-function#Invoke-your-Lambda-function"}},"kind":"tutorialSection","headings":[],"rawIndexableTextContent":"Learn how to invoke the Lambda function using the AWS Lambda API and the AWS command line. Typically you will associate an URL to your Lambda function, or you will expose the Lambda function through a REST API. You might use the Serverless Application Model (SAM) to do so. We’ll leave tasks for another tutorial. In the remaining section of this tutorial, you will learn how to invoke your Lambda function from the AWS command-line tool. First, check that you have the aws command line tool installed and configured. You can install the aws CLI with the command brew awscli. You need to configure the aws CLI with your AWS credentials. You may use the command aws configure to configure the CLI. The AWS CLI documentation has more details. Enter the following command to invoke your Lambda function. The command returns with the invocation status. Type cat result.json to see the value returned by your function. When everything goes well, you will see {\"text\":\"Was it a car or a cat I saw?\",\"isPalindrome\":true,\"message\":\"Your text is a palindrome\"}. Congratulation 🎉 !"}]