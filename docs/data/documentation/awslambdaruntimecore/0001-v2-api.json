{"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/awslambdaruntimecore\/0001-v2-api"]}],"sections":[],"identifier":{"url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/0001-v2-api","interfaceLanguage":"swift"},"schemaVersion":{"major":0,"patch":0,"minor":3},"metadata":{"role":"article","modules":[{"name":"AWSLambdaRuntimeCore"}],"title":"v2 API proposal for swift-aws-lambda-runtime","roleHeading":"Article"},"kind":"article","hierarchy":{"paths":[["doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore"]]},"abstract":[{"type":"codeVoice","code":"swift-aws-lambda-runtime"},{"text":" is an important library for the Swift on Server ecosystem. The initial API was written before","type":"text"},{"text":" ","type":"text"},{"text":"async\/await was introduced to Swift. When async\/await was introduced, shims were added to bridge between the underlying","type":"text"},{"text":" ","type":"text"},{"text":"SwiftNIO ","type":"text"},{"type":"codeVoice","code":"EventLoop"},{"type":"text","text":" interfaces and async\/await. However, just like "},{"type":"codeVoice","code":"gRPC-swift"},{"type":"text","text":" and "},{"code":"postgres-nio","type":"codeVoice"},{"type":"text","text":", we now want to"},{"type":"text","text":" "},{"type":"text","text":"shift to solely using async\/await instead of "},{"code":"EventLoop","type":"codeVoice"},{"text":" interfaces. For this, large parts of the current API have to be","type":"text"},{"type":"text","text":" "},{"text":"reconsidered.","type":"text"}],"primaryContentSections":[{"content":[{"level":2,"type":"heading","text":"Overview","anchor":"Overview"},{"inlineContent":[{"type":"text","text":"Versions:"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"text":"v1 (2024-08-07): Initial version","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"v1.1:"}]},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"Remove the "},{"code":"reportError(_:)","type":"codeVoice"},{"type":"text","text":" method from "},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"type":"text","text":" and instead make the "},{"type":"codeVoice","code":"handle(...)"},{"type":"text","text":" method of"},{"text":" ","type":"text"},{"type":"codeVoice","code":"StreamingLambdaHandler"},{"type":"text","text":" throwing."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Remove the ","type":"text"},{"code":"addBackgroundTask(_:)","type":"codeVoice"},{"text":" method from ","type":"text"},{"type":"codeVoice","code":"LambdaContext"},{"type":"text","text":" due to structured concurrency concerns and introduce"},{"text":" ","type":"text"},{"text":"the ","type":"text"},{"type":"codeVoice","code":"LambdaWithBackgroundProcessingHandler"},{"type":"text","text":" protocol as a solution."}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Introduce ","type":"text"},{"code":"LambdaHandlerAdapter","type":"codeVoice"},{"text":", which adapts handlers conforming to ","type":"text"},{"type":"codeVoice","code":"LambdaHandler"},{"type":"text","text":" with"},{"type":"text","text":" "},{"code":"LambdaWithBackgroundProcessingHandler","type":"codeVoice"},{"text":".","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Update ","type":"text"},{"type":"codeVoice","code":"LambdaCodableAdapter"},{"text":" to now be generic over any handler conforming to","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"LambdaWithBackgroundProcessingHandler"},{"text":" instead of ","type":"text"},{"type":"codeVoice","code":"LambdaHandler"},{"text":".","type":"text"}]}]}]}]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"v1.2:","type":"text"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Remove "},{"type":"codeVoice","code":"~Copyable"},{"type":"text","text":" from "},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"type":"text","text":" and "},{"code":"LambdaResponseWriter","type":"codeVoice"},{"type":"text","text":". Instead throw an error when"},{"type":"text","text":" "},{"code":"finish()","type":"codeVoice"},{"text":" is called multiple times or when ","type":"text"},{"code":"write","type":"codeVoice"},{"type":"text","text":"\/"},{"type":"codeVoice","code":"writeAndFinish"},{"type":"text","text":" is called after "},{"code":"finish()","type":"codeVoice"},{"type":"text","text":"."}]}]}],"type":"unorderedList"}]}],"type":"unorderedList"},{"type":"heading","level":2,"anchor":"Motivation","text":"Motivation"},{"type":"heading","anchor":"Current-Limitations","level":3,"text":"Current Limitations"},{"text":"EventLoop interfaces","type":"heading","anchor":"EventLoop-interfaces","level":4},{"type":"paragraph","inlineContent":[{"type":"text","text":"The current API extensively uses the "},{"code":"EventLoop","type":"codeVoice"},{"text":" family of interfaces from SwiftNIO in many areas. To use these","type":"text"},{"type":"text","text":" "},{"type":"text","text":"interfaces correctly though, it requires developers to exercise great care and understand the various transform methods"},{"type":"text","text":" "},{"type":"text","text":"that are used to work with "},{"code":"EventLoop","type":"codeVoice"},{"text":"s and ","type":"text"},{"type":"codeVoice","code":"EventLoopFuture"},{"text":"s. This results in a lot of cognitive complexity and makes","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"the code in the current API hard to reason about and maintain. For these reasons, the overarching trend in the Swift on"},{"type":"text","text":" "},{"type":"text","text":"Server ecosystem is to shift to newer, more readable, Swift concurrency constructs and de-couple from SwiftNIO’s"},{"text":" ","type":"text"},{"code":"EventLoop","type":"codeVoice"},{"type":"text","text":" interfaces."}]},{"text":"No ownership of the main() function","type":"heading","anchor":"No-ownership-of-the-main-function","level":4},{"type":"paragraph","inlineContent":[{"type":"text","text":"A Lambda function can currently be implemented through conformance to the various handler protocols defined in"},{"text":" ","type":"text"},{"type":"codeVoice","code":"AWSLambdaRuntimeCore\/LambdaHandler"},{"type":"text","text":". Each of these protocols have an extension which implements a "},{"type":"codeVoice","code":"static func main()"},{"text":".","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"This allows users to annotate their "},{"type":"codeVoice","code":"LambdaHandler"},{"type":"text","text":" conforming object with "},{"type":"codeVoice","code":"@main"},{"text":". The ","type":"text"},{"type":"codeVoice","code":"static func main()"},{"type":"text","text":" calls the"},{"text":" ","type":"text"},{"type":"text","text":"internal "},{"code":"Lambda.run()","type":"codeVoice"},{"text":" function, which starts the Lambda function. Since the ","type":"text"},{"type":"codeVoice","code":"Lambda.run()"},{"type":"text","text":" method is internal, users"},{"type":"text","text":" "},{"text":"cannot override the default implementation. This has proven challenging for users who want to","type":"text"},{"text":" ","type":"text"},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/swift-server\/swift-aws-lambda-runtime\/issues\/265"},{"type":"text","text":"."},{"text":" ","type":"text"},{"text":"Setting up global properties is required to customize the Swift Logging, Metric and Tracing backend.","type":"text"}]},{"level":4,"type":"heading","anchor":"Non-trivial-transition-from-SimpleLambdaHandler-to-LambdaHandler","text":"Non-trivial transition from SimpleLambdaHandler to LambdaHandler"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"SimpleLambdaHandler"},{"type":"text","text":" protocol provides a quick and easy way to implement a basic Lambda function. It only requires"},{"type":"text","text":" "},{"text":"an implementation of the ","type":"text"},{"code":"handle","type":"codeVoice"},{"text":" function where the business logic of the Lambda function can be written.","type":"text"},{"text":" ","type":"text"},{"type":"codeVoice","code":"SimpleLambdaHandler"},{"type":"text","text":" is perfectly sufficient for small use-cases as the user does not need to spend much time looking"},{"text":" ","type":"text"},{"type":"text","text":"into the library."}]},{"type":"paragraph","inlineContent":[{"text":"However, ","type":"text"},{"code":"SimpleLambdaHandler","type":"codeVoice"},{"type":"text","text":" cannot be used when services such as a database client need to be initialized before the"},{"text":" ","type":"text"},{"text":"Lambda runtime starts and then also gracefully shutdown prior to the runtime terminating. This is because the only way","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"to register termination logic is through the "},{"code":"LambdaInitializationContext","type":"codeVoice"},{"type":"text","text":" (containing a field"},{"type":"text","text":" "},{"code":"terminator: LambdaTerminator","type":"codeVoice"},{"type":"text","text":") which is created and used "},{"inlineContent":[{"type":"text","text":"internally"}],"type":"emphasis"},{"text":" within ","type":"text"},{"type":"codeVoice","code":"LambdaRuntime"},{"type":"text","text":" and never exposed through"},{"type":"text","text":" "},{"code":"SimpleLambdaHandler","type":"codeVoice"},{"text":". For such use-cases, other handler protocols like ","type":"text"},{"code":"LambdaHandler","type":"codeVoice"},{"type":"text","text":" must be used. "},{"type":"codeVoice","code":"LambdaHandler"},{"text":" ","type":"text"},{"type":"text","text":"exposes a "},{"code":"context","type":"codeVoice"},{"text":" argument of type ","type":"text"},{"code":"LambdaInitializationContext","type":"codeVoice"},{"text":" through its initializer. Within the initializer,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"required services can be initialized and their graceful shutdown logic can be registered with the"},{"text":" ","type":"text"},{"code":"context.terminator.register","type":"codeVoice"},{"text":" function.","type":"text"}]},{"inlineContent":[{"text":"Yet, ","type":"text"},{"type":"codeVoice","code":"LambdaHandler"},{"text":" is quite cumbersome to use in such use-cases as users have to deviate from the established norms of","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"the Swift on Server ecosystem in order to cleanly manage the lifecycle of the services intended to be used. This is"},{"type":"text","text":" "},{"type":"text","text":"because the convenient "},{"type":"codeVoice","code":"swift-service-lifecycle"},{"type":"text","text":" v2 library — which is commonly used for cleanly managing the lifecycles"},{"type":"text","text":" "},{"type":"text","text":"of required services and widely supported by many libraries — cannot be used in a structured concurrency manner."}],"type":"paragraph"},{"anchor":"Does-not-integrate-well-with-swift-service-lifecycle-in-a-structured-concurrency-manner","type":"heading","text":"Does not integrate well with swift-service-lifecycle in a structured concurrency manner","level":4},{"type":"paragraph","inlineContent":[{"text":"The Lambda runtime can only be started using the ","type":"text"},{"type":"strong","inlineContent":[{"type":"text","text":"internal"}]},{"type":"text","text":" "},{"type":"codeVoice","code":"Lambda.run()"},{"text":" function. This function is called by the","type":"text"},{"text":" ","type":"text"},{"type":"codeVoice","code":"main()"},{"type":"text","text":" function defined by the "},{"code":"LambdaHandler","type":"codeVoice"},{"type":"text","text":" protocol, preventing users from injecting initialized services into the"},{"type":"text","text":" "},{"text":"runtime ","type":"text"},{"inlineContent":[{"type":"text","text":"prior"}],"type":"emphasis"},{"text":" to it starting. As shown below, this forces users to use an ","type":"text"},{"inlineContent":[{"type":"text","text":"unstructured concurrency"}],"type":"strong"},{"type":"text","text":" approach and"},{"text":" ","type":"text"},{"text":"manually initialize services, leading to the issue of the user then perhaps forgetting to gracefully shutdown the","type":"text"},{"text":" ","type":"text"},{"text":"initialized services:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["struct MyLambda: LambdaHandler {","    let pgClient: PostgresClient","","    init(context: AWSLambdaRuntimeCore.LambdaInitializationContext) async throws {","        \/\/\/ Instantiate service","        let client = PostgresClient(configuration: ...)","","        \/\/\/ Unstructured concurrency to initialize the service","        let pgTask = Task {","            await client.run()","        }","","        \/\/\/ Store the client in `self` so that it can be used in `handle(...)`","        self.pgClient = client","","        \/\/\/ !!! Must remember to explicitly register termination logic for PostgresClient !!!","        context.terminator.register(","           name: \"PostgreSQL Client\",","           handler: { eventLoop in","               pgTask.cancel()","               return eventLoop.makeFutureWithTask {","                  await pgTask.value","               }","           }","        )","    }","","    func handle(_ event: Event, context: LambdaContext) async throws -> Output {","        \/\/\/ Use the initialized service stored in `self.pgClient`","        try await self.pgClient.query(...)","    }","}"]},{"type":"heading","anchor":"Verbose-Codable-support","text":"Verbose Codable support","level":4},{"inlineContent":[{"type":"text","text":"In the current API, there are extensions and Codable wrapper classes for decoding events and encoding computed responses"},{"type":"text","text":" "},{"type":"text","text":"for "},{"inlineContent":[{"type":"text","text":"each"}],"type":"emphasis"},{"type":"text","text":" different handler protocol and for both "},{"type":"codeVoice","code":"String"},{"type":"text","text":" and "},{"type":"codeVoice","code":"JSON"},{"text":" formats. This has resulted in a lot of","type":"text"},{"type":"text","text":" "},{"type":"text","text":"boilerplate code which can very easily be made generic and simplified in v2."}],"type":"paragraph"},{"level":3,"anchor":"New-features","text":"New features","type":"heading"},{"anchor":"Support-response-streaming","text":"Support response streaming","type":"heading","level":4},{"type":"paragraph","inlineContent":[{"type":"text","text":"In April 2023"},{"text":" ","type":"text"},{"isActive":true,"identifier":"https:\/\/aws.amazon.com\/blogs\/compute\/introducing-aws-lambda-response-streaming\/","type":"reference"},{"type":"text","text":" "},{"text":"in Lambda. The current API does not support streaming. For v2 we want to change this.","type":"text"}]},{"text":"Scheduling background work","level":4,"type":"heading","anchor":"Scheduling-background-work"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In May"},{"type":"text","text":" "},{"identifier":"https:\/\/aws.amazon.com\/blogs\/compute\/running-code-after-returning-a-response-from-an-aws-lambda-function\/","isActive":true,"type":"reference"},{"type":"text","text":" "},{"type":"text","text":"until the runtime asks for more work from the control plane. We want to support this by adding new API that allows"},{"type":"text","text":" "},{"type":"text","text":"background processing, even after the response has been returned."}]},{"level":2,"text":"Proposed Solution","anchor":"Proposed-Solution","type":"heading"},{"anchor":"asyncawait-first-API","level":3,"text":"async\/await-first API","type":"heading"},{"inlineContent":[{"type":"text","text":"Large parts of "},{"type":"codeVoice","code":"Lambda"},{"text":", ","type":"text"},{"type":"codeVoice","code":"LambdaHandler"},{"type":"text","text":", and "},{"code":"LambdaRuntime","type":"codeVoice"},{"type":"text","text":" will be re-written to use async\/await constructs in place"},{"type":"text","text":" "},{"type":"text","text":"of the "},{"type":"codeVoice","code":"EventLoop"},{"text":" family of interfaces.","type":"text"}],"type":"paragraph"},{"anchor":"Providing-ownership-of-main-and-support-for-swift-service-lifecycle","level":3,"type":"heading","text":"Providing ownership of main() and support for swift-service-lifecycle"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Instead of conforming to a handler protocol, users can now create a "},{"code":"LambdaRuntime","type":"codeVoice"},{"text":" by passing in a handler closure.","type":"text"}]}]},{"content":[{"inlineContent":[{"code":"LambdaRuntime","type":"codeVoice"},{"text":" conforms to ","type":"text"},{"type":"codeVoice","code":"ServiceLifecycle.Service"},{"type":"text","text":" by implementing a "},{"type":"codeVoice","code":"run()"},{"type":"text","text":" method that contains initialization"},{"type":"text","text":" "},{"text":"and graceful shutdown logic.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"This allows the lifecycle of the ","type":"text"},{"code":"LambdaRuntime","type":"codeVoice"},{"text":" to be managed with ","type":"text"},{"code":"swift-service-lifecycle","type":"codeVoice"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"text":"alongside","type":"text"}]},{"type":"text","text":" and in the"},{"type":"text","text":" "},{"type":"text","text":"same way the lifecycles of the required services are managed, e.g."},{"type":"text","text":" "},{"type":"codeVoice","code":"try await ServiceGroup(services: [postgresClient, ..., lambdaRuntime], ...).run()"},{"text":".","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Dependencies can now be injected into "},{"type":"codeVoice","code":"LambdaRuntime"},{"text":". With ","type":"text"},{"type":"codeVoice","code":"swift-service-lifecycle"},{"type":"text","text":", services will be initialized"},{"type":"text","text":" "},{"type":"text","text":"together with "},{"code":"LambdaRuntime","type":"codeVoice"},{"type":"text","text":"."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"The required services can then be used within the handler in a structured concurrency manner.","type":"text"},{"type":"text","text":" "},{"code":"swift-service-lifecycle","type":"codeVoice"},{"text":" takes care of listening for termination signals and terminating the services as well as the","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"LambdaRuntime"},{"type":"text","text":" in correct order."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"LambdaTerminator"},{"type":"text","text":" can now be eliminated because its role is replaced with "},{"code":"swift-service-lifecycle","type":"codeVoice"},{"type":"text","text":". The termination"},{"text":" ","type":"text"},{"text":"logic of the Lambda function will be implemented in the conforming ","type":"text"},{"type":"codeVoice","code":"run()"},{"type":"text","text":" function of "},{"code":"LambdaRuntime","type":"codeVoice"},{"type":"text","text":"."}]}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"text":"With this, the earlier code snippet can be replaced with something much easier to read, maintain, and debug:","type":"text"}]},{"type":"codeListing","code":["\/\/\/ Instantiate services","let postgresClient = PostgresClient()","","\/\/\/ Instantiate LambdaRuntime with a closure handler implementing the business logic of the Lambda function","let runtime = LambdaRuntime { (event: Input, context: LambdaContext) in","    \/\/\/ Use initialized service within the handler","    try await postgresClient.query(...)","}","","\/\/\/ Use ServiceLifecycle to manage the initialization and termination","\/\/\/ of the services as well as the LambdaRuntime","let serviceGroup = ServiceGroup(","    services: [postgresClient, runtime],","    configuration: .init(gracefulShutdownSignals: [.sigterm]),","    logger: logger",")","try await serviceGroup.run()"],"syntax":"swift"},{"anchor":"Simplifying-Codable-support","level":3,"type":"heading","text":"Simplifying Codable support"},{"type":"paragraph","inlineContent":[{"text":"A detailed explanation is provided in the ","type":"text"},{"inlineContent":[{"text":"Codable Support","type":"text"}],"type":"strong"},{"type":"text","text":" section. In short, much of the boilerplate code defined"},{"type":"text","text":" "},{"type":"text","text":"for each handler protocol in "},{"type":"codeVoice","code":"Lambda+Codable"},{"type":"text","text":" and "},{"code":"Lambda+String","type":"codeVoice"},{"text":" will be replaced with a single ","type":"text"},{"type":"codeVoice","code":"LambdaCodableAdapter"},{"type":"text","text":" "},{"text":"struct.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This adapter struct is generic over (1) any handler conforming to a new handler protocol"},{"text":" ","type":"text"},{"type":"codeVoice","code":"LambdaWithBackgroundProcessingHandler"},{"text":", (2) the user-specified input and output types, and (3) any decoder and encoder","type":"text"},{"type":"text","text":" "},{"type":"text","text":"conforming to protocols "},{"type":"codeVoice","code":"LambdaEventDecoder"},{"type":"text","text":" and "},{"type":"codeVoice","code":"LambdaOutputDecoder"},{"text":". The adapter will wrap the underlying handler","type":"text"},{"type":"text","text":" "},{"type":"text","text":"with encoding\/decoding logic."}]},{"text":"Detailed Solution","anchor":"Detailed-Solution","type":"heading","level":2},{"inlineContent":[{"text":"Below are explanations for all types that we want to use in AWS Lambda Runtime v2.","type":"text"}],"type":"paragraph"},{"level":3,"anchor":"LambdaResponseStreamWriter","type":"heading","text":"LambdaResponseStreamWriter"},{"type":"paragraph","inlineContent":[{"text":"We will introduce a new ","type":"text"},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"type":"text","text":" protocol. It is used in the new "},{"type":"codeVoice","code":"StreamingLambdaHandler"},{"text":" (defined","type":"text"},{"type":"text","text":" "},{"type":"text","text":"below), which is the new base protocol for the "},{"type":"codeVoice","code":"LambdaRuntime"},{"text":" (defined below as well).","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["\/\/\/ A writer object to write the Lambda response stream into","public protocol LambdaResponseStreamWriter {","    \/\/\/ Write a response part into the stream. The HTTP response is started lazily before the first call to `write(_:)`.","    \/\/\/ Bytes written to the writer are streamed continually.","    func write(_ buffer: ByteBuffer) async throws","    \/\/\/ End the response stream and the underlying HTTP response.","    func finish() async throws","    \/\/\/ Write a response part into the stream and end the response stream as well as the underlying HTTP response.","    func writeAndFinish(_ buffer: ByteBuffer) async throws","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If the user does not call "},{"type":"codeVoice","code":"finish()"},{"type":"text","text":", the library will automatically finish the stream after the last "},{"code":"write","type":"codeVoice"},{"text":".","type":"text"},{"type":"text","text":" "},{"text":"Appropriate errors will be thrown if ","type":"text"},{"type":"codeVoice","code":"finish()"},{"type":"text","text":" is called multiple times, or if "},{"type":"codeVoice","code":"write"},{"type":"text","text":"\/"},{"type":"codeVoice","code":"writeAndFinish"},{"type":"text","text":" is called after"},{"type":"text","text":" "},{"type":"codeVoice","code":"finish()"},{"text":".","type":"text"}]},{"anchor":"LambdaContext","level":3,"type":"heading","text":"LambdaContext"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"LambdaContext"},{"type":"text","text":" will be largely unchanged, but the "},{"code":"eventLoop","type":"codeVoice"},{"type":"text","text":" property will be removed. The "},{"type":"codeVoice","code":"allocator"},{"type":"text","text":" property of"},{"text":" ","type":"text"},{"type":"text","text":"type "},{"type":"codeVoice","code":"ByteBufferAllocator"},{"text":" will also be removed because (1), we generally want to reduce the number of SwiftNIO types","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"exposed in the API, and (2), "},{"code":"ByteBufferAllocator","type":"codeVoice"},{"type":"text","text":" does not optimize the allocation strategies. The common pattern"},{"type":"text","text":" "},{"text":"observed across many libraries is to re-use existing ","type":"text"},{"type":"codeVoice","code":"ByteBuffer"},{"text":"s as much as possible. This is also what we do for the","type":"text"},{"text":" ","type":"text"},{"type":"codeVoice","code":"LambdaCodableAdapter"},{"type":"text","text":" (explained in the "},{"inlineContent":[{"text":"Codable Support","type":"text"}],"type":"strong"},{"text":" section) implementation.","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["\/\/\/ A context object passed as part of an invocation in LambdaHandler handle functions.","public struct LambdaContext: Sendable {","    \/\/\/ The request ID, which identifies the request that triggered the function invocation.","    public var requestID: String { get }","","    \/\/\/ The AWS X-Ray tracing header.","    public var traceID: String { get }","","    \/\/\/ The ARN of the Lambda function, version, or alias that's specified in the invocation.","    public var invokedFunctionARN: String { get }","","    \/\/\/ The timestamp that the function times out.","    public var deadline: DispatchWallTime { get }","","    \/\/\/ For invocations from the AWS Mobile SDK, data about the Amazon Cognito identity provider.","    public var cognitoIdentity: String? { get }","","    \/\/\/ For invocations from the AWS Mobile SDK, data about the client application and device.","    public var clientContext: String? { get }","","    \/\/\/ `Logger` to log with.","    \/\/\/","    \/\/\/ - note: The `LogLevel` can be configured using the `LOG_LEVEL` environment variable.","    public var logger: Logger { get }","}"]},{"type":"heading","text":"Handlers","anchor":"Handlers","level":3},{"inlineContent":[{"text":"We introduce three handler protocols: ","type":"text"},{"code":"StreamingLambdaHandler","type":"codeVoice"},{"type":"text","text":", "},{"type":"codeVoice","code":"LambdaHandler"},{"text":", and","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"LambdaWithBackgroundProcessingHandler"},{"type":"text","text":"."}],"type":"paragraph"},{"level":4,"type":"heading","text":"StreamingLambdaHandler","anchor":"StreamingLambdaHandler"},{"type":"paragraph","inlineContent":[{"text":"The new ","type":"text"},{"code":"StreamingLambdaHandler","type":"codeVoice"},{"text":" protocol is the base protocol to implement a Lambda function. Most users will not use","type":"text"},{"type":"text","text":" "},{"type":"text","text":"this protocol and instead use the "},{"type":"codeVoice","code":"LambdaHandler"},{"type":"text","text":" protocol defined below."}]},{"type":"codeListing","syntax":"swift","code":["\/\/\/ The base StreamingLambdaHandler protocol","public protocol StreamingLambdaHandler {","    \/\/\/ The business logic of the Lambda function","    \/\/\/ - Parameters:","    \/\/\/   - event: The invocation's input data","    \/\/\/   - responseWriter: A ``LambdaResponseStreamWriter`` to write the invocation's response to.","    \/\/\/                     If no response or error is written to the `responseWriter` it will","    \/\/\/                     report an error to the invoker.","    \/\/\/   - context: The LambdaContext containing the invocation's metadata","    \/\/\/ - Throws:","    \/\/\/ How the thrown error will be handled by the runtime:","    \/\/\/   - An invocation error will be reported if the error is thrown before the first call to","    \/\/\/     ``LambdaResponseStreamWriter.write(_:)``.","    \/\/\/   - If the error is thrown after call(s) to ``LambdaResponseStreamWriter.write(_:)`` but before","    \/\/\/     a call to ``LambdaResponseStreamWriter.finish()``, the response stream will be closed and trailing","    \/\/\/     headers will be sent.","    \/\/\/   - If ``LambdaResponseStreamWriter.finish()`` has already been called before the error is thrown, the","    \/\/\/     error will be logged.","    mutating func handle(_ event: ByteBuffer, responseWriter: some LambdaResponseStreamWriter, context: LambdaContext) async throws","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Using this protocol requires the "},{"type":"codeVoice","code":"handle"},{"text":" method to receive the incoming event as a ","type":"text"},{"code":"ByteBuffer","type":"codeVoice"},{"text":" and return the output","type":"text"},{"type":"text","text":" "},{"type":"text","text":"as a "},{"type":"codeVoice","code":"ByteBuffer"},{"text":" too.","type":"text"}]},{"inlineContent":[{"type":"text","text":"Through the "},{"code":"LambdaResponseStreamWriter","type":"codeVoice"},{"type":"text","text":", which is passed as an argument in the "},{"type":"codeVoice","code":"handle"},{"text":" function, the ","type":"text"},{"inlineContent":[{"type":"text","text":"response can be"},{"text":" ","type":"text"},{"text":"streamed","type":"text"}],"type":"strong"},{"text":" by calling the ","type":"text"},{"type":"codeVoice","code":"write(_:)"},{"type":"text","text":" function of the "},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"text":" with partial data repeatedly before","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"finally closing the response stream by calling "},{"code":"finish()","type":"codeVoice"},{"type":"text","text":". Users can also choose to return the entire output and not"},{"type":"text","text":" "},{"type":"text","text":"stream the response by calling "},{"code":"writeAndFinish(_:)","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This protocol also allows for background tasks to be run after a result has been reported to the AWS Lambda control"},{"text":" ","type":"text"},{"text":"plane, since the ","type":"text"},{"code":"handle(...)","type":"codeVoice"},{"text":" function is free to implement any background work after the call to","type":"text"},{"type":"text","text":" "},{"code":"responseWriter.finish()","type":"codeVoice"},{"type":"text","text":"."}]},{"inlineContent":[{"type":"text","text":"The protocol is defined in a way that supports a broad range of use-cases. The handle method is marked as "},{"type":"codeVoice","code":"mutating"},{"type":"text","text":" to"},{"type":"text","text":" "},{"text":"allow handlers to be implemented with a ","type":"text"},{"code":"struct","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"An implementation that sends the number 1 to 10 every 500ms could look like this:"}]},{"syntax":"swift","type":"codeListing","code":["struct SendNumbersWithPause: StreamingLambdaHandler {","    func handle(","        _ event: ByteBuffer,","        responseWriter: some LambdaResponseStreamWriter,","        context: LambdaContext","    ) async throws {","        for i in 1...10 {","            \/\/ Send partial data","            responseWriter.write(ByteBuffer(string: #\"\\#(i)\\n\\r\"#))","            \/\/ Perform some long asynchronous work","            try await Task.sleep(for: .milliseconds(500))","        }","        \/\/ All data has been sent. Close off the response stream.","        responseWriter.finish()","    }","}"]},{"anchor":"LambdaHandler","text":"LambdaHandler:","type":"heading","level":4},{"type":"paragraph","inlineContent":[{"type":"text","text":"This handler protocol will be the go-to choice for most use-cases because it is completely agnostic to any"},{"type":"text","text":" "},{"text":"encoding\/decoding logic – conforming objects simply have to implement the ","type":"text"},{"code":"handle","type":"codeVoice"},{"text":" function where the input and return","type":"text"},{"type":"text","text":" "},{"type":"text","text":"types are Swift objects."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that the "},{"code":"handle","type":"codeVoice"},{"text":" function does not receive a ","type":"text"},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"text":" as an argument. Response streaming is","type":"text"},{"type":"text","text":" "},{"type":"text","text":"not viable for "},{"type":"codeVoice","code":"LambdaHandler"},{"type":"text","text":" because the output has to be encoded prior to it being sent, e.g. it is not possible to"},{"text":" ","type":"text"},{"type":"text","text":"encode a partial\/incomplete JSON string."}]},{"syntax":"swift","type":"codeListing","code":["public protocol LambdaHandler {","    \/\/\/ Generic input type","    \/\/\/ The body of the request sent to Lambda will be decoded into this type for the handler to consume","    associatedtype Event","    \/\/\/ Generic output type","    \/\/\/ This is the return type of the handle() function.","    associatedtype Output","","    \/\/\/ The business logic of the Lambda function. Receives a generic input type and returns a generic output type.","    \/\/\/ Agnostic to encoding\/decoding","    mutating func handle(_ event: Event, context: LambdaContext) async throws -> Output","}"]},{"text":"LambdaWithBackgroundProcessingHandler:","anchor":"LambdaWithBackgroundProcessingHandler","type":"heading","level":4},{"type":"paragraph","inlineContent":[{"type":"text","text":"This protocol is exactly like "},{"type":"codeVoice","code":"LambdaHandler"},{"text":", with the only difference being the added support for executing background","type":"text"},{"type":"text","text":" "},{"type":"text","text":"work after the result has been sent to the AWS Lambda control plane."}]},{"inlineContent":[{"text":"This is achieved by not having a return type in the ","type":"text"},{"type":"codeVoice","code":"handle"},{"text":" function. The output is instead written into a","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"LambdaResponseWriter"},{"type":"text","text":" that is passed in as an argument, meaning that the "},{"type":"codeVoice","code":"handle"},{"text":" function is then free to implement","type":"text"},{"type":"text","text":" "},{"type":"text","text":"any background work after the result has been sent to the AWS Lambda control plane."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"LambdaResponseWriter"},{"text":" has different semantics to the ","type":"text"},{"code":"LambdaResponseStreamWriter","type":"codeVoice"},{"type":"text","text":". Where the "},{"type":"codeVoice","code":"write(_:)"},{"type":"text","text":" function of"},{"type":"text","text":" "},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"type":"text","text":" means writing into a response stream, the "},{"type":"codeVoice","code":"write(_:)"},{"type":"text","text":" function of "},{"type":"codeVoice","code":"LambdaResponseWriter"},{"type":"text","text":" "},{"type":"text","text":"simply serves as a mechanism to return the output without explicitly returning from the "},{"code":"handle","type":"codeVoice"},{"type":"text","text":" function."}]},{"code":["public protocol LambdaResponseWriter<Output> {","    associatedtype Output","","    \/\/\/ Sends the generic Output object (representing the computed result of the handler)","    \/\/\/ to the AWS Lambda response endpoint.","    \/\/\/ An error will be thrown if this function is called more than once.","    func write(_: Output) async throws","}","","public protocol LambdaWithBackgroundProcessingHandler {","    \/\/\/ Generic input type","    \/\/\/ The body of the request sent to Lambda will be decoded into this type for the handler to consume","    associatedtype Event","    \/\/\/ Generic output type","    \/\/\/ This is the type that the handle() function will send through the ``LambdaResponseWriter``.","    associatedtype Output","","    \/\/\/ The business logic of the Lambda function. Receives a generic input type and returns a generic output type.","    \/\/\/ Agnostic to JSON encoding\/decoding","    func handle(","        _ event: Event,","        outputWriter: some LambdaResponseWriter<Output>,","        context: LambdaContext","    ) async throws","}"],"syntax":"swift","type":"codeListing"},{"type":"heading","anchor":"Example-Usage","level":5,"text":"Example Usage:"},{"syntax":"swift","code":["struct BackgroundProcessingHandler: LambdaWithBackgroundProcessingHandler {","    struct Input: Decodable {","        let message: String","    }","","    struct Greeting: Encodable {","        let echoedMessage: String","    }","","    typealias Event = Input","    typealias Output = Greeting","","    func handle(","        _ event: Event,","        outputWriter: some LambdaResponseWriter<Output>,","        context: LambdaContext","    ) async throws {","        \/\/ Return result to the Lambda control plane","        try await outputWriter.write(result: Greeting(echoedMessage: event.messageToEcho))","","        \/\/ Perform some background work, e.g:","        try await Task.sleep(for: .seconds(10))","","        \/\/ Exit the function. All asynchronous work has been executed before exiting the scope of this function.","        \/\/ Follows structured concurrency principles.","        return","    }","}"],"type":"codeListing"},{"level":4,"type":"heading","text":"Handler Adapters","anchor":"Handler-Adapters"},{"inlineContent":[{"text":"Since the ","type":"text"},{"type":"codeVoice","code":"StreamingLambdaHandler"},{"text":" protocol is the base protocol the ","type":"text"},{"code":"LambdaRuntime","type":"codeVoice"},{"type":"text","text":" works with, there are adapters to"},{"type":"text","text":" "},{"type":"text","text":"make both "},{"code":"LambdaHandler","type":"codeVoice"},{"type":"text","text":" and "},{"type":"codeVoice","code":"LambdaWithBackgroundProcessingHandler"},{"type":"text","text":" compatible with "},{"code":"StreamingLambdaHandler","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"code":"LambdaHandlerAdapter","type":"codeVoice"},{"text":" accepts a ","type":"text"},{"code":"LambdaHandler","type":"codeVoice"},{"type":"text","text":" and conforms it to "},{"type":"codeVoice","code":"LambdaWithBackgroundProcessingHandler"},{"type":"text","text":". This is"},{"type":"text","text":" "},{"type":"text","text":"achieved by taking the generic "},{"type":"codeVoice","code":"Output"},{"type":"text","text":" object returned from the "},{"code":"handle","type":"codeVoice"},{"type":"text","text":" function of "},{"type":"codeVoice","code":"LambdaHandler"},{"text":" and passing it","type":"text"},{"type":"text","text":" "},{"type":"text","text":"to the "},{"code":"write(_:)","type":"codeVoice"},{"type":"text","text":" function of the "},{"code":"LambdaResponseWriter","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"codeVoice","code":"LambdaCodableAdapter"},{"type":"text","text":" accepts a "},{"type":"codeVoice","code":"LambdaWithBackgroundProcessingHandler"},{"type":"text","text":" and conforms it to "},{"code":"StreamingLambdaHandler","type":"codeVoice"},{"text":".","type":"text"},{"type":"text","text":" "},{"type":"text","text":"This is achieved by wrapping the "},{"code":"LambdaResponseWriter","type":"codeVoice"},{"text":" with the ","type":"text"},{"code":"LambdaResponseStreamWriter","type":"codeVoice"},{"type":"text","text":" provided by"},{"text":" ","type":"text"},{"type":"codeVoice","code":"StreamingLambdaHandler"},{"type":"text","text":". A call to the "},{"type":"codeVoice","code":"write(_:)"},{"text":" function of ","type":"text"},{"type":"codeVoice","code":"LambdaResponseWriter"},{"type":"text","text":" is translated into a call to"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":"writeAndFinish(_:)"},{"type":"text","text":" function of "},{"code":"LambdaResponseStreamWriter","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"}]}],"type":"orderedList"},{"type":"paragraph","inlineContent":[{"text":"Both ","type":"text"},{"code":"LambdaHandlerAdapter","type":"codeVoice"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"LambdaCodableAdapter"},{"type":"text","text":" are described in greater detail in the "},{"type":"strong","inlineContent":[{"type":"text","text":"Codable Support"}]},{"type":"text","text":" "},{"type":"text","text":"section."}]},{"type":"paragraph","inlineContent":[{"text":"To summarize, ","type":"text"},{"type":"codeVoice","code":"LambdaHandler"},{"type":"text","text":" can be used with the "},{"code":"LambdaRuntime","type":"codeVoice"},{"type":"text","text":" by first going through "},{"code":"LambdaHandlerAdapter","type":"codeVoice"},{"type":"text","text":" and"},{"type":"text","text":" "},{"type":"text","text":"then through "},{"type":"codeVoice","code":"LambdaCodableAdapter"},{"text":". ","type":"text"},{"type":"codeVoice","code":"LambdaWithBackgroundHandler"},{"text":" just requires ","type":"text"},{"code":"LambdaCodableAdapter","type":"codeVoice"},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"For the common JSON-in and JSON-out use-case, there is an extension on ","type":"text"},{"type":"codeVoice","code":"LambdaRuntime"},{"type":"text","text":" that abstracts away this wrapping"},{"text":" ","type":"text"},{"type":"text","text":"from the user."}]},{"anchor":"LambdaRuntime","text":"LambdaRuntime","level":3,"type":"heading"},{"inlineContent":[{"type":"codeVoice","code":"LambdaRuntime"},{"text":" is the class that communicates with the Lambda control plane as defined in","type":"text"},{"type":"text","text":" "},{"type":"reference","identifier":"https:\/\/docs.aws.amazon.com\/lambda\/latest\/dg\/runtimes-custom.html","isActive":true},{"type":"text","text":" and"},{"type":"text","text":" "},{"text":"forward the invocations to the provided ","type":"text"},{"type":"codeVoice","code":"StreamingLambdaHandler"},{"type":"text","text":". It will conform to "},{"type":"codeVoice","code":"ServiceLifecycle.Service"},{"type":"text","text":" to"},{"text":" ","type":"text"},{"type":"text","text":"provide support for "},{"type":"codeVoice","code":"swift-service-lifecycle"},{"type":"text","text":"."}],"type":"paragraph"},{"code":["\/\/\/ The LambdaRuntime object. This object communicates with the Lambda control plane","\/\/\/ to fetch work and report errors.","public final class LambdaRuntime<Handler>: ServiceLifecycle.Service, Sendable","    where Handler: StreamingLambdaHandler","{","","    \/\/\/ Create a LambdaRuntime by passing a handler, an eventLoop and a logger.","    \/\/\/ - Parameter handler: A ``StreamingLambdaHandler`` that will be invoked","    \/\/\/ - Parameter eventLoop: An ``EventLoop`` on which the LambdaRuntime will be","    \/\/\/                        executed. Defaults to an EventLoop from","    \/\/\/                        ``NIOSingletons.posixEventLoopGroup``.","    \/\/\/ - Parameter logger: A logger","    public init(","        handler: sending Handler,","        eventLoop: EventLoop = Lambda.defaultEventLoop,","        logger: Logger = Logger(label: \"Lambda\")","    )","","    \/\/\/ Create a LambdaRuntime by passing a ``StreamingLambdaHandler``.","    public convenience init(handler: sending Handler)","","    \/\/\/ Starts the LambdaRuntime by connecting to the Lambda control plane to ask","    \/\/\/ for events to process. If the environment variable AWS_LAMBDA_RUNTIME_API is","    \/\/\/ set, the LambdaRuntime will connect to the Lambda control plane. Otherwise","    \/\/\/ it will start a mock server that can be used for testing at port 8080","    \/\/\/ locally.","    \/\/\/ Cancel the task that runs this function to close the communication with","    \/\/\/ the Lambda control plane or close the local mock server. This function","    \/\/\/ only returns once cancelled.","    public func run() async throws","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The current API allows for a Lambda function to be tested locally through a mock server by requiring an environment"},{"type":"text","text":" "},{"type":"text","text":"variable named "},{"code":"LOCAL_LAMBDA_SERVER_ENABLED","type":"codeVoice"},{"text":" to be set to ","type":"text"},{"code":"true","type":"codeVoice"},{"text":". If this environment variable is not set, the program","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"immediately crashes as the user will not have the "},{"code":"AWS_LAMBDA_RUNTIME_API","type":"codeVoice"},{"type":"text","text":" environment variable on their local machine"},{"type":"text","text":" "},{"text":"(set automatically when deployed to AWS Lambda). However, making the user set the ","type":"text"},{"code":"LOCAL_LAMBDA_SERVER_ENABLED","type":"codeVoice"},{"type":"text","text":" "},{"text":"environment variable is an unnecessary step that can be avoided. In the v2 API, the ","type":"text"},{"code":"run()","type":"codeVoice"},{"type":"text","text":" function will automatically"},{"text":" ","type":"text"},{"text":"start the mock server when the ","type":"text"},{"type":"codeVoice","code":"AWS_LAMBDA_RUNTIME_API"},{"type":"text","text":" environment variable cannot be found."}]},{"type":"heading","level":3,"text":"Lambda","anchor":"Lambda"},{"inlineContent":[{"text":"We also add an enum to store a static function and a property on. We put this on the static ","type":"text"},{"type":"codeVoice","code":"Lambda"},{"text":" because","type":"text"},{"type":"text","text":" "},{"code":"LambdaRuntime","type":"codeVoice"},{"type":"text","text":" is generic and thus has bad ergonomics for static properties and functions."}],"type":"paragraph"},{"syntax":"swift","code":["enum Lambda {","    \/\/\/ This returns the default EventLoop that a LambdaRuntime is scheduled on.","    \/\/\/ It uses `NIOSingletons.posixEventLoopGroup.next()` under the hood.","    public static var defaultEventLoop: any EventLoop { get }","","    \/\/\/ Report a startup error to the Lambda Control Plane API","    public static func reportStartupError(any Error) async","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Since the library now provides ownership of the "},{"type":"codeVoice","code":"main()"},{"type":"text","text":" function and allows users to initialize services before the"},{"text":" ","type":"text"},{"code":"LambdaRuntime","type":"codeVoice"},{"type":"text","text":" is initialized, the library cannot implicitly report"},{"text":" ","type":"text"},{"identifier":"https:\/\/docs.aws.amazon.com\/lambda\/latest\/dg\/runtimes-api.html#runtimes-api-initerror","isActive":true,"type":"reference"},{"type":"text","text":" "},{"type":"text","text":"like it currently does through the "},{"code":"initialize()","type":"codeVoice"},{"type":"text","text":" function of "},{"type":"codeVoice","code":"LambdaRunner"},{"type":"text","text":" which wraps the handler’s "},{"code":"init(...)","type":"codeVoice"},{"type":"text","text":" and"},{"type":"text","text":" "},{"type":"text","text":"handles any errors thrown by reporting it to the dedicated AWS endpoint."}]},{"inlineContent":[{"text":"To retain support for initialization error reporting, the ","type":"text"},{"code":"Lambda.reportStartupError(any Error)","type":"codeVoice"},{"type":"text","text":" function gives users"},{"type":"text","text":" "},{"text":"the option to manually report initialization errors in their closure handler. Although this should ideally happen","type":"text"},{"type":"text","text":" "},{"type":"text","text":"implicitly like it currently does in v1, we believe this is a small compromise in comparison to the benefits gained in"},{"text":" ","type":"text"},{"text":"now being able to cleanly manage the lifecycles of required services in a structured concurrency manner.","type":"text"}],"type":"paragraph"},{"type":"aside","style":"note","name":"Use-case","content":[{"inlineContent":[{"type":"text","text":""}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Assume we want to load a secret for the Lambda function from a secret vault first. If this fails, we want to report"},{"text":" ","type":"text"},{"type":"text","text":"the error to the control plane:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["let secretVault = SecretVault()","","do {","   \/\/\/ !!! Error thrown: secret \"foo\" does not exist !!!","   let secret = try await secretVault.getSecret(\"foo\")","","   let runtime = LambdaRuntime { (event: Input, context: LambdaContext) in","       \/\/\/ Lambda business logic","   }","","   let serviceGroup = ServiceGroup(","       services: [postgresClient, runtime],","       configuration: .init(gracefulShutdownSignals: [.sigterm]),","       logger: logger","   )","   try await serviceGroup.run()","} catch {","   \/\/\/ Report startup error straight away to the dedicated initialization error endpoint","   try await Lambda.reportStartupError(error)","}"]}]},{"level":3,"type":"heading","text":"Codable support","anchor":"Codable-support"},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"code":"LambdaHandler","type":"codeVoice"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"LambdaWithBackgroundProcessingHandler"},{"type":"text","text":" protocols abstract away encoding\/decoding logic from the"},{"text":" ","type":"text"},{"type":"text","text":"conformers as they are generic over custom "},{"code":"Event","type":"codeVoice"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Output"},{"text":" types. We introduce two adapters ","type":"text"},{"type":"codeVoice","code":"LambdaHandlerAdapter"},{"text":" ","type":"text"},{"type":"text","text":"and "},{"code":"CodableLambdaAdapter","type":"codeVoice"},{"type":"text","text":" that implement the encoding\/decoding logic and in turn allow the respective handlers to"},{"type":"text","text":" "},{"type":"text","text":"conform to "},{"type":"codeVoice","code":"StreamingLambdaHandler"},{"text":".","type":"text"}]},{"level":4,"text":"LambdaHandlerAdapter","anchor":"LambdaHandlerAdapter","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"Any handler conforming to ","type":"text"},{"code":"LambdaHandler","type":"codeVoice"},{"type":"text","text":" can be conformed to "},{"type":"codeVoice","code":"LambdaWithBackgroundProcessingHandler"},{"type":"text","text":" through"},{"type":"text","text":" "},{"type":"codeVoice","code":"LambdaHandlerAdapter"},{"type":"text","text":"."}]},{"code":["\/\/\/ Wraps an underlying handler conforming to ``LambdaHandler``","\/\/\/ with ``LambdaWithBackgroundProcessingHandler``.","public struct LambdaHandlerAdapter<","    Event: Decodable,","    Output,","    Handler: LambdaHandler",">: LambdaWithBackgroundProcessingHandler where Handler.Event == Event, Handler.Output == Output {","    let handler: Handler","","    \/\/\/ Register the concrete handler.","    public init(handler: Handler)","","    \/\/\/ 1. Call the `self.handler.handle(...)` with `event` and `context`.","    \/\/\/ 2. Pass the generic `Output` object returned from `self.handler.handle(...)` to `outputWriter.write(_:)`","    public func handle(_ event: Event, outputWriter: some LambdaResponseWriter<Output>, context: LambdaContext) async throws","}"],"type":"codeListing","syntax":"swift"},{"text":"LambdaCodableAdapter","level":4,"anchor":"LambdaCodableAdapter","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"LambdaCodableAdapter"},{"type":"text","text":" accepts any generic underlying handler conforming to "},{"type":"codeVoice","code":"LambdaWithBackgroundProcessingHandler"},{"type":"text","text":". It"},{"text":" ","type":"text"},{"text":"also accepts ","type":"text"},{"inlineContent":[{"type":"text","text":"any"}],"type":"emphasis"},{"text":" encoder and decoder object conforming to the ","type":"text"},{"code":"LambdaEventDecoder","type":"codeVoice"},{"type":"text","text":" and "},{"type":"codeVoice","code":"LambdaOutputEncoder"},{"type":"text","text":" "},{"text":"protocols:","type":"text"}]},{"level":5,"text":"LambdaEventDecoder and LambdaOutputEncoder protocols","anchor":"LambdaEventDecoder-and-LambdaOutputEncoder-protocols","type":"heading"},{"type":"codeListing","syntax":"swift","code":["public protocol LambdaEventDecoder {","    \/\/\/ Decode the ByteBuffer representing the received event into the generic type Event","    \/\/\/ the handler will receive","    func decode<Event: Decodable>(_ type: Event.Type, from buffer: ByteBuffer) throws -> Event","}","","public protocol LambdaOutputEncoder {","    \/\/\/ Encode the generic type Output the handler has produced into a ByteBuffer","    func encode<Output: Encodable>(_ value: Output, into buffer: inout ByteBuffer) throws","}"]},{"inlineContent":[{"type":"text","text":"We provide conformances for Foundation’s "},{"type":"codeVoice","code":"JSONDecoder"},{"type":"text","text":" to "},{"type":"codeVoice","code":"LambdaEventDecoder"},{"type":"text","text":" and "},{"code":"JSONEncoder","type":"codeVoice"},{"type":"text","text":" to"},{"type":"text","text":" "},{"code":"LambdaOutputEncoder","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"LambdaCodableAdapter"},{"type":"text","text":" implements its "},{"code":"handle()","type":"codeVoice"},{"text":" method by:","type":"text"}]},{"type":"orderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Decoding the ","type":"text"},{"code":"ByteBuffer","type":"codeVoice"},{"type":"text","text":" event into the generic "},{"code":"Event","type":"codeVoice"},{"text":" type.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Wrapping the ","type":"text"},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"type":"text","text":" with a concrete "},{"type":"codeVoice","code":"LambdaResponseWriter"},{"type":"text","text":" such that calls to"},{"text":" ","type":"text"},{"type":"codeVoice","code":"LambdaResponseWriter"},{"type":"text","text":"s "},{"code":"write(_:)","type":"codeVoice"},{"type":"text","text":" are mapped to "},{"code":"LambdaResponseStreamWriter","type":"codeVoice"},{"type":"text","text":"s "},{"code":"writeAndFinish(_:)","type":"codeVoice"},{"type":"text","text":"."}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that the argument to "},{"type":"codeVoice","code":"LambdaResponseWriter"},{"text":"s ","type":"text"},{"type":"codeVoice","code":"write(_:)"},{"text":" is a generic ","type":"text"},{"type":"codeVoice","code":"Output"},{"type":"text","text":" object whereas"},{"type":"text","text":" "},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"type":"text","text":"s "},{"type":"codeVoice","code":"writeAndFinish(_:)"},{"type":"text","text":" requires a "},{"code":"ByteBuffer","type":"codeVoice"},{"type":"text","text":"."}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Therefore, the concrete implementation of "},{"code":"LambdaResponseWriter","type":"codeVoice"},{"text":" also accepts an encoder. Its ","type":"text"},{"type":"codeVoice","code":"write(_:)"},{"text":" function","type":"text"},{"text":" ","type":"text"},{"text":"first encodes the generic ","type":"text"},{"code":"Output","type":"codeVoice"},{"type":"text","text":" object and then passes it to the underlying "},{"code":"LambdaResponseStreamWriter","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"}]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Passing the generic ","type":"text"},{"code":"Event","type":"codeVoice"},{"type":"text","text":" instance, the concrete "},{"type":"codeVoice","code":"LambdaResponseWriter"},{"text":", as well as the ","type":"text"},{"type":"codeVoice","code":"LambdaContext"},{"type":"text","text":" to the"},{"text":" ","type":"text"},{"type":"text","text":"underlying handler’s "},{"type":"codeVoice","code":"handle()"},{"text":" method.","type":"text"}]}]}]},{"inlineContent":[{"type":"codeVoice","code":"LambdaCodableAdapter"},{"type":"text","text":" can implement encoding\/decoding for "},{"inlineContent":[{"text":"any","type":"text"}],"type":"emphasis"},{"text":" handler conforming to","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"LambdaWithBackgroundProcessingHandler"},{"type":"text","text":" if "},{"code":"Event","type":"codeVoice"},{"text":" is ","type":"text"},{"code":"Decodable","type":"codeVoice"},{"type":"text","text":" and the "},{"type":"codeVoice","code":"Output"},{"type":"text","text":" is "},{"code":"Encodable","type":"codeVoice"},{"type":"text","text":" or "},{"type":"codeVoice","code":"Void"},{"type":"text","text":", meaning"},{"text":" ","type":"text"},{"type":"text","text":"that the encoding\/decoding stubs do not need to be implemented by the user."}],"type":"paragraph"},{"syntax":"swift","code":["\/\/\/ Wraps an underlying handler conforming to `LambdaWithBackgroundProcessingHandler`","\/\/\/ with encoding\/decoding logic","public struct LambdaCodableAdapter<","    Handler: LambdaWithBackgroundProcessingHandler,","    Event: Decodable,","    Output,","    Decoder: LambdaEventDecoder,","    Encoder: LambdaOutputEncoder",">: StreamingLambdaHandler where Handler.Output == Output, Handler.Event == Event {","","    \/\/\/ Register the concrete handler, encoder, and decoder.","    public init(","        handler: Handler,","        encoder: Encoder,","        decoder: Decoder","    ) where Output: Encodable","","    \/\/\/ For handler with a void output -- the user doesn't specify an encoder.","    public init(","        handler: Handler,","        decoder: Decoder","    ) where Output == Void, Encoder == VoidEncoder","","    \/\/\/ 1. Decode the invocation event using `self.decoder`","    \/\/\/ 2. Create a concrete `LambdaResponseWriter` that maps calls to `write(_:)` with the `responseWriter`s `writeAndFinish(_:)`","    \/\/\/ 2. Call the underlying `self.handler.handle()` method with the decoded event data, the concrete `LambdaResponseWriter`,","    \/\/\/ and the `LambdaContext`.","    public mutating func handle(","        _ request: ByteBuffer,","        responseWriter: some LambdaResponseStreamWriter,","        context: LambdaContext","    ) async throws","}"],"type":"codeListing"},{"level":3,"anchor":"Handler-as-a-Closure","type":"heading","text":"Handler as a Closure"},{"inlineContent":[{"type":"text","text":"To create a Lambda function using the current API, a user first has to create an object and conform it to one of the"},{"text":" ","type":"text"},{"text":"handler protocols by implementing the initializer and the ","type":"text"},{"type":"codeVoice","code":"handle(...)"},{"text":" function. Now that ","type":"text"},{"code":"LambdaRuntime","type":"codeVoice"},{"text":" is public,","type":"text"},{"text":" ","type":"text"},{"text":"this verbosity can very easily be simplified.","type":"text"}],"type":"paragraph"},{"type":"heading","text":"ClosureHandler","anchor":"ClosureHandler","level":4},{"type":"paragraph","inlineContent":[{"text":"This handler is generic over any ","type":"text"},{"type":"codeVoice","code":"Event"},{"text":" type conforming to ","type":"text"},{"code":"Decodable","type":"codeVoice"},{"type":"text","text":" and any "},{"type":"codeVoice","code":"Output"},{"type":"text","text":" type conforming to "},{"type":"codeVoice","code":"Encodable"},{"type":"text","text":" "},{"text":"or ","type":"text"},{"type":"codeVoice","code":"Void"},{"text":".","type":"text"}]},{"code":["public struct ClosureHandler<Event, Output>: LambdaHandler {","    \/\/\/ Initialize with a closure handler over generic Input and Output types","    public init(body: @escaping (Event, LambdaContext) async throws -> Output) where Output: Encodable","    \/\/\/ Initialize with a closure handler over a generic Input type (Void Output).","    public init(body: @escaping (Event, LambdaContext) async throws -> Void) where Output == Void","    \/\/\/ The business logic of the Lambda function.","    public func handle(_ event: Event, context: LambdaContext) async throws -> Output","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"Given that ","type":"text"},{"code":"ClosureHandler","type":"codeVoice"},{"type":"text","text":" conforms to "},{"code":"LambdaHandler","type":"codeVoice"},{"text":":","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"text":"We can extend the ","type":"text"},{"type":"codeVoice","code":"LambdaRuntime"},{"type":"text","text":" initializer such that it accepts a closure as an argument."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Within the initializer, the closure handler is wrapped with ","type":"text"},{"type":"codeVoice","code":"LambdaCodableAdapter"},{"text":".","type":"text"}]}]}],"type":"orderedList"},{"type":"codeListing","syntax":"swift","code":["extension LambdaRuntime {","    \/\/\/ Initialize a LambdaRuntime with a closure handler over generic Event and Output types.","    \/\/\/ This initializer bolts on encoding\/decoding logic by wrapping the closure handler with","    \/\/\/ LambdaCodableAdapter.","    public init<Event: Decodable, Output: Encodable>(","        body: @escaping (Event, LambdaContext) async throws -> Output","    ) where Handler == LambdaCodableAdapter<ClosureHandler<Event, Output>, Event, Output, JSONDecoder, JSONEncoder>","","    \/\/\/ Same as above but for handlers with a void output","    public init<Event: Decodable>(","        body: @escaping (Event, LambdaContext) async throws -> Void","    ) where Handler == LambdaCodableAdapter<ClosureHandler<Event, Void>, Event, Void, JSONDecoder, VoidEncoder>","}"]},{"inlineContent":[{"type":"text","text":"We can now significantly reduce the verbosity and leverage Swift’s trailing closure syntax to cleanly create and run a"},{"type":"text","text":" "},{"type":"text","text":"Lambda function, abstracting away the decoding and encoding logic from the user:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["\/\/\/ The type the handler will use as input","struct Input: Decodable {","    var message: String","}","","\/\/\/ The type the handler will output","struct Greeting: Encodable {","    var echoedMessage: String","}","","\/\/\/ A simple Lambda function that echoes the input","let runtime = LambdaRuntime { (event: Input, context: LambdaContext) in","    Greeting(echoedMessage: event.message)","}","","try await runtime.run()"]},{"type":"paragraph","inlineContent":[{"text":"We also add a ","type":"text"},{"code":"StreamingClosureHandler","type":"codeVoice"},{"text":" conforming to ","type":"text"},{"code":"StreamingLambdaHandler","type":"codeVoice"},{"text":" for use-cases where the user wants to","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"handle encoding\/decoding themselves:"}]},{"type":"codeListing","code":["public struct StreamingClosureHandler: StreamingLambdaHandler {","","    public init(","        body: @escaping sending (ByteBuffer, LambdaResponseStreamWriter, LambdaContext) async throws -> ()","    )","","    public func handle(","        _ request: ByteBuffer,","        responseWriter: LambdaResponseStreamWriter,","        context: LambdaContext","    ) async throws","}","","extension LambdaRuntime {","    public init(","        body: @escaping sending (ByteBuffer, LambdaResponseStreamWriter, LambdaContext) async throws -> ()","    )","}"],"syntax":"swift"},{"type":"heading","anchor":"Alternatives-considered","level":2,"text":"Alternatives considered"},{"anchor":"UInt8-instead-of-ByteBuffer","text":"[UInt8] instead of ByteBuffer","level":3,"type":"heading"},{"inlineContent":[{"type":"text","text":"We considered using "},{"type":"codeVoice","code":"[UInt8]"},{"text":" instead of ","type":"text"},{"type":"codeVoice","code":"ByteBuffer"},{"text":" in the base ","type":"text"},{"type":"codeVoice","code":"LambdaHandler"},{"text":" API. We decided to use ","type":"text"},{"type":"codeVoice","code":"ByteBuffer"},{"text":" ","type":"text"},{"text":"for two reasons.","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"99% of use-cases will use the JSON codable API and will not directly get in touch with ByteBuffer anyway. For those"},{"text":" ","type":"text"},{"type":"text","text":"users it does not matter if the base API uses "},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":" or "},{"code":"[UInt8]","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"The incoming and outgoing data must be in the "},{"type":"codeVoice","code":"ByteBuffer"},{"text":" format anyway, as Lambda uses SwiftNIO under the hood and","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"SwiftNIO uses "},{"type":"codeVoice","code":"ByteBuffer"},{"text":" in its APIs. By using ","type":"text"},{"code":"ByteBuffer","type":"codeVoice"},{"type":"text","text":" we can save a copies to and from "},{"code":"[UInt8]","type":"codeVoice"},{"text":". This will","type":"text"},{"text":" ","type":"text"},{"text":"reduce the invocation time for all users.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The base "},{"type":"codeVoice","code":"LambdaHandler"},{"type":"text","text":" API is most likely mainly being used by developers that want to integrate their web"},{"type":"text","text":" "},{"type":"text","text":"framework with Lambda (examples: Vapor, Hummingbird, …). Those developers will most likely prefer to get the data"},{"type":"text","text":" "},{"type":"text","text":"in the "},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":" format anyway, as their lower level networking stack also depends on SwiftNIO."}]}]}],"type":"orderedList"},{"anchor":"Users-create-a-LambdaResponse-that-supports-streaming-instead-of-being-passed-a-LambdaResponseStreamWriter","type":"heading","text":"Users create a LambdaResponse, that supports streaming instead of being passed a LambdaResponseStreamWriter","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"Instead of passing the "},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"text":" in the invocation we considered a new type ","type":"text"},{"type":"codeVoice","code":"LambdaResponse"},{"type":"text","text":", that"},{"type":"text","text":" "},{"type":"text","text":"users must return in the "},{"type":"codeVoice","code":"StreamingLambdaHandler"},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Its API would look like this:"}]},{"syntax":"swift","code":["\/\/\/ A response returned from a ``LambdaHandler``.","\/\/\/ The response can be empty, a single ByteBuffer or a response stream.","public struct LambdaResponse {","    \/\/\/ A writer to be used when creating a streamed response.","    public struct Writer {","        \/\/\/ Writes data to the response stream","        public func write(_ byteBuffer: ByteBuffer) async throws","        \/\/\/ Closes off the response stream","        public func finish() async throws","        \/\/\/ Writes the `byteBuffer` to the response stream and subsequently closes the stream","        public func writeAndFinish(_ byteBuffer: ByteBuffer) async throws","    }","","    \/\/\/ Creates an empty lambda response","    public init()","","    \/\/\/ Creates a LambdaResponse with a fixed ByteBuffer.","    public init(_ byteBuffer: ByteBuffer)","","    \/\/\/ Creates a streamed lambda response. Use the ``Writer`` to send","    \/\/\/ response chunks on the stream.","    public init(_ stream: @escaping sending (Writer) async throws -> ())","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"StreamingLambdaHandler"},{"text":" would look like this:","type":"text"}]},{"code":["\/\/\/ The base LambdaHandler protocol","public protocol StreamingLambdaHandler {","    \/\/\/ The business logic of the Lambda function","    \/\/\/ - Parameters:","    \/\/\/   - event: The invocation's input data","    \/\/\/   - context: The LambdaContext containing the invocation's metadata","    \/\/\/ - Returns: A LambdaResponse, that can be streamed","    mutating func handle(","        _ event: ByteBuffer,","        context: LambdaContext","    ) async throws -> LambdaResponse","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"There are pros and cons for the API that returns the "},{"type":"codeVoice","code":"LambdaResponses"},{"type":"text","text":" and there are pros and cons for the API that"},{"text":" ","type":"text"},{"text":"receives a ","type":"text"},{"code":"LambdaResponseStreamWriter","type":"codeVoice"},{"type":"text","text":" as a parameter."}]},{"inlineContent":[{"text":"Concerning following structured concurrency principles the approach that receives a ","type":"text"},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"type":"text","text":" as a"},{"text":" ","type":"text"},{"type":"text","text":"parameter has benefits as the lifetime of the handle function is tied to the invocation runtime. The approach that"},{"type":"text","text":" "},{"type":"text","text":"returns a "},{"code":"LambdaResponse","type":"codeVoice"},{"text":" splits the invocation into two separate function calls. First the handle method is invoked,","type":"text"},{"type":"text","text":" "},{"text":"second the ","type":"text"},{"code":"LambdaResponse","type":"codeVoice"},{"text":" writer closure is invoked. This means that it is impossible to use Swift APIs that use","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"with"},{"text":" style lifecycle management patterns from before creating the response until sending the full response stream off.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"For example, users instrumenting their lambdas with Swift tracing likely can not use the "},{"type":"codeVoice","code":"withSpan"},{"type":"text","text":" API for the full"},{"type":"text","text":" "},{"type":"text","text":"lifetime of the request, if they return a streamed response."}],"type":"paragraph"},{"inlineContent":[{"text":"However, if it comes to consistency with the larger Swift on server ecosystem, the API that returns a ","type":"text"},{"type":"codeVoice","code":"LambdaResponse"},{"text":" ","type":"text"},{"type":"text","text":"is likely the better choice. Hummingbird v2, OpenAPI and the new Swift gRPC v2 implementation all use this approach."},{"type":"text","text":" "},{"type":"text","text":"This might be due to the fact that writing middleware becomes easier, if a Response is explicitly returned."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"We decided to implement the approach in which a "},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"text":" is passed to the function, since the","type":"text"},{"type":"text","text":" "},{"text":"approach in which a ","type":"text"},{"code":"LambdaResponse","type":"codeVoice"},{"text":" is returned can trivially be built on top of it. This is not true vice versa.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"We welcome the discussion on this topic and are open to change our minds and API here."}]},{"anchor":"Adding-a-function-addBackgroundTask-body-sending-escaping--async-%3E--in-LambdaContext","level":3,"type":"heading","text":"Adding a function `addBackgroundTask(_ body: sending @escaping () async -> ())` in `LambdaContext`"},{"inlineContent":[{"type":"text","text":"Initially we proposed an explicit "},{"code":"addBackgroundTask(_:)","type":"codeVoice"},{"type":"text","text":" function in "},{"type":"codeVoice","code":"LambdaContext"},{"text":" that users could call from their","type":"text"},{"text":" ","type":"text"},{"text":"handler object to schedule a background task to be run after the result is reported to AWS. We received feedback that","type":"text"},{"text":" ","type":"text"},{"text":"this approach for supporting background tasks does not exhibit structured concurrency, as code could still be in","type":"text"},{"text":" ","type":"text"},{"text":"execution after leaving the scope of the ","type":"text"},{"code":"handle(...)","type":"codeVoice"},{"text":" function.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"For handlers conforming to the ","type":"text"},{"code":"StreamingLambdaHandler","type":"codeVoice"},{"text":", ","type":"text"},{"code":"addBackgroundTask(_:)","type":"codeVoice"},{"text":" was anyways unnecessary as background","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"work could be executed in a structured concurrency manner within the "},{"code":"handle(...)","type":"codeVoice"},{"type":"text","text":" function after the call to"},{"text":" ","type":"text"},{"type":"codeVoice","code":"LambdaResponseStreamWriter.finish()"},{"type":"text","text":"."}]},{"inlineContent":[{"type":"text","text":"For handlers conforming to the "},{"code":"LambdaHandler","type":"codeVoice"},{"type":"text","text":" protocol, we considered extending "},{"code":"LambdaHandler","type":"codeVoice"},{"text":" with a","type":"text"},{"text":" ","type":"text"},{"code":"performPostHandleWork(...)","type":"codeVoice"},{"text":" function that will be called after the ","type":"text"},{"code":"handle","type":"codeVoice"},{"text":" function by the library. Users wishing to","type":"text"},{"type":"text","text":" "},{"type":"text","text":"add background work can override this function in their "},{"type":"codeVoice","code":"LambdaHandler"},{"text":" conforming object.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["public protocol LambdaHandler {","    associatedtype Event","    associatedtype Output","","    func handle(_ event: Event, context: LambdaContext) async throws -> Output","","    func performPostHandleWork(...) async throws -> Void","}","","extension LambdaHandler {","    \/\/ User's can override this function if they wish to perform background work","    \/\/ after returning a response from ``handle``.","    func performPostHandleWork(...) async throws -> Void {","        \/\/ nothing to do","    }","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Yet this poses difficulties when the user wishes to use any state created in the "},{"type":"codeVoice","code":"handle(...)"},{"text":" function as part of the","type":"text"},{"type":"text","text":" "},{"type":"text","text":"background work."}]},{"inlineContent":[{"text":"In general, the most common use-case for this library will be to implement simple Lambda functions that do not have","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"requirements for response streaming, nor to perform any background work after returning the output. To keep things easy"},{"text":" ","type":"text"},{"text":"for the common use-case, and with Swift’s principle of progressive disclosure of complexity in mind, we settled on three","type":"text"},{"type":"text","text":" "},{"type":"text","text":"handler protocols:"}],"type":"paragraph"},{"type":"orderedList","items":[{"content":[{"inlineContent":[{"type":"codeVoice","code":"LambdaHandler"},{"type":"text","text":": Most common use-case. JSON-in, JSON-out. Does not support background work execution. An intuitive"},{"type":"text","text":" "},{"code":"handle(event: Event, context: LambdaContext) -> Output","type":"codeVoice"},{"text":" API that is simple to understand, i.e. users are not exposed","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"to the concept of sending their response through a writer. "},{"type":"codeVoice","code":"LambdaHandler"},{"text":" can be very cleanly implemented and used","type":"text"},{"type":"text","text":" "},{"text":"with ","type":"text"},{"code":"LambdaRuntime","type":"codeVoice"},{"text":", especially with ","type":"text"},{"type":"codeVoice","code":"ClosureHandler"},{"type":"text","text":"."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"LambdaWithBackgroundProcessingHandler"},{"text":": If users wish to augment their ","type":"text"},{"code":"LambdaHandler","type":"codeVoice"},{"type":"text","text":" with the ability to run"},{"type":"text","text":" "},{"type":"text","text":"background tasks, they can easily migrate. A user simply has to:"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Change the conformance to "},{"code":"LambdaWithBackgroundProcessingHandler","type":"codeVoice"},{"type":"text","text":"."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Add an additional ","type":"text"},{"code":"outputWriter: some LambdaResponseWriter<Output>","type":"codeVoice"},{"text":" argument to the ","type":"text"},{"type":"codeVoice","code":"handle"},{"text":" function.","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Replace the "},{"code":"return ...","type":"codeVoice"},{"type":"text","text":" with "},{"code":"outputWriter.write(...)","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Implement any background work after ","type":"text"},{"type":"codeVoice","code":"outputWriter.write(...)"},{"type":"text","text":"."}],"type":"paragraph"}]}],"type":"orderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"StreamingLambdaHandler"},{"type":"text","text":": This is the base handler protocol which is intended to be used directly only for advanced"},{"type":"text","text":" "},{"text":"use-cases. Users are provided the invocation event as a ","type":"text"},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":" and a "},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"type":"text","text":" where the"},{"type":"text","text":" "},{"type":"text","text":"computed result (as "},{"type":"codeVoice","code":"ByteBuffer"},{"text":") can either be streamed (with repeated calls to ","type":"text"},{"type":"codeVoice","code":"write(_:)"},{"type":"text","text":") or sent all at once"},{"type":"text","text":" "},{"type":"text","text":"(with a single call to "},{"code":"writeAndFinish(_:)","type":"codeVoice"},{"text":"). After closing the ","type":"text"},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"text":", any background work can","type":"text"},{"type":"text","text":" "},{"text":"be implemented.","type":"text"}]}]}]},{"text":"Making LambdaResponseStreamWriter and LambdaResponseWriter ~Copyable","anchor":"Making-LambdaResponseStreamWriter-and-LambdaResponseWriter-~Copyable","type":"heading","level":3},{"type":"paragraph","inlineContent":[{"text":"We initially proposed to make the ","type":"text"},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"type":"text","text":" and "},{"type":"codeVoice","code":"LambdaResponseWriter"},{"type":"text","text":" protocols "},{"type":"codeVoice","code":"~Copyable"},{"type":"text","text":", with"},{"type":"text","text":" "},{"type":"text","text":"the functions that close the response having the "},{"code":"consuming","type":"codeVoice"},{"type":"text","text":" ownership keyword. This was so that the compiler could"},{"text":" ","type":"text"},{"type":"text","text":"enforce the restriction of not being able to interact with the writer after the response stream has closed."}]},{"inlineContent":[{"type":"text","text":"However, non-copyable types do not compose nicely and add complexity for users. Further, for the compiler to actually"},{"type":"text","text":" "},{"type":"text","text":"enforce the "},{"type":"codeVoice","code":"consuming"},{"text":" restrictions, user’s have to explicitly mark the writer argument as ","type":"text"},{"code":"consuming","type":"codeVoice"},{"type":"text","text":" in the "},{"type":"codeVoice","code":"handle"},{"text":" ","type":"text"},{"type":"text","text":"function."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"Therefore, throwing appropriate errors to prevent abnormal interaction with the writers seems to be the simplest","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"approach."}]},{"type":"heading","anchor":"A-word-about-versioning","level":2,"text":"A word about versioning"},{"type":"paragraph","inlineContent":[{"type":"text","text":"We are aware that AWS Lambda Runtime has not reached a proper 1.0. We intend to keep the current implementation around"},{"text":" ","type":"text"},{"type":"text","text":"at 1.0-alpha. We don’t want to change the current API without releasing a new major. We think there are lots of adopters"},{"type":"text","text":" "},{"type":"text","text":"out there that depend on the API in v1. Because of this we intend to release the proposed API here as AWS Lambda Runtime"},{"text":" ","type":"text"},{"type":"text","text":"v2."}]}],"kind":"content"}],"references":{"https://aws.amazon.com/blogs/compute/introducing-aws-lambda-response-streaming/":{"titleInlineContent":[{"type":"text","text":"AWS introduced support for response streaming"}],"type":"link","identifier":"https:\/\/aws.amazon.com\/blogs\/compute\/introducing-aws-lambda-response-streaming\/","title":"AWS introduced support for response streaming","url":"https:\/\/aws.amazon.com\/blogs\/compute\/introducing-aws-lambda-response-streaming\/"},"https://docs.aws.amazon.com/lambda/latest/dg/runtimes-custom.html":{"titleInlineContent":[{"type":"text","text":"Building a custom runtime for AWS Lambda"}],"type":"link","identifier":"https:\/\/docs.aws.amazon.com\/lambda\/latest\/dg\/runtimes-custom.html","title":"Building a custom runtime for AWS Lambda","url":"https:\/\/docs.aws.amazon.com\/lambda\/latest\/dg\/runtimes-custom.html"},"https://docs.aws.amazon.com/lambda/latest/dg/runtimes-api.html#runtimes-api-initerror":{"titleInlineContent":[{"type":"text","text":"errors that occur during initialization to the dedicated endpoint AWS exposes"}],"type":"link","identifier":"https:\/\/docs.aws.amazon.com\/lambda\/latest\/dg\/runtimes-api.html#runtimes-api-initerror","title":"errors that occur during initialization to the dedicated endpoint AWS exposes","url":"https:\/\/docs.aws.amazon.com\/lambda\/latest\/dg\/runtimes-api.html#runtimes-api-initerror"},"doc://AWSLambdaRuntimeCore/documentation/AWSLambdaRuntimeCore":{"kind":"symbol","role":"collection","identifier":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore","title":"AWSLambdaRuntimeCore","url":"\/documentation\/awslambdaruntimecore","abstract":[{"type":"text","text":"An AWS Lambda runtime for the Swift programming language"}],"type":"topic"},"https://aws.amazon.com/blogs/compute/running-code-after-returning-a-response-from-an-aws-lambda-function/":{"titleInlineContent":[{"type":"text","text":"AWS described in a blog post that you can run background tasks in Lambda"}],"type":"link","identifier":"https:\/\/aws.amazon.com\/blogs\/compute\/running-code-after-returning-a-response-from-an-aws-lambda-function\/","title":"AWS described in a blog post that you can run background tasks in Lambda","url":"https:\/\/aws.amazon.com\/blogs\/compute\/running-code-after-returning-a-response-from-an-aws-lambda-function\/"},"https://github.com/swift-server/swift-aws-lambda-runtime/issues/265":{"titleInlineContent":[{"type":"text","text":"set up global properties before the Lambda starts-up"}],"type":"link","identifier":"https:\/\/github.com\/swift-server\/swift-aws-lambda-runtime\/issues\/265","title":"set up global properties before the Lambda starts-up","url":"https:\/\/github.com\/swift-server\/swift-aws-lambda-runtime\/issues\/265"}}}