{"hierarchy":{"paths":[["doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore"]]},"metadata":{"title":"v2 API proposal for swift-aws-lambda-runtime","role":"article","roleHeading":"Article","modules":[{"name":"AWSLambdaRuntimeCore"}]},"primaryContentSections":[{"content":[{"anchor":"Overview","type":"heading","level":2,"text":"Overview"},{"type":"paragraph","inlineContent":[{"text":"Versions:","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"v1 (2024-08-07): Initial version","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"v1.1:"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Remove the "},{"type":"codeVoice","code":"reportError(_:)"},{"text":" method from ","type":"text"},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"type":"text","text":" and instead make the "},{"code":"handle(...)","type":"codeVoice"},{"type":"text","text":" method of"},{"type":"text","text":" "},{"code":"StreamingLambdaHandler","type":"codeVoice"},{"type":"text","text":" throwing."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Remove the ","type":"text"},{"type":"codeVoice","code":"addBackgroundTask(_:)"},{"type":"text","text":" method from "},{"type":"codeVoice","code":"LambdaContext"},{"text":" due to structured concurrency concerns and introduce","type":"text"},{"type":"text","text":" "},{"text":"the ","type":"text"},{"type":"codeVoice","code":"LambdaWithBackgroundProcessingHandler"},{"text":" protocol as a solution.","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Introduce "},{"code":"LambdaHandlerAdapter","type":"codeVoice"},{"type":"text","text":", which adapts handlers conforming to "},{"code":"LambdaHandler","type":"codeVoice"},{"type":"text","text":" with"},{"type":"text","text":" "},{"type":"codeVoice","code":"LambdaWithBackgroundProcessingHandler"},{"text":".","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Update "},{"type":"codeVoice","code":"LambdaCodableAdapter"},{"text":" to now be generic over any handler conforming to","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"LambdaWithBackgroundProcessingHandler"},{"type":"text","text":" instead of "},{"code":"LambdaHandler","type":"codeVoice"},{"text":".","type":"text"}]}]}]}]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"v1.2:"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Remove ","type":"text"},{"type":"codeVoice","code":"~Copyable"},{"type":"text","text":" from "},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"LambdaResponseWriter"},{"text":". Instead throw an error when","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"finish()"},{"text":" is called multiple times or when ","type":"text"},{"type":"codeVoice","code":"write"},{"text":"\/","type":"text"},{"type":"codeVoice","code":"writeAndFinish"},{"text":" is called after ","type":"text"},{"code":"finish()","type":"codeVoice"},{"type":"text","text":"."}]}]}],"type":"unorderedList"}]}]},{"type":"heading","level":2,"text":"Motivation","anchor":"Motivation"},{"text":"Current Limitations","level":3,"anchor":"Current-Limitations","type":"heading"},{"text":"EventLoop interfaces","level":4,"anchor":"EventLoop-interfaces","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"The current API extensively uses the ","type":"text"},{"code":"EventLoop","type":"codeVoice"},{"text":" family of interfaces from SwiftNIO in many areas. To use these","type":"text"},{"type":"text","text":" "},{"type":"text","text":"interfaces correctly though, it requires developers to exercise great care and understand the various transform methods"},{"type":"text","text":" "},{"text":"that are used to work with ","type":"text"},{"type":"codeVoice","code":"EventLoop"},{"text":"s and ","type":"text"},{"type":"codeVoice","code":"EventLoopFuture"},{"type":"text","text":"s. This results in a lot of cognitive complexity and makes"},{"text":" ","type":"text"},{"type":"text","text":"the code in the current API hard to reason about and maintain. For these reasons, the overarching trend in the Swift on"},{"type":"text","text":" "},{"type":"text","text":"Server ecosystem is to shift to newer, more readable, Swift concurrency constructs and de-couple from SwiftNIO’s"},{"text":" ","type":"text"},{"type":"codeVoice","code":"EventLoop"},{"type":"text","text":" interfaces."}]},{"level":4,"type":"heading","anchor":"No-ownership-of-the-main-function","text":"No ownership of the main() function"},{"type":"paragraph","inlineContent":[{"text":"A Lambda function can currently be implemented through conformance to the various handler protocols defined in","type":"text"},{"type":"text","text":" "},{"code":"AWSLambdaRuntimeCore\/LambdaHandler","type":"codeVoice"},{"text":". Each of these protocols have an extension which implements a ","type":"text"},{"type":"codeVoice","code":"static func main()"},{"type":"text","text":"."},{"text":" ","type":"text"},{"type":"text","text":"This allows users to annotate their "},{"type":"codeVoice","code":"LambdaHandler"},{"text":" conforming object with ","type":"text"},{"type":"codeVoice","code":"@main"},{"text":". The ","type":"text"},{"type":"codeVoice","code":"static func main()"},{"text":" calls the","type":"text"},{"type":"text","text":" "},{"text":"internal ","type":"text"},{"type":"codeVoice","code":"Lambda.run()"},{"text":" function, which starts the Lambda function. Since the ","type":"text"},{"code":"Lambda.run()","type":"codeVoice"},{"text":" method is internal, users","type":"text"},{"type":"text","text":" "},{"type":"text","text":"cannot override the default implementation. This has proven challenging for users who want to"},{"text":" ","type":"text"},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/swift-server\/swift-aws-lambda-runtime\/issues\/265"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Setting up global properties is required to customize the Swift Logging, Metric and Tracing backend."}]},{"text":"Non-trivial transition from SimpleLambdaHandler to LambdaHandler","type":"heading","level":4,"anchor":"Non-trivial-transition-from-SimpleLambdaHandler-to-LambdaHandler"},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"SimpleLambdaHandler"},{"type":"text","text":" protocol provides a quick and easy way to implement a basic Lambda function. It only requires"},{"text":" ","type":"text"},{"text":"an implementation of the ","type":"text"},{"type":"codeVoice","code":"handle"},{"text":" function where the business logic of the Lambda function can be written.","type":"text"},{"text":" ","type":"text"},{"code":"SimpleLambdaHandler","type":"codeVoice"},{"type":"text","text":" is perfectly sufficient for small use-cases as the user does not need to spend much time looking"},{"text":" ","type":"text"},{"text":"into the library.","type":"text"}]},{"inlineContent":[{"type":"text","text":"However, "},{"type":"codeVoice","code":"SimpleLambdaHandler"},{"type":"text","text":" cannot be used when services such as a database client need to be initialized before the"},{"type":"text","text":" "},{"type":"text","text":"Lambda runtime starts and then also gracefully shutdown prior to the runtime terminating. This is because the only way"},{"type":"text","text":" "},{"type":"text","text":"to register termination logic is through the "},{"type":"codeVoice","code":"LambdaInitializationContext"},{"type":"text","text":" (containing a field"},{"type":"text","text":" "},{"type":"codeVoice","code":"terminator: LambdaTerminator"},{"type":"text","text":") which is created and used "},{"inlineContent":[{"text":"internally","type":"text"}],"type":"emphasis"},{"text":" within ","type":"text"},{"code":"LambdaRuntime","type":"codeVoice"},{"text":" and never exposed through","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"SimpleLambdaHandler"},{"type":"text","text":". For such use-cases, other handler protocols like "},{"type":"codeVoice","code":"LambdaHandler"},{"type":"text","text":" must be used. "},{"code":"LambdaHandler","type":"codeVoice"},{"text":" ","type":"text"},{"type":"text","text":"exposes a "},{"type":"codeVoice","code":"context"},{"text":" argument of type ","type":"text"},{"code":"LambdaInitializationContext","type":"codeVoice"},{"type":"text","text":" through its initializer. Within the initializer,"},{"type":"text","text":" "},{"type":"text","text":"required services can be initialized and their graceful shutdown logic can be registered with the"},{"text":" ","type":"text"},{"code":"context.terminator.register","type":"codeVoice"},{"type":"text","text":" function."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"Yet, ","type":"text"},{"type":"codeVoice","code":"LambdaHandler"},{"type":"text","text":" is quite cumbersome to use in such use-cases as users have to deviate from the established norms of"},{"type":"text","text":" "},{"text":"the Swift on Server ecosystem in order to cleanly manage the lifecycle of the services intended to be used. This is","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"because the convenient "},{"code":"swift-service-lifecycle","type":"codeVoice"},{"text":" v2 library — which is commonly used for cleanly managing the lifecycles","type":"text"},{"type":"text","text":" "},{"type":"text","text":"of required services and widely supported by many libraries — cannot be used in a structured concurrency manner."}]},{"level":4,"type":"heading","text":"Does not integrate well with swift-service-lifecycle in a structured concurrency manner","anchor":"Does-not-integrate-well-with-swift-service-lifecycle-in-a-structured-concurrency-manner"},{"inlineContent":[{"text":"The Lambda runtime can only be started using the ","type":"text"},{"type":"strong","inlineContent":[{"text":"internal","type":"text"}]},{"type":"text","text":" "},{"code":"Lambda.run()","type":"codeVoice"},{"text":" function. This function is called by the","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"main()"},{"type":"text","text":" function defined by the "},{"code":"LambdaHandler","type":"codeVoice"},{"type":"text","text":" protocol, preventing users from injecting initialized services into the"},{"type":"text","text":" "},{"type":"text","text":"runtime "},{"type":"emphasis","inlineContent":[{"text":"prior","type":"text"}]},{"text":" to it starting. As shown below, this forces users to use an ","type":"text"},{"type":"strong","inlineContent":[{"type":"text","text":"unstructured concurrency"}]},{"text":" approach and","type":"text"},{"type":"text","text":" "},{"text":"manually initialize services, leading to the issue of the user then perhaps forgetting to gracefully shutdown the","type":"text"},{"type":"text","text":" "},{"text":"initialized services:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["struct MyLambda: LambdaHandler {","    let pgClient: PostgresClient","","    init(context: AWSLambdaRuntimeCore.LambdaInitializationContext) async throws {","        \/\/\/ Instantiate service","        let client = PostgresClient(configuration: ...)","","        \/\/\/ Unstructured concurrency to initialize the service","        let pgTask = Task {","            await client.run()","        }","","        \/\/\/ Store the client in `self` so that it can be used in `handle(...)`","        self.pgClient = client","","        \/\/\/ !!! Must remember to explicitly register termination logic for PostgresClient !!!","        context.terminator.register(","           name: \"PostgreSQL Client\",","           handler: { eventLoop in","               pgTask.cancel()","               return eventLoop.makeFutureWithTask {","                  await pgTask.value","               }","           }","        )","    }","","    func handle(_ event: Event, context: LambdaContext) async throws -> Output {","        \/\/\/ Use the initialized service stored in `self.pgClient`","        try await self.pgClient.query(...)","    }","}"],"type":"codeListing"},{"type":"heading","text":"Verbose Codable support","level":4,"anchor":"Verbose-Codable-support"},{"inlineContent":[{"type":"text","text":"In the current API, there are extensions and Codable wrapper classes for decoding events and encoding computed responses"},{"type":"text","text":" "},{"type":"text","text":"for "},{"type":"emphasis","inlineContent":[{"text":"each","type":"text"}]},{"type":"text","text":" different handler protocol and for both "},{"code":"String","type":"codeVoice"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"JSON"},{"text":" formats. This has resulted in a lot of","type":"text"},{"text":" ","type":"text"},{"text":"boilerplate code which can very easily be made generic and simplified in v2.","type":"text"}],"type":"paragraph"},{"anchor":"New-features","text":"New features","type":"heading","level":3},{"text":"Support response streaming","type":"heading","anchor":"Support-response-streaming","level":4},{"type":"paragraph","inlineContent":[{"text":"In April 2023","type":"text"},{"text":" ","type":"text"},{"type":"reference","isActive":true,"identifier":"https:\/\/aws.amazon.com\/blogs\/compute\/introducing-aws-lambda-response-streaming\/"},{"text":" ","type":"text"},{"text":"in Lambda. The current API does not support streaming. For v2 we want to change this.","type":"text"}]},{"type":"heading","text":"Scheduling background work","level":4,"anchor":"Scheduling-background-work"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In May"},{"text":" ","type":"text"},{"type":"reference","identifier":"https:\/\/aws.amazon.com\/blogs\/compute\/running-code-after-returning-a-response-from-an-aws-lambda-function\/","isActive":true},{"text":" ","type":"text"},{"type":"text","text":"until the runtime asks for more work from the control plane. We want to support this by adding new API that allows"},{"type":"text","text":" "},{"text":"background processing, even after the response has been returned.","type":"text"}]},{"anchor":"Proposed-Solution","level":2,"type":"heading","text":"Proposed Solution"},{"level":3,"anchor":"asyncawait-first-API","text":"async\/await-first API","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Large parts of "},{"type":"codeVoice","code":"Lambda"},{"text":", ","type":"text"},{"type":"codeVoice","code":"LambdaHandler"},{"type":"text","text":", and "},{"type":"codeVoice","code":"LambdaRuntime"},{"text":" will be re-written to use async\/await constructs in place","type":"text"},{"type":"text","text":" "},{"text":"of the ","type":"text"},{"code":"EventLoop","type":"codeVoice"},{"type":"text","text":" family of interfaces."}]},{"type":"heading","text":"Providing ownership of main() and support for swift-service-lifecycle","anchor":"Providing-ownership-of-main-and-support-for-swift-service-lifecycle","level":3},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Instead of conforming to a handler protocol, users can now create a ","type":"text"},{"type":"codeVoice","code":"LambdaRuntime"},{"text":" by passing in a handler closure.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"code":"LambdaRuntime","type":"codeVoice"},{"text":" conforms to ","type":"text"},{"code":"ServiceLifecycle.Service","type":"codeVoice"},{"text":" by implementing a ","type":"text"},{"code":"run()","type":"codeVoice"},{"text":" method that contains initialization","type":"text"},{"text":" ","type":"text"},{"text":"and graceful shutdown logic.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"This allows the lifecycle of the "},{"type":"codeVoice","code":"LambdaRuntime"},{"text":" to be managed with ","type":"text"},{"type":"codeVoice","code":"swift-service-lifecycle"},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"alongside"}]},{"type":"text","text":" and in the"},{"text":" ","type":"text"},{"type":"text","text":"same way the lifecycles of the required services are managed, e.g."},{"type":"text","text":" "},{"type":"codeVoice","code":"try await ServiceGroup(services: [postgresClient, ..., lambdaRuntime], ...).run()"},{"text":".","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Dependencies can now be injected into ","type":"text"},{"type":"codeVoice","code":"LambdaRuntime"},{"text":". With ","type":"text"},{"code":"swift-service-lifecycle","type":"codeVoice"},{"type":"text","text":", services will be initialized"},{"text":" ","type":"text"},{"text":"together with ","type":"text"},{"code":"LambdaRuntime","type":"codeVoice"},{"type":"text","text":"."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"The required services can then be used within the handler in a structured concurrency manner.","type":"text"},{"text":" ","type":"text"},{"type":"codeVoice","code":"swift-service-lifecycle"},{"type":"text","text":" takes care of listening for termination signals and terminating the services as well as the"},{"text":" ","type":"text"},{"type":"codeVoice","code":"LambdaRuntime"},{"type":"text","text":" in correct order."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"code":"LambdaTerminator","type":"codeVoice"},{"type":"text","text":" can now be eliminated because its role is replaced with "},{"type":"codeVoice","code":"swift-service-lifecycle"},{"type":"text","text":". The termination"},{"text":" ","type":"text"},{"type":"text","text":"logic of the Lambda function will be implemented in the conforming "},{"code":"run()","type":"codeVoice"},{"type":"text","text":" function of "},{"code":"LambdaRuntime","type":"codeVoice"},{"text":".","type":"text"}]}]}]},{"inlineContent":[{"type":"text","text":"With this, the earlier code snippet can be replaced with something much easier to read, maintain, and debug:"}],"type":"paragraph"},{"code":["\/\/\/ Instantiate services","let postgresClient = PostgresClient()","","\/\/\/ Instantiate LambdaRuntime with a closure handler implementing the business logic of the Lambda function","let runtime = LambdaRuntime { (event: Input, context: LambdaContext) in","    \/\/\/ Use initialized service within the handler","    try await postgresClient.query(...)","}","","\/\/\/ Use ServiceLifecycle to manage the initialization and termination","\/\/\/ of the services as well as the LambdaRuntime","let serviceGroup = ServiceGroup(","    services: [postgresClient, runtime],","    configuration: .init(gracefulShutdownSignals: [.sigterm]),","    logger: logger",")","try await serviceGroup.run()"],"syntax":"swift","type":"codeListing"},{"level":3,"anchor":"Simplifying-Codable-support","text":"Simplifying Codable support","type":"heading"},{"inlineContent":[{"text":"A detailed explanation is provided in the ","type":"text"},{"type":"strong","inlineContent":[{"type":"text","text":"Codable Support"}]},{"type":"text","text":" section. In short, much of the boilerplate code defined"},{"type":"text","text":" "},{"type":"text","text":"for each handler protocol in "},{"type":"codeVoice","code":"Lambda+Codable"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Lambda+String"},{"type":"text","text":" will be replaced with a single "},{"code":"LambdaCodableAdapter","type":"codeVoice"},{"type":"text","text":" "},{"text":"struct.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"This adapter struct is generic over (1) any handler conforming to a new handler protocol","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"LambdaWithBackgroundProcessingHandler"},{"type":"text","text":", (2) the user-specified input and output types, and (3) any decoder and encoder"},{"text":" ","type":"text"},{"type":"text","text":"conforming to protocols "},{"code":"LambdaEventDecoder","type":"codeVoice"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"LambdaOutputDecoder"},{"type":"text","text":". The adapter will wrap the underlying handler"},{"type":"text","text":" "},{"type":"text","text":"with encoding\/decoding logic."}]},{"text":"Detailed Solution","level":2,"type":"heading","anchor":"Detailed-Solution"},{"inlineContent":[{"text":"Below are explanations for all types that we want to use in AWS Lambda Runtime v2.","type":"text"}],"type":"paragraph"},{"level":3,"text":"LambdaResponseStreamWriter","type":"heading","anchor":"LambdaResponseStreamWriter"},{"type":"paragraph","inlineContent":[{"type":"text","text":"We will introduce a new "},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"type":"text","text":" protocol. It is used in the new "},{"type":"codeVoice","code":"StreamingLambdaHandler"},{"type":"text","text":" (defined"},{"type":"text","text":" "},{"text":"below), which is the new base protocol for the ","type":"text"},{"code":"LambdaRuntime","type":"codeVoice"},{"type":"text","text":" (defined below as well)."}]},{"syntax":"swift","code":["\/\/\/ A writer object to write the Lambda response stream into","public protocol LambdaResponseStreamWriter {","    \/\/\/ Write a response part into the stream. The HTTP response is started lazily before the first call to `write(_:)`.","    \/\/\/ Bytes written to the writer are streamed continually.","    func write(_ buffer: ByteBuffer) async throws","    \/\/\/ End the response stream and the underlying HTTP response.","    func finish() async throws","    \/\/\/ Write a response part into the stream and end the response stream as well as the underlying HTTP response.","    func writeAndFinish(_ buffer: ByteBuffer) async throws","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"If the user does not call ","type":"text"},{"type":"codeVoice","code":"finish()"},{"text":", the library will automatically finish the stream after the last ","type":"text"},{"type":"codeVoice","code":"write"},{"text":".","type":"text"},{"text":" ","type":"text"},{"text":"Appropriate errors will be thrown if ","type":"text"},{"code":"finish()","type":"codeVoice"},{"text":" is called multiple times, or if ","type":"text"},{"type":"codeVoice","code":"write"},{"type":"text","text":"\/"},{"type":"codeVoice","code":"writeAndFinish"},{"type":"text","text":" is called after"},{"type":"text","text":" "},{"type":"codeVoice","code":"finish()"},{"type":"text","text":"."}]},{"level":3,"text":"LambdaContext","type":"heading","anchor":"LambdaContext"},{"type":"paragraph","inlineContent":[{"code":"LambdaContext","type":"codeVoice"},{"type":"text","text":" will be largely unchanged, but the "},{"code":"eventLoop","type":"codeVoice"},{"text":" property will be removed. The ","type":"text"},{"type":"codeVoice","code":"allocator"},{"type":"text","text":" property of"},{"text":" ","type":"text"},{"type":"text","text":"type "},{"type":"codeVoice","code":"ByteBufferAllocator"},{"type":"text","text":" will also be removed because (1), we generally want to reduce the number of SwiftNIO types"},{"type":"text","text":" "},{"type":"text","text":"exposed in the API, and (2), "},{"type":"codeVoice","code":"ByteBufferAllocator"},{"type":"text","text":" does not optimize the allocation strategies. The common pattern"},{"text":" ","type":"text"},{"type":"text","text":"observed across many libraries is to re-use existing "},{"code":"ByteBuffer","type":"codeVoice"},{"type":"text","text":"s as much as possible. This is also what we do for the"},{"type":"text","text":" "},{"type":"codeVoice","code":"LambdaCodableAdapter"},{"type":"text","text":" (explained in the "},{"type":"strong","inlineContent":[{"text":"Codable Support","type":"text"}]},{"text":" section) implementation.","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["\/\/\/ A context object passed as part of an invocation in LambdaHandler handle functions.","public struct LambdaContext: Sendable {","    \/\/\/ The request ID, which identifies the request that triggered the function invocation.","    public var requestID: String { get }","","    \/\/\/ The AWS X-Ray tracing header.","    public var traceID: String { get }","","    \/\/\/ The ARN of the Lambda function, version, or alias that's specified in the invocation.","    public var invokedFunctionARN: String { get }","","    \/\/\/ The timestamp that the function times out.","    public var deadline: DispatchWallTime { get }","","    \/\/\/ For invocations from the AWS Mobile SDK, data about the Amazon Cognito identity provider.","    public var cognitoIdentity: String? { get }","","    \/\/\/ For invocations from the AWS Mobile SDK, data about the client application and device.","    public var clientContext: String? { get }","","    \/\/\/ `Logger` to log with.","    \/\/\/","    \/\/\/ - note: The `LogLevel` can be configured using the `LOG_LEVEL` environment variable.","    public var logger: Logger { get }","}"]},{"type":"heading","anchor":"Handlers","text":"Handlers","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"We introduce three handler protocols: "},{"type":"codeVoice","code":"StreamingLambdaHandler"},{"type":"text","text":", "},{"type":"codeVoice","code":"LambdaHandler"},{"type":"text","text":", and"},{"type":"text","text":" "},{"code":"LambdaWithBackgroundProcessingHandler","type":"codeVoice"},{"text":".","type":"text"}]},{"text":"StreamingLambdaHandler","level":4,"anchor":"StreamingLambdaHandler","type":"heading"},{"inlineContent":[{"text":"The new ","type":"text"},{"code":"StreamingLambdaHandler","type":"codeVoice"},{"text":" protocol is the base protocol to implement a Lambda function. Most users will not use","type":"text"},{"type":"text","text":" "},{"type":"text","text":"this protocol and instead use the "},{"type":"codeVoice","code":"LambdaHandler"},{"text":" protocol defined below.","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["\/\/\/ The base StreamingLambdaHandler protocol","public protocol StreamingLambdaHandler {","    \/\/\/ The business logic of the Lambda function","    \/\/\/ - Parameters:","    \/\/\/   - event: The invocation's input data","    \/\/\/   - responseWriter: A ``LambdaResponseStreamWriter`` to write the invocation's response to.","    \/\/\/                     If no response or error is written to the `responseWriter` it will","    \/\/\/                     report an error to the invoker.","    \/\/\/   - context: The LambdaContext containing the invocation's metadata","    \/\/\/ - Throws:","    \/\/\/ How the thrown error will be handled by the runtime:","    \/\/\/   - An invocation error will be reported if the error is thrown before the first call to","    \/\/\/     ``LambdaResponseStreamWriter.write(_:)``.","    \/\/\/   - If the error is thrown after call(s) to ``LambdaResponseStreamWriter.write(_:)`` but before","    \/\/\/     a call to ``LambdaResponseStreamWriter.finish()``, the response stream will be closed and trailing","    \/\/\/     headers will be sent.","    \/\/\/   - If ``LambdaResponseStreamWriter.finish()`` has already been called before the error is thrown, the","    \/\/\/     error will be logged.","    mutating func handle(_ event: ByteBuffer, responseWriter: some LambdaResponseStreamWriter, context: LambdaContext) async throws","}"],"syntax":"swift"},{"inlineContent":[{"type":"text","text":"Using this protocol requires the "},{"type":"codeVoice","code":"handle"},{"text":" method to receive the incoming event as a ","type":"text"},{"type":"codeVoice","code":"ByteBuffer"},{"text":" and return the output","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"as a "},{"code":"ByteBuffer","type":"codeVoice"},{"text":" too.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Through the "},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"type":"text","text":", which is passed as an argument in the "},{"type":"codeVoice","code":"handle"},{"text":" function, the ","type":"text"},{"type":"strong","inlineContent":[{"type":"text","text":"response can be"},{"type":"text","text":" "},{"type":"text","text":"streamed"}]},{"type":"text","text":" by calling the "},{"type":"codeVoice","code":"write(_:)"},{"type":"text","text":" function of the "},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"type":"text","text":" with partial data repeatedly before"},{"text":" ","type":"text"},{"text":"finally closing the response stream by calling ","type":"text"},{"type":"codeVoice","code":"finish()"},{"type":"text","text":". Users can also choose to return the entire output and not"},{"text":" ","type":"text"},{"type":"text","text":"stream the response by calling "},{"code":"writeAndFinish(_:)","type":"codeVoice"},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"This protocol also allows for background tasks to be run after a result has been reported to the AWS Lambda control","type":"text"},{"type":"text","text":" "},{"type":"text","text":"plane, since the "},{"type":"codeVoice","code":"handle(...)"},{"type":"text","text":" function is free to implement any background work after the call to"},{"type":"text","text":" "},{"type":"codeVoice","code":"responseWriter.finish()"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The protocol is defined in a way that supports a broad range of use-cases. The handle method is marked as "},{"code":"mutating","type":"codeVoice"},{"type":"text","text":" to"},{"type":"text","text":" "},{"type":"text","text":"allow handlers to be implemented with a "},{"type":"codeVoice","code":"struct"},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"An implementation that sends the number 1 to 10 every 500ms could look like this:","type":"text"}]},{"code":["struct SendNumbersWithPause: StreamingLambdaHandler {","    func handle(","        _ event: ByteBuffer,","        responseWriter: some LambdaResponseStreamWriter,","        context: LambdaContext","    ) async throws {","        for i in 1...10 {","            \/\/ Send partial data","            responseWriter.write(ByteBuffer(string: #\"\\#(i)\\n\\r\"#))","            \/\/ Perform some long asynchronous work","            try await Task.sleep(for: .milliseconds(500))","        }","        \/\/ All data has been sent. Close off the response stream.","        responseWriter.finish()","    }","}"],"type":"codeListing","syntax":"swift"},{"type":"heading","level":4,"text":"LambdaHandler:","anchor":"LambdaHandler"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This handler protocol will be the go-to choice for most use-cases because it is completely agnostic to any"},{"type":"text","text":" "},{"type":"text","text":"encoding\/decoding logic – conforming objects simply have to implement the "},{"type":"codeVoice","code":"handle"},{"type":"text","text":" function where the input and return"},{"text":" ","type":"text"},{"type":"text","text":"types are Swift objects."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that the "},{"code":"handle","type":"codeVoice"},{"type":"text","text":" function does not receive a "},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"text":" as an argument. Response streaming is","type":"text"},{"text":" ","type":"text"},{"text":"not viable for ","type":"text"},{"code":"LambdaHandler","type":"codeVoice"},{"type":"text","text":" because the output has to be encoded prior to it being sent, e.g. it is not possible to"},{"type":"text","text":" "},{"type":"text","text":"encode a partial\/incomplete JSON string."}]},{"type":"codeListing","syntax":"swift","code":["public protocol LambdaHandler {","    \/\/\/ Generic input type","    \/\/\/ The body of the request sent to Lambda will be decoded into this type for the handler to consume","    associatedtype Event","    \/\/\/ Generic output type","    \/\/\/ This is the return type of the handle() function.","    associatedtype Output","","    \/\/\/ The business logic of the Lambda function. Receives a generic input type and returns a generic output type.","    \/\/\/ Agnostic to encoding\/decoding","    mutating func handle(_ event: Event, context: LambdaContext) async throws -> Output","}"]},{"anchor":"LambdaWithBackgroundProcessingHandler","text":"LambdaWithBackgroundProcessingHandler:","level":4,"type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This protocol is exactly like "},{"code":"LambdaHandler","type":"codeVoice"},{"text":", with the only difference being the added support for executing background","type":"text"},{"text":" ","type":"text"},{"text":"work after the result has been sent to the AWS Lambda control plane.","type":"text"}]},{"inlineContent":[{"type":"text","text":"This is achieved by not having a return type in the "},{"code":"handle","type":"codeVoice"},{"text":" function. The output is instead written into a","type":"text"},{"type":"text","text":" "},{"code":"LambdaResponseWriter","type":"codeVoice"},{"type":"text","text":" that is passed in as an argument, meaning that the "},{"type":"codeVoice","code":"handle"},{"text":" function is then free to implement","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"any background work after the result has been sent to the AWS Lambda control plane."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"LambdaResponseWriter"},{"text":" has different semantics to the ","type":"text"},{"code":"LambdaResponseStreamWriter","type":"codeVoice"},{"type":"text","text":". Where the "},{"code":"write(_:)","type":"codeVoice"},{"type":"text","text":" function of"},{"type":"text","text":" "},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"text":" means writing into a response stream, the ","type":"text"},{"type":"codeVoice","code":"write(_:)"},{"text":" function of ","type":"text"},{"type":"codeVoice","code":"LambdaResponseWriter"},{"text":" ","type":"text"},{"type":"text","text":"simply serves as a mechanism to return the output without explicitly returning from the "},{"code":"handle","type":"codeVoice"},{"type":"text","text":" function."}]},{"type":"codeListing","syntax":"swift","code":["public protocol LambdaResponseWriter<Output> {","    associatedtype Output","","    \/\/\/ Sends the generic Output object (representing the computed result of the handler)","    \/\/\/ to the AWS Lambda response endpoint.","    \/\/\/ An error will be thrown if this function is called more than once.","    func write(_: Output) async throws","}","","public protocol LambdaWithBackgroundProcessingHandler {","    \/\/\/ Generic input type","    \/\/\/ The body of the request sent to Lambda will be decoded into this type for the handler to consume","    associatedtype Event","    \/\/\/ Generic output type","    \/\/\/ This is the type that the handle() function will send through the ``LambdaResponseWriter``.","    associatedtype Output","","    \/\/\/ The business logic of the Lambda function. Receives a generic input type and returns a generic output type.","    \/\/\/ Agnostic to JSON encoding\/decoding","    func handle(","        _ event: Event,","        outputWriter: some LambdaResponseWriter<Output>,","        context: LambdaContext","    ) async throws","}"]},{"level":5,"text":"Example Usage:","anchor":"Example-Usage","type":"heading"},{"type":"codeListing","syntax":"swift","code":["struct BackgroundProcessingHandler: LambdaWithBackgroundProcessingHandler {","    struct Input: Decodable {","        let message: String","    }","","    struct Greeting: Encodable {","        let echoedMessage: String","    }","","    typealias Event = Input","    typealias Output = Greeting","","    func handle(","        _ event: Event,","        outputWriter: some LambdaResponseWriter<Output>,","        context: LambdaContext","    ) async throws {","        \/\/ Return result to the Lambda control plane","        try await outputWriter.write(result: Greeting(echoedMessage: event.messageToEcho))","","        \/\/ Perform some background work, e.g:","        try await Task.sleep(for: .seconds(10))","","        \/\/ Exit the function. All asynchronous work has been executed before exiting the scope of this function.","        \/\/ Follows structured concurrency principles.","        return","    }","}"]},{"anchor":"Handler-Adapters","level":4,"type":"heading","text":"Handler Adapters"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Since the "},{"type":"codeVoice","code":"StreamingLambdaHandler"},{"text":" protocol is the base protocol the ","type":"text"},{"code":"LambdaRuntime","type":"codeVoice"},{"type":"text","text":" works with, there are adapters to"},{"text":" ","type":"text"},{"type":"text","text":"make both "},{"code":"LambdaHandler","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"LambdaWithBackgroundProcessingHandler","type":"codeVoice"},{"text":" compatible with ","type":"text"},{"type":"codeVoice","code":"StreamingLambdaHandler"},{"text":".","type":"text"}]},{"type":"orderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"code":"LambdaHandlerAdapter","type":"codeVoice"},{"type":"text","text":" accepts a "},{"code":"LambdaHandler","type":"codeVoice"},{"type":"text","text":" and conforms it to "},{"type":"codeVoice","code":"LambdaWithBackgroundProcessingHandler"},{"type":"text","text":". This is"},{"text":" ","type":"text"},{"text":"achieved by taking the generic ","type":"text"},{"type":"codeVoice","code":"Output"},{"type":"text","text":" object returned from the "},{"code":"handle","type":"codeVoice"},{"text":" function of ","type":"text"},{"type":"codeVoice","code":"LambdaHandler"},{"text":" and passing it","type":"text"},{"type":"text","text":" "},{"type":"text","text":"to the "},{"code":"write(_:)","type":"codeVoice"},{"text":" function of the ","type":"text"},{"code":"LambdaResponseWriter","type":"codeVoice"},{"type":"text","text":"."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"LambdaCodableAdapter"},{"text":" accepts a ","type":"text"},{"code":"LambdaWithBackgroundProcessingHandler","type":"codeVoice"},{"text":" and conforms it to ","type":"text"},{"type":"codeVoice","code":"StreamingLambdaHandler"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"This is achieved by wrapping the "},{"type":"codeVoice","code":"LambdaResponseWriter"},{"text":" with the ","type":"text"},{"code":"LambdaResponseStreamWriter","type":"codeVoice"},{"type":"text","text":" provided by"},{"type":"text","text":" "},{"code":"StreamingLambdaHandler","type":"codeVoice"},{"type":"text","text":". A call to the "},{"type":"codeVoice","code":"write(_:)"},{"text":" function of ","type":"text"},{"code":"LambdaResponseWriter","type":"codeVoice"},{"type":"text","text":" is translated into a call to"},{"text":" ","type":"text"},{"type":"text","text":"the "},{"type":"codeVoice","code":"writeAndFinish(_:)"},{"text":" function of ","type":"text"},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"text":".","type":"text"}]}]}]},{"inlineContent":[{"type":"text","text":"Both "},{"type":"codeVoice","code":"LambdaHandlerAdapter"},{"type":"text","text":" and "},{"type":"codeVoice","code":"LambdaCodableAdapter"},{"type":"text","text":" are described in greater detail in the "},{"type":"strong","inlineContent":[{"type":"text","text":"Codable Support"}]},{"text":" ","type":"text"},{"type":"text","text":"section."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"To summarize, "},{"code":"LambdaHandler","type":"codeVoice"},{"text":" can be used with the ","type":"text"},{"code":"LambdaRuntime","type":"codeVoice"},{"type":"text","text":" by first going through "},{"type":"codeVoice","code":"LambdaHandlerAdapter"},{"type":"text","text":" and"},{"type":"text","text":" "},{"text":"then through ","type":"text"},{"code":"LambdaCodableAdapter","type":"codeVoice"},{"text":". ","type":"text"},{"code":"LambdaWithBackgroundHandler","type":"codeVoice"},{"type":"text","text":" just requires "},{"code":"LambdaCodableAdapter","type":"codeVoice"},{"type":"text","text":"."}]},{"inlineContent":[{"text":"For the common JSON-in and JSON-out use-case, there is an extension on ","type":"text"},{"type":"codeVoice","code":"LambdaRuntime"},{"text":" that abstracts away this wrapping","type":"text"},{"type":"text","text":" "},{"text":"from the user.","type":"text"}],"type":"paragraph"},{"text":"LambdaRuntime","type":"heading","level":3,"anchor":"LambdaRuntime"},{"inlineContent":[{"code":"LambdaRuntime","type":"codeVoice"},{"text":" is the class that communicates with the Lambda control plane as defined in","type":"text"},{"text":" ","type":"text"},{"identifier":"https:\/\/docs.aws.amazon.com\/lambda\/latest\/dg\/runtimes-custom.html","isActive":true,"type":"reference"},{"text":" and","type":"text"},{"type":"text","text":" "},{"text":"forward the invocations to the provided ","type":"text"},{"type":"codeVoice","code":"StreamingLambdaHandler"},{"type":"text","text":". It will conform to "},{"code":"ServiceLifecycle.Service","type":"codeVoice"},{"text":" to","type":"text"},{"type":"text","text":" "},{"type":"text","text":"provide support for "},{"type":"codeVoice","code":"swift-service-lifecycle"},{"type":"text","text":"."}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["\/\/\/ The LambdaRuntime object. This object communicates with the Lambda control plane","\/\/\/ to fetch work and report errors.","public final class LambdaRuntime<Handler>: ServiceLifecycle.Service, Sendable","    where Handler: StreamingLambdaHandler","{","","    \/\/\/ Create a LambdaRuntime by passing a handler, an eventLoop and a logger.","    \/\/\/ - Parameter handler: A ``StreamingLambdaHandler`` that will be invoked","    \/\/\/ - Parameter eventLoop: An ``EventLoop`` on which the LambdaRuntime will be","    \/\/\/                        executed. Defaults to an EventLoop from","    \/\/\/                        ``NIOSingletons.posixEventLoopGroup``.","    \/\/\/ - Parameter logger: A logger","    public init(","        handler: sending Handler,","        eventLoop: EventLoop = Lambda.defaultEventLoop,","        logger: Logger = Logger(label: \"Lambda\")","    )","","    \/\/\/ Create a LambdaRuntime by passing a ``StreamingLambdaHandler``.","    public convenience init(handler: sending Handler)","","    \/\/\/ Starts the LambdaRuntime by connecting to the Lambda control plane to ask","    \/\/\/ for events to process. If the environment variable AWS_LAMBDA_RUNTIME_API is","    \/\/\/ set, the LambdaRuntime will connect to the Lambda control plane. Otherwise","    \/\/\/ it will start a mock server that can be used for testing at port 8080","    \/\/\/ locally.","    \/\/\/ Cancel the task that runs this function to close the communication with","    \/\/\/ the Lambda control plane or close the local mock server. This function","    \/\/\/ only returns once cancelled.","    public func run() async throws","}"]},{"type":"paragraph","inlineContent":[{"text":"The current API allows for a Lambda function to be tested locally through a mock server by requiring an environment","type":"text"},{"text":" ","type":"text"},{"text":"variable named ","type":"text"},{"type":"codeVoice","code":"LOCAL_LAMBDA_SERVER_ENABLED"},{"type":"text","text":" to be set to "},{"type":"codeVoice","code":"true"},{"type":"text","text":". If this environment variable is not set, the program"},{"text":" ","type":"text"},{"text":"immediately crashes as the user will not have the ","type":"text"},{"type":"codeVoice","code":"AWS_LAMBDA_RUNTIME_API"},{"type":"text","text":" environment variable on their local machine"},{"type":"text","text":" "},{"type":"text","text":"(set automatically when deployed to AWS Lambda). However, making the user set the "},{"type":"codeVoice","code":"LOCAL_LAMBDA_SERVER_ENABLED"},{"text":" ","type":"text"},{"text":"environment variable is an unnecessary step that can be avoided. In the v2 API, the ","type":"text"},{"type":"codeVoice","code":"run()"},{"text":" function will automatically","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"start the mock server when the "},{"code":"AWS_LAMBDA_RUNTIME_API","type":"codeVoice"},{"type":"text","text":" environment variable cannot be found."}]},{"type":"heading","anchor":"Lambda","text":"Lambda","level":3},{"inlineContent":[{"type":"text","text":"We also add an enum to store a static function and a property on. We put this on the static "},{"type":"codeVoice","code":"Lambda"},{"type":"text","text":" because"},{"type":"text","text":" "},{"code":"LambdaRuntime","type":"codeVoice"},{"type":"text","text":" is generic and thus has bad ergonomics for static properties and functions."}],"type":"paragraph"},{"code":["enum Lambda {","    \/\/\/ This returns the default EventLoop that a LambdaRuntime is scheduled on.","    \/\/\/ It uses `NIOSingletons.posixEventLoopGroup.next()` under the hood.","    public static var defaultEventLoop: any EventLoop { get }","","    \/\/\/ Report a startup error to the Lambda Control Plane API","    public static func reportStartupError(any Error) async","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"Since the library now provides ownership of the ","type":"text"},{"type":"codeVoice","code":"main()"},{"text":" function and allows users to initialize services before the","type":"text"},{"type":"text","text":" "},{"code":"LambdaRuntime","type":"codeVoice"},{"type":"text","text":" is initialized, the library cannot implicitly report"},{"text":" ","type":"text"},{"type":"reference","identifier":"https:\/\/docs.aws.amazon.com\/lambda\/latest\/dg\/runtimes-api.html#runtimes-api-initerror","isActive":true},{"text":" ","type":"text"},{"type":"text","text":"like it currently does through the "},{"code":"initialize()","type":"codeVoice"},{"type":"text","text":" function of "},{"type":"codeVoice","code":"LambdaRunner"},{"type":"text","text":" which wraps the handler’s "},{"code":"init(...)","type":"codeVoice"},{"text":" and","type":"text"},{"type":"text","text":" "},{"text":"handles any errors thrown by reporting it to the dedicated AWS endpoint.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"To retain support for initialization error reporting, the "},{"type":"codeVoice","code":"Lambda.reportStartupError(any Error)"},{"text":" function gives users","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the option to manually report initialization errors in their closure handler. Although this should ideally happen"},{"text":" ","type":"text"},{"type":"text","text":"implicitly like it currently does in v1, we believe this is a small compromise in comparison to the benefits gained in"},{"type":"text","text":" "},{"type":"text","text":"now being able to cleanly manage the lifecycles of required services in a structured concurrency manner."}],"type":"paragraph"},{"type":"aside","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"inlineContent":[{"text":"Assume we want to load a secret for the Lambda function from a secret vault first. If this fails, we want to report","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"the error to the control plane:"}],"type":"paragraph"},{"code":["let secretVault = SecretVault()","","do {","   \/\/\/ !!! Error thrown: secret \"foo\" does not exist !!!","   let secret = try await secretVault.getSecret(\"foo\")","","   let runtime = LambdaRuntime { (event: Input, context: LambdaContext) in","       \/\/\/ Lambda business logic","   }","","   let serviceGroup = ServiceGroup(","       services: [postgresClient, runtime],","       configuration: .init(gracefulShutdownSignals: [.sigterm]),","       logger: logger","   )","   try await serviceGroup.run()","} catch {","   \/\/\/ Report startup error straight away to the dedicated initialization error endpoint","   try await Lambda.reportStartupError(error)","}"],"syntax":"swift","type":"codeListing"}],"name":"Use-case","style":"note"},{"level":3,"text":"Codable support","type":"heading","anchor":"Codable-support"},{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"LambdaHandler"},{"type":"text","text":" and "},{"code":"LambdaWithBackgroundProcessingHandler","type":"codeVoice"},{"text":" protocols abstract away encoding\/decoding logic from the","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"conformers as they are generic over custom "},{"code":"Event","type":"codeVoice"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Output"},{"type":"text","text":" types. We introduce two adapters "},{"type":"codeVoice","code":"LambdaHandlerAdapter"},{"type":"text","text":" "},{"type":"text","text":"and "},{"type":"codeVoice","code":"CodableLambdaAdapter"},{"text":" that implement the encoding\/decoding logic and in turn allow the respective handlers to","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"conform to "},{"type":"codeVoice","code":"StreamingLambdaHandler"},{"type":"text","text":"."}],"type":"paragraph"},{"text":"LambdaHandlerAdapter","anchor":"LambdaHandlerAdapter","type":"heading","level":4},{"inlineContent":[{"type":"text","text":"Any handler conforming to "},{"type":"codeVoice","code":"LambdaHandler"},{"type":"text","text":" can be conformed to "},{"type":"codeVoice","code":"LambdaWithBackgroundProcessingHandler"},{"text":" through","type":"text"},{"type":"text","text":" "},{"code":"LambdaHandlerAdapter","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["\/\/\/ Wraps an underlying handler conforming to ``LambdaHandler``","\/\/\/ with ``LambdaWithBackgroundProcessingHandler``.","public struct LambdaHandlerAdapter<","    Event: Decodable,","    Output,","    Handler: LambdaHandler",">: LambdaWithBackgroundProcessingHandler where Handler.Event == Event, Handler.Output == Output {","    let handler: Handler","","    \/\/\/ Register the concrete handler.","    public init(handler: Handler)","","    \/\/\/ 1. Call the `self.handler.handle(...)` with `event` and `context`.","    \/\/\/ 2. Pass the generic `Output` object returned from `self.handler.handle(...)` to `outputWriter.write(_:)`","    public func handle(_ event: Event, outputWriter: some LambdaResponseWriter<Output>, context: LambdaContext) async throws","}"]},{"anchor":"LambdaCodableAdapter","level":4,"type":"heading","text":"LambdaCodableAdapter"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"LambdaCodableAdapter"},{"type":"text","text":" accepts any generic underlying handler conforming to "},{"code":"LambdaWithBackgroundProcessingHandler","type":"codeVoice"},{"text":". It","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"also accepts "},{"type":"emphasis","inlineContent":[{"text":"any","type":"text"}]},{"type":"text","text":" encoder and decoder object conforming to the "},{"code":"LambdaEventDecoder","type":"codeVoice"},{"type":"text","text":" and "},{"code":"LambdaOutputEncoder","type":"codeVoice"},{"type":"text","text":" "},{"type":"text","text":"protocols:"}]},{"level":5,"text":"LambdaEventDecoder and LambdaOutputEncoder protocols","type":"heading","anchor":"LambdaEventDecoder-and-LambdaOutputEncoder-protocols"},{"type":"codeListing","syntax":"swift","code":["public protocol LambdaEventDecoder {","    \/\/\/ Decode the ByteBuffer representing the received event into the generic type Event","    \/\/\/ the handler will receive","    func decode<Event: Decodable>(_ type: Event.Type, from buffer: ByteBuffer) throws -> Event","}","","public protocol LambdaOutputEncoder {","    \/\/\/ Encode the generic type Output the handler has produced into a ByteBuffer","    func encode<Output: Encodable>(_ value: Output, into buffer: inout ByteBuffer) throws","}"]},{"inlineContent":[{"text":"We provide conformances for Foundation’s ","type":"text"},{"type":"codeVoice","code":"JSONDecoder"},{"type":"text","text":" to "},{"type":"codeVoice","code":"LambdaEventDecoder"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"JSONEncoder"},{"type":"text","text":" to"},{"type":"text","text":" "},{"code":"LambdaOutputEncoder","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"code":"LambdaCodableAdapter","type":"codeVoice"},{"text":" implements its ","type":"text"},{"type":"codeVoice","code":"handle()"},{"type":"text","text":" method by:"}]},{"type":"orderedList","items":[{"content":[{"inlineContent":[{"text":"Decoding the ","type":"text"},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":" event into the generic "},{"type":"codeVoice","code":"Event"},{"text":" type.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Wrapping the "},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"type":"text","text":" with a concrete "},{"code":"LambdaResponseWriter","type":"codeVoice"},{"type":"text","text":" such that calls to"},{"type":"text","text":" "},{"code":"LambdaResponseWriter","type":"codeVoice"},{"type":"text","text":"s "},{"type":"codeVoice","code":"write(_:)"},{"text":" are mapped to ","type":"text"},{"code":"LambdaResponseStreamWriter","type":"codeVoice"},{"text":"s ","type":"text"},{"code":"writeAndFinish(_:)","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Note that the argument to ","type":"text"},{"type":"codeVoice","code":"LambdaResponseWriter"},{"text":"s ","type":"text"},{"code":"write(_:)","type":"codeVoice"},{"type":"text","text":" is a generic "},{"code":"Output","type":"codeVoice"},{"type":"text","text":" object whereas"},{"type":"text","text":" "},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"type":"text","text":"s "},{"code":"writeAndFinish(_:)","type":"codeVoice"},{"type":"text","text":" requires a "},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":"."}]}]},{"content":[{"inlineContent":[{"text":"Therefore, the concrete implementation of ","type":"text"},{"code":"LambdaResponseWriter","type":"codeVoice"},{"text":" also accepts an encoder. Its ","type":"text"},{"type":"codeVoice","code":"write(_:)"},{"text":" function","type":"text"},{"type":"text","text":" "},{"text":"first encodes the generic ","type":"text"},{"code":"Output","type":"codeVoice"},{"type":"text","text":" object and then passes it to the underlying "},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"type":"text","text":"."}],"type":"paragraph"}]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Passing the generic ","type":"text"},{"code":"Event","type":"codeVoice"},{"type":"text","text":" instance, the concrete "},{"code":"LambdaResponseWriter","type":"codeVoice"},{"type":"text","text":", as well as the "},{"type":"codeVoice","code":"LambdaContext"},{"text":" to the","type":"text"},{"type":"text","text":" "},{"type":"text","text":"underlying handler’s "},{"type":"codeVoice","code":"handle()"},{"type":"text","text":" method."}]}]}]},{"type":"paragraph","inlineContent":[{"code":"LambdaCodableAdapter","type":"codeVoice"},{"type":"text","text":" can implement encoding\/decoding for "},{"inlineContent":[{"text":"any","type":"text"}],"type":"emphasis"},{"type":"text","text":" handler conforming to"},{"text":" ","type":"text"},{"code":"LambdaWithBackgroundProcessingHandler","type":"codeVoice"},{"text":" if ","type":"text"},{"type":"codeVoice","code":"Event"},{"type":"text","text":" is "},{"type":"codeVoice","code":"Decodable"},{"text":" and the ","type":"text"},{"code":"Output","type":"codeVoice"},{"text":" is ","type":"text"},{"type":"codeVoice","code":"Encodable"},{"text":" or ","type":"text"},{"type":"codeVoice","code":"Void"},{"text":", meaning","type":"text"},{"type":"text","text":" "},{"type":"text","text":"that the encoding\/decoding stubs do not need to be implemented by the user."}]},{"code":["\/\/\/ Wraps an underlying handler conforming to `LambdaWithBackgroundProcessingHandler`","\/\/\/ with encoding\/decoding logic","public struct LambdaCodableAdapter<","    Handler: LambdaWithBackgroundProcessingHandler,","    Event: Decodable,","    Output,","    Decoder: LambdaEventDecoder,","    Encoder: LambdaOutputEncoder",">: StreamingLambdaHandler where Handler.Output == Output, Handler.Event == Event {","","    \/\/\/ Register the concrete handler, encoder, and decoder.","    public init(","        handler: Handler,","        encoder: Encoder,","        decoder: Decoder","    ) where Output: Encodable","","    \/\/\/ For handler with a void output -- the user doesn't specify an encoder.","    public init(","        handler: Handler,","        decoder: Decoder","    ) where Output == Void, Encoder == VoidEncoder","","    \/\/\/ 1. Decode the invocation event using `self.decoder`","    \/\/\/ 2. Create a concrete `LambdaResponseWriter` that maps calls to `write(_:)` with the `responseWriter`s `writeAndFinish(_:)`","    \/\/\/ 2. Call the underlying `self.handler.handle()` method with the decoded event data, the concrete `LambdaResponseWriter`,","    \/\/\/ and the `LambdaContext`.","    public mutating func handle(","        _ request: ByteBuffer,","        responseWriter: some LambdaResponseStreamWriter,","        context: LambdaContext","    ) async throws","}"],"type":"codeListing","syntax":"swift"},{"level":3,"anchor":"Handler-as-a-Closure","type":"heading","text":"Handler as a Closure"},{"inlineContent":[{"type":"text","text":"To create a Lambda function using the current API, a user first has to create an object and conform it to one of the"},{"text":" ","type":"text"},{"type":"text","text":"handler protocols by implementing the initializer and the "},{"code":"handle(...)","type":"codeVoice"},{"text":" function. Now that ","type":"text"},{"code":"LambdaRuntime","type":"codeVoice"},{"text":" is public,","type":"text"},{"text":" ","type":"text"},{"text":"this verbosity can very easily be simplified.","type":"text"}],"type":"paragraph"},{"anchor":"ClosureHandler","level":4,"type":"heading","text":"ClosureHandler"},{"type":"paragraph","inlineContent":[{"text":"This handler is generic over any ","type":"text"},{"code":"Event","type":"codeVoice"},{"type":"text","text":" type conforming to "},{"code":"Decodable","type":"codeVoice"},{"type":"text","text":" and any "},{"code":"Output","type":"codeVoice"},{"text":" type conforming to ","type":"text"},{"type":"codeVoice","code":"Encodable"},{"text":" ","type":"text"},{"type":"text","text":"or "},{"type":"codeVoice","code":"Void"},{"text":".","type":"text"}]},{"type":"codeListing","code":["public struct ClosureHandler<Event, Output>: LambdaHandler {","    \/\/\/ Initialize with a closure handler over generic Input and Output types","    public init(body: @escaping (Event, LambdaContext) async throws -> Output) where Output: Encodable","    \/\/\/ Initialize with a closure handler over a generic Input type (Void Output).","    public init(body: @escaping (Event, LambdaContext) async throws -> Void) where Output == Void","    \/\/\/ The business logic of the Lambda function.","    public func handle(_ event: Event, context: LambdaContext) async throws -> Output","}"],"syntax":"swift"},{"inlineContent":[{"text":"Given that ","type":"text"},{"type":"codeVoice","code":"ClosureHandler"},{"text":" conforms to ","type":"text"},{"code":"LambdaHandler","type":"codeVoice"},{"type":"text","text":":"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"text":"We can extend the ","type":"text"},{"type":"codeVoice","code":"LambdaRuntime"},{"type":"text","text":" initializer such that it accepts a closure as an argument."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Within the initializer, the closure handler is wrapped with "},{"code":"LambdaCodableAdapter","type":"codeVoice"},{"type":"text","text":"."}]}]}],"type":"orderedList"},{"type":"codeListing","syntax":"swift","code":["extension LambdaRuntime {","    \/\/\/ Initialize a LambdaRuntime with a closure handler over generic Event and Output types.","    \/\/\/ This initializer bolts on encoding\/decoding logic by wrapping the closure handler with","    \/\/\/ LambdaCodableAdapter.","    public init<Event: Decodable, Output: Encodable>(","        body: @escaping (Event, LambdaContext) async throws -> Output","    ) where Handler == LambdaCodableAdapter<ClosureHandler<Event, Output>, Event, Output, JSONDecoder, JSONEncoder>","","    \/\/\/ Same as above but for handlers with a void output","    public init<Event: Decodable>(","        body: @escaping (Event, LambdaContext) async throws -> Void","    ) where Handler == LambdaCodableAdapter<ClosureHandler<Event, Void>, Event, Void, JSONDecoder, VoidEncoder>","}"]},{"inlineContent":[{"type":"text","text":"We can now significantly reduce the verbosity and leverage Swift’s trailing closure syntax to cleanly create and run a"},{"type":"text","text":" "},{"text":"Lambda function, abstracting away the decoding and encoding logic from the user:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["\/\/\/ The type the handler will use as input","struct Input: Decodable {","    var message: String","}","","\/\/\/ The type the handler will output","struct Greeting: Encodable {","    var echoedMessage: String","}","","\/\/\/ A simple Lambda function that echoes the input","let runtime = LambdaRuntime { (event: Input, context: LambdaContext) in","    Greeting(echoedMessage: event.message)","}","","try await runtime.run()"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"We also add a "},{"type":"codeVoice","code":"StreamingClosureHandler"},{"type":"text","text":" conforming to "},{"type":"codeVoice","code":"StreamingLambdaHandler"},{"text":" for use-cases where the user wants to","type":"text"},{"text":" ","type":"text"},{"text":"handle encoding\/decoding themselves:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["public struct StreamingClosureHandler: StreamingLambdaHandler {","","    public init(","        body: @escaping sending (ByteBuffer, LambdaResponseStreamWriter, LambdaContext) async throws -> ()","    )","","    public func handle(","        _ request: ByteBuffer,","        responseWriter: LambdaResponseStreamWriter,","        context: LambdaContext","    ) async throws","}","","extension LambdaRuntime {","    public init(","        body: @escaping sending (ByteBuffer, LambdaResponseStreamWriter, LambdaContext) async throws -> ()","    )","}"]},{"text":"Alternatives considered","type":"heading","level":2,"anchor":"Alternatives-considered"},{"level":3,"type":"heading","text":"[UInt8] instead of ByteBuffer","anchor":"UInt8-instead-of-ByteBuffer"},{"inlineContent":[{"text":"We considered using ","type":"text"},{"type":"codeVoice","code":"[UInt8]"},{"type":"text","text":" instead of "},{"code":"ByteBuffer","type":"codeVoice"},{"text":" in the base ","type":"text"},{"type":"codeVoice","code":"LambdaHandler"},{"type":"text","text":" API. We decided to use "},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":" "},{"text":"for two reasons.","type":"text"}],"type":"paragraph"},{"type":"orderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"99% of use-cases will use the JSON codable API and will not directly get in touch with ByteBuffer anyway. For those"},{"text":" ","type":"text"},{"text":"users it does not matter if the base API uses ","type":"text"},{"type":"codeVoice","code":"ByteBuffer"},{"text":" or ","type":"text"},{"type":"codeVoice","code":"[UInt8]"},{"text":".","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The incoming and outgoing data must be in the "},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":" format anyway, as Lambda uses SwiftNIO under the hood and"},{"text":" ","type":"text"},{"type":"text","text":"SwiftNIO uses "},{"code":"ByteBuffer","type":"codeVoice"},{"text":" in its APIs. By using ","type":"text"},{"code":"ByteBuffer","type":"codeVoice"},{"type":"text","text":" we can save a copies to and from "},{"code":"[UInt8]","type":"codeVoice"},{"text":". This will","type":"text"},{"type":"text","text":" "},{"text":"reduce the invocation time for all users.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"The base ","type":"text"},{"type":"codeVoice","code":"LambdaHandler"},{"type":"text","text":" API is most likely mainly being used by developers that want to integrate their web"},{"type":"text","text":" "},{"text":"framework with Lambda (examples: Vapor, Hummingbird, …). Those developers will most likely prefer to get the data","type":"text"},{"type":"text","text":" "},{"type":"text","text":"in the "},{"code":"ByteBuffer","type":"codeVoice"},{"text":" format anyway, as their lower level networking stack also depends on SwiftNIO.","type":"text"}]}]}]},{"anchor":"Users-create-a-LambdaResponse-that-supports-streaming-instead-of-being-passed-a-LambdaResponseStreamWriter","text":"Users create a LambdaResponse, that supports streaming instead of being passed a LambdaResponseStreamWriter","level":3,"type":"heading"},{"type":"paragraph","inlineContent":[{"text":"Instead of passing the ","type":"text"},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"text":" in the invocation we considered a new type ","type":"text"},{"type":"codeVoice","code":"LambdaResponse"},{"type":"text","text":", that"},{"type":"text","text":" "},{"type":"text","text":"users must return in the "},{"code":"StreamingLambdaHandler","type":"codeVoice"},{"type":"text","text":"."}]},{"inlineContent":[{"type":"text","text":"Its API would look like this:"}],"type":"paragraph"},{"type":"codeListing","code":["\/\/\/ A response returned from a ``LambdaHandler``.","\/\/\/ The response can be empty, a single ByteBuffer or a response stream.","public struct LambdaResponse {","    \/\/\/ A writer to be used when creating a streamed response.","    public struct Writer {","        \/\/\/ Writes data to the response stream","        public func write(_ byteBuffer: ByteBuffer) async throws","        \/\/\/ Closes off the response stream","        public func finish() async throws","        \/\/\/ Writes the `byteBuffer` to the response stream and subsequently closes the stream","        public func writeAndFinish(_ byteBuffer: ByteBuffer) async throws","    }","","    \/\/\/ Creates an empty lambda response","    public init()","","    \/\/\/ Creates a LambdaResponse with a fixed ByteBuffer.","    public init(_ byteBuffer: ByteBuffer)","","    \/\/\/ Creates a streamed lambda response. Use the ``Writer`` to send","    \/\/\/ response chunks on the stream.","    public init(_ stream: @escaping sending (Writer) async throws -> ())","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"code":"StreamingLambdaHandler","type":"codeVoice"},{"type":"text","text":" would look like this:"}]},{"code":["\/\/\/ The base LambdaHandler protocol","public protocol StreamingLambdaHandler {","    \/\/\/ The business logic of the Lambda function","    \/\/\/ - Parameters:","    \/\/\/   - event: The invocation's input data","    \/\/\/   - context: The LambdaContext containing the invocation's metadata","    \/\/\/ - Returns: A LambdaResponse, that can be streamed","    mutating func handle(","        _ event: ByteBuffer,","        context: LambdaContext","    ) async throws -> LambdaResponse","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"There are pros and cons for the API that returns the ","type":"text"},{"type":"codeVoice","code":"LambdaResponses"},{"text":" and there are pros and cons for the API that","type":"text"},{"type":"text","text":" "},{"type":"text","text":"receives a "},{"code":"LambdaResponseStreamWriter","type":"codeVoice"},{"text":" as a parameter.","type":"text"}]},{"inlineContent":[{"text":"Concerning following structured concurrency principles the approach that receives a ","type":"text"},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"text":" as a","type":"text"},{"type":"text","text":" "},{"type":"text","text":"parameter has benefits as the lifetime of the handle function is tied to the invocation runtime. The approach that"},{"text":" ","type":"text"},{"text":"returns a ","type":"text"},{"type":"codeVoice","code":"LambdaResponse"},{"type":"text","text":" splits the invocation into two separate function calls. First the handle method is invoked,"},{"type":"text","text":" "},{"text":"second the ","type":"text"},{"type":"codeVoice","code":"LambdaResponse"},{"text":" writer closure is invoked. This means that it is impossible to use Swift APIs that use","type":"text"},{"type":"text","text":" "},{"code":"with","type":"codeVoice"},{"type":"text","text":" style lifecycle management patterns from before creating the response until sending the full response stream off."},{"type":"text","text":" "},{"text":"For example, users instrumenting their lambdas with Swift tracing likely can not use the ","type":"text"},{"type":"codeVoice","code":"withSpan"},{"text":" API for the full","type":"text"},{"type":"text","text":" "},{"type":"text","text":"lifetime of the request, if they return a streamed response."}],"type":"paragraph"},{"inlineContent":[{"text":"However, if it comes to consistency with the larger Swift on server ecosystem, the API that returns a ","type":"text"},{"code":"LambdaResponse","type":"codeVoice"},{"text":" ","type":"text"},{"type":"text","text":"is likely the better choice. Hummingbird v2, OpenAPI and the new Swift gRPC v2 implementation all use this approach."},{"text":" ","type":"text"},{"text":"This might be due to the fact that writing middleware becomes easier, if a Response is explicitly returned.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"We decided to implement the approach in which a "},{"code":"LambdaResponseStreamWriter","type":"codeVoice"},{"text":" is passed to the function, since the","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"approach in which a "},{"code":"LambdaResponse","type":"codeVoice"},{"type":"text","text":" is returned can trivially be built on top of it. This is not true vice versa."}]},{"inlineContent":[{"type":"text","text":"We welcome the discussion on this topic and are open to change our minds and API here."}],"type":"paragraph"},{"level":3,"type":"heading","anchor":"Adding-a-function-addBackgroundTask-body-sending-escaping--async-%3E--in-LambdaContext","text":"Adding a function `addBackgroundTask(_ body: sending @escaping () async -> ())` in `LambdaContext`"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Initially we proposed an explicit "},{"code":"addBackgroundTask(_:)","type":"codeVoice"},{"type":"text","text":" function in "},{"code":"LambdaContext","type":"codeVoice"},{"type":"text","text":" that users could call from their"},{"type":"text","text":" "},{"type":"text","text":"handler object to schedule a background task to be run after the result is reported to AWS. We received feedback that"},{"type":"text","text":" "},{"type":"text","text":"this approach for supporting background tasks does not exhibit structured concurrency, as code could still be in"},{"text":" ","type":"text"},{"type":"text","text":"execution after leaving the scope of the "},{"type":"codeVoice","code":"handle(...)"},{"type":"text","text":" function."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For handlers conforming to the "},{"type":"codeVoice","code":"StreamingLambdaHandler"},{"text":", ","type":"text"},{"code":"addBackgroundTask(_:)","type":"codeVoice"},{"text":" was anyways unnecessary as background","type":"text"},{"text":" ","type":"text"},{"text":"work could be executed in a structured concurrency manner within the ","type":"text"},{"type":"codeVoice","code":"handle(...)"},{"text":" function after the call to","type":"text"},{"text":" ","type":"text"},{"code":"LambdaResponseStreamWriter.finish()","type":"codeVoice"},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For handlers conforming to the "},{"code":"LambdaHandler","type":"codeVoice"},{"type":"text","text":" protocol, we considered extending "},{"type":"codeVoice","code":"LambdaHandler"},{"type":"text","text":" with a"},{"text":" ","type":"text"},{"type":"codeVoice","code":"performPostHandleWork(...)"},{"type":"text","text":" function that will be called after the "},{"code":"handle","type":"codeVoice"},{"text":" function by the library. Users wishing to","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"add background work can override this function in their "},{"type":"codeVoice","code":"LambdaHandler"},{"type":"text","text":" conforming object."}]},{"code":["public protocol LambdaHandler {","    associatedtype Event","    associatedtype Output","","    func handle(_ event: Event, context: LambdaContext) async throws -> Output","","    func performPostHandleWork(...) async throws -> Void","}","","extension LambdaHandler {","    \/\/ User's can override this function if they wish to perform background work","    \/\/ after returning a response from ``handle``.","    func performPostHandleWork(...) async throws -> Void {","        \/\/ nothing to do","    }","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"Yet this poses difficulties when the user wishes to use any state created in the ","type":"text"},{"type":"codeVoice","code":"handle(...)"},{"type":"text","text":" function as part of the"},{"text":" ","type":"text"},{"text":"background work.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"In general, the most common use-case for this library will be to implement simple Lambda functions that do not have","type":"text"},{"type":"text","text":" "},{"text":"requirements for response streaming, nor to perform any background work after returning the output. To keep things easy","type":"text"},{"text":" ","type":"text"},{"text":"for the common use-case, and with Swift’s principle of progressive disclosure of complexity in mind, we settled on three","type":"text"},{"type":"text","text":" "},{"text":"handler protocols:","type":"text"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"LambdaHandler"},{"type":"text","text":": Most common use-case. JSON-in, JSON-out. Does not support background work execution. An intuitive"},{"type":"text","text":" "},{"code":"handle(event: Event, context: LambdaContext) -> Output","type":"codeVoice"},{"text":" API that is simple to understand, i.e. users are not exposed","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"to the concept of sending their response through a writer. "},{"code":"LambdaHandler","type":"codeVoice"},{"text":" can be very cleanly implemented and used","type":"text"},{"type":"text","text":" "},{"type":"text","text":"with "},{"code":"LambdaRuntime","type":"codeVoice"},{"text":", especially with ","type":"text"},{"code":"ClosureHandler","type":"codeVoice"},{"text":".","type":"text"}]}]},{"content":[{"inlineContent":[{"code":"LambdaWithBackgroundProcessingHandler","type":"codeVoice"},{"type":"text","text":": If users wish to augment their "},{"type":"codeVoice","code":"LambdaHandler"},{"type":"text","text":" with the ability to run"},{"type":"text","text":" "},{"type":"text","text":"background tasks, they can easily migrate. A user simply has to:"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Change the conformance to "},{"type":"codeVoice","code":"LambdaWithBackgroundProcessingHandler"},{"text":".","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Add an additional "},{"code":"outputWriter: some LambdaResponseWriter<Output>","type":"codeVoice"},{"type":"text","text":" argument to the "},{"type":"codeVoice","code":"handle"},{"type":"text","text":" function."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Replace the "},{"type":"codeVoice","code":"return ..."},{"type":"text","text":" with "},{"type":"codeVoice","code":"outputWriter.write(...)"},{"type":"text","text":"."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Implement any background work after "},{"type":"codeVoice","code":"outputWriter.write(...)"},{"text":".","type":"text"}]}]}],"type":"orderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"StreamingLambdaHandler"},{"type":"text","text":": This is the base handler protocol which is intended to be used directly only for advanced"},{"text":" ","type":"text"},{"type":"text","text":"use-cases. Users are provided the invocation event as a "},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":" and a "},{"code":"LambdaResponseStreamWriter","type":"codeVoice"},{"type":"text","text":" where the"},{"text":" ","type":"text"},{"text":"computed result (as ","type":"text"},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":") can either be streamed (with repeated calls to "},{"code":"write(_:)","type":"codeVoice"},{"text":") or sent all at once","type":"text"},{"type":"text","text":" "},{"text":"(with a single call to ","type":"text"},{"type":"codeVoice","code":"writeAndFinish(_:)"},{"text":"). After closing the ","type":"text"},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"type":"text","text":", any background work can"},{"type":"text","text":" "},{"text":"be implemented.","type":"text"}]}]}],"type":"orderedList"},{"text":"Making LambdaResponseStreamWriter and LambdaResponseWriter ~Copyable","level":3,"type":"heading","anchor":"Making-LambdaResponseStreamWriter-and-LambdaResponseWriter-~Copyable"},{"inlineContent":[{"type":"text","text":"We initially proposed to make the "},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"type":"text","text":" and "},{"type":"codeVoice","code":"LambdaResponseWriter"},{"text":" protocols ","type":"text"},{"code":"~Copyable","type":"codeVoice"},{"type":"text","text":", with"},{"text":" ","type":"text"},{"text":"the functions that close the response having the ","type":"text"},{"type":"codeVoice","code":"consuming"},{"text":" ownership keyword. This was so that the compiler could","type":"text"},{"type":"text","text":" "},{"text":"enforce the restriction of not being able to interact with the writer after the response stream has closed.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"However, non-copyable types do not compose nicely and add complexity for users. Further, for the compiler to actually"},{"text":" ","type":"text"},{"type":"text","text":"enforce the "},{"type":"codeVoice","code":"consuming"},{"text":" restrictions, user’s have to explicitly mark the writer argument as ","type":"text"},{"code":"consuming","type":"codeVoice"},{"text":" in the ","type":"text"},{"type":"codeVoice","code":"handle"},{"text":" ","type":"text"},{"type":"text","text":"function."}]},{"type":"paragraph","inlineContent":[{"text":"Therefore, throwing appropriate errors to prevent abnormal interaction with the writers seems to be the simplest","type":"text"},{"text":" ","type":"text"},{"text":"approach.","type":"text"}]},{"text":"A word about versioning","type":"heading","level":2,"anchor":"A-word-about-versioning"},{"inlineContent":[{"text":"We are aware that AWS Lambda Runtime has not reached a proper 1.0. We intend to keep the current implementation around","type":"text"},{"type":"text","text":" "},{"type":"text","text":"at 1.0-alpha. We don’t want to change the current API without releasing a new major. We think there are lots of adopters"},{"text":" ","type":"text"},{"text":"out there that depend on the API in v1. Because of this we intend to release the proposed API here as AWS Lambda Runtime","type":"text"},{"type":"text","text":" "},{"type":"text","text":"v2."}],"type":"paragraph"}],"kind":"content"}],"sections":[],"schemaVersion":{"major":0,"minor":3,"patch":0},"abstract":[{"code":"swift-aws-lambda-runtime","type":"codeVoice"},{"text":" is an important library for the Swift on Server ecosystem. The initial API was written before","type":"text"},{"type":"text","text":" "},{"text":"async\/await was introduced to Swift. When async\/await was introduced, shims were added to bridge between the underlying","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"SwiftNIO "},{"type":"codeVoice","code":"EventLoop"},{"type":"text","text":" interfaces and async\/await. However, just like "},{"type":"codeVoice","code":"gRPC-swift"},{"type":"text","text":" and "},{"code":"postgres-nio","type":"codeVoice"},{"text":", we now want to","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"shift to solely using async\/await instead of "},{"type":"codeVoice","code":"EventLoop"},{"type":"text","text":" interfaces. For this, large parts of the current API have to be"},{"type":"text","text":" "},{"type":"text","text":"reconsidered."}],"identifier":{"url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/0001-v2-api","interfaceLanguage":"swift"},"variants":[{"paths":["\/documentation\/awslambdaruntimecore\/0001-v2-api"],"traits":[{"interfaceLanguage":"swift"}]}],"kind":"article","references":{"https://docs.aws.amazon.com/lambda/latest/dg/runtimes-api.html#runtimes-api-initerror":{"type":"link","title":"errors that occur during initialization to the dedicated endpoint AWS exposes","titleInlineContent":[{"type":"text","text":"errors that occur during initialization to the dedicated endpoint AWS exposes"}],"url":"https:\/\/docs.aws.amazon.com\/lambda\/latest\/dg\/runtimes-api.html#runtimes-api-initerror","identifier":"https:\/\/docs.aws.amazon.com\/lambda\/latest\/dg\/runtimes-api.html#runtimes-api-initerror"},"https://docs.aws.amazon.com/lambda/latest/dg/runtimes-custom.html":{"type":"link","title":"Building a custom runtime for AWS Lambda","titleInlineContent":[{"type":"text","text":"Building a custom runtime for AWS Lambda"}],"url":"https:\/\/docs.aws.amazon.com\/lambda\/latest\/dg\/runtimes-custom.html","identifier":"https:\/\/docs.aws.amazon.com\/lambda\/latest\/dg\/runtimes-custom.html"},"https://aws.amazon.com/blogs/compute/introducing-aws-lambda-response-streaming/":{"type":"link","title":"AWS introduced support for response streaming","titleInlineContent":[{"type":"text","text":"AWS introduced support for response streaming"}],"url":"https:\/\/aws.amazon.com\/blogs\/compute\/introducing-aws-lambda-response-streaming\/","identifier":"https:\/\/aws.amazon.com\/blogs\/compute\/introducing-aws-lambda-response-streaming\/"},"doc://AWSLambdaRuntimeCore/documentation/AWSLambdaRuntimeCore":{"identifier":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore","title":"AWSLambdaRuntimeCore","kind":"symbol","abstract":[{"text":"An AWS Lambda runtime for the Swift programming language","type":"text"}],"role":"collection","url":"\/documentation\/awslambdaruntimecore","type":"topic"},"https://aws.amazon.com/blogs/compute/running-code-after-returning-a-response-from-an-aws-lambda-function/":{"type":"link","title":"AWS described in a blog post that you can run background tasks in Lambda","titleInlineContent":[{"type":"text","text":"AWS described in a blog post that you can run background tasks in Lambda"}],"url":"https:\/\/aws.amazon.com\/blogs\/compute\/running-code-after-returning-a-response-from-an-aws-lambda-function\/","identifier":"https:\/\/aws.amazon.com\/blogs\/compute\/running-code-after-returning-a-response-from-an-aws-lambda-function\/"},"https://github.com/swift-server/swift-aws-lambda-runtime/issues/265":{"type":"link","title":"set up global properties before the Lambda starts-up","titleInlineContent":[{"type":"text","text":"set up global properties before the Lambda starts-up"}],"url":"https:\/\/github.com\/swift-server\/swift-aws-lambda-runtime\/issues\/265","identifier":"https:\/\/github.com\/swift-server\/swift-aws-lambda-runtime\/issues\/265"}}}