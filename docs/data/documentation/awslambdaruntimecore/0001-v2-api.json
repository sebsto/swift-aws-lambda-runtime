{"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/0001-v2-api"},"variants":[{"paths":["\/documentation\/awslambdaruntimecore\/0001-v2-api"],"traits":[{"interfaceLanguage":"swift"}]}],"hierarchy":{"paths":[["doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore"]]},"primaryContentSections":[{"kind":"content","content":[{"type":"heading","text":"Overview","level":2,"anchor":"Overview"},{"type":"paragraph","inlineContent":[{"text":"Versions:","type":"text"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"v1 (2024-08-07): Initial version"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"v1.1:","type":"text"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Remove the ","type":"text"},{"type":"codeVoice","code":"reportError(_:)"},{"type":"text","text":" method from "},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"text":" and instead make the ","type":"text"},{"type":"codeVoice","code":"handle(...)"},{"type":"text","text":" method of"},{"type":"text","text":" "},{"type":"codeVoice","code":"StreamingLambdaHandler"},{"type":"text","text":" throwing."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Remove the "},{"code":"addBackgroundTask(_:)","type":"codeVoice"},{"text":" method from ","type":"text"},{"code":"LambdaContext","type":"codeVoice"},{"text":" due to structured concurrency concerns and introduce","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"the "},{"type":"codeVoice","code":"LambdaWithBackgroundProcessingHandler"},{"text":" protocol as a solution.","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Introduce "},{"code":"LambdaHandlerAdapter","type":"codeVoice"},{"type":"text","text":", which adapts handlers conforming to "},{"code":"LambdaHandler","type":"codeVoice"},{"type":"text","text":" with"},{"type":"text","text":" "},{"code":"LambdaWithBackgroundProcessingHandler","type":"codeVoice"},{"type":"text","text":"."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Update "},{"code":"LambdaCodableAdapter","type":"codeVoice"},{"type":"text","text":" to now be generic over any handler conforming to"},{"type":"text","text":" "},{"code":"LambdaWithBackgroundProcessingHandler","type":"codeVoice"},{"text":" instead of ","type":"text"},{"code":"LambdaHandler","type":"codeVoice"},{"text":".","type":"text"}]}]}]}]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"v1.2:","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Remove ","type":"text"},{"type":"codeVoice","code":"~Copyable"},{"type":"text","text":" from "},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"type":"text","text":" and "},{"type":"codeVoice","code":"LambdaResponseWriter"},{"type":"text","text":". Instead throw an error when"},{"text":" ","type":"text"},{"type":"codeVoice","code":"finish()"},{"type":"text","text":" is called multiple times or when "},{"code":"write","type":"codeVoice"},{"text":"\/","type":"text"},{"type":"codeVoice","code":"writeAndFinish"},{"text":" is called after ","type":"text"},{"code":"finish()","type":"codeVoice"},{"type":"text","text":"."}]}]}]}]}],"type":"unorderedList"},{"anchor":"Motivation","text":"Motivation","level":2,"type":"heading"},{"anchor":"Current-Limitations","type":"heading","text":"Current Limitations","level":3},{"anchor":"EventLoop-interfaces","level":4,"type":"heading","text":"EventLoop interfaces"},{"inlineContent":[{"type":"text","text":"The current API extensively uses the "},{"code":"EventLoop","type":"codeVoice"},{"text":" family of interfaces from SwiftNIO in many areas. To use these","type":"text"},{"type":"text","text":" "},{"type":"text","text":"interfaces correctly though, it requires developers to exercise great care and understand the various transform methods"},{"text":" ","type":"text"},{"text":"that are used to work with ","type":"text"},{"type":"codeVoice","code":"EventLoop"},{"text":"s and ","type":"text"},{"code":"EventLoopFuture","type":"codeVoice"},{"text":"s. This results in a lot of cognitive complexity and makes","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"the code in the current API hard to reason about and maintain. For these reasons, the overarching trend in the Swift on"},{"text":" ","type":"text"},{"text":"Server ecosystem is to shift to newer, more readable, Swift concurrency constructs and de-couple from SwiftNIO’s","type":"text"},{"type":"text","text":" "},{"code":"EventLoop","type":"codeVoice"},{"type":"text","text":" interfaces."}],"type":"paragraph"},{"level":4,"type":"heading","anchor":"No-ownership-of-the-main-function","text":"No ownership of the main() function"},{"inlineContent":[{"type":"text","text":"A Lambda function can currently be implemented through conformance to the various handler protocols defined in"},{"type":"text","text":" "},{"type":"codeVoice","code":"AWSLambdaRuntimeCore\/LambdaHandler"},{"type":"text","text":". Each of these protocols have an extension which implements a "},{"type":"codeVoice","code":"static func main()"},{"text":".","type":"text"},{"type":"text","text":" "},{"text":"This allows users to annotate their ","type":"text"},{"type":"codeVoice","code":"LambdaHandler"},{"type":"text","text":" conforming object with "},{"code":"@main","type":"codeVoice"},{"type":"text","text":". The "},{"type":"codeVoice","code":"static func main()"},{"type":"text","text":" calls the"},{"type":"text","text":" "},{"type":"text","text":"internal "},{"type":"codeVoice","code":"Lambda.run()"},{"text":" function, which starts the Lambda function. Since the ","type":"text"},{"code":"Lambda.run()","type":"codeVoice"},{"type":"text","text":" method is internal, users"},{"text":" ","type":"text"},{"text":"cannot override the default implementation. This has proven challenging for users who want to","type":"text"},{"type":"text","text":" "},{"identifier":"https:\/\/github.com\/swift-server\/swift-aws-lambda-runtime\/issues\/265","isActive":true,"type":"reference"},{"text":".","type":"text"},{"type":"text","text":" "},{"text":"Setting up global properties is required to customize the Swift Logging, Metric and Tracing backend.","type":"text"}],"type":"paragraph"},{"anchor":"Non-trivial-transition-from-SimpleLambdaHandler-to-LambdaHandler","text":"Non-trivial transition from SimpleLambdaHandler to LambdaHandler","level":4,"type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"code":"SimpleLambdaHandler","type":"codeVoice"},{"text":" protocol provides a quick and easy way to implement a basic Lambda function. It only requires","type":"text"},{"text":" ","type":"text"},{"text":"an implementation of the ","type":"text"},{"type":"codeVoice","code":"handle"},{"type":"text","text":" function where the business logic of the Lambda function can be written."},{"text":" ","type":"text"},{"code":"SimpleLambdaHandler","type":"codeVoice"},{"type":"text","text":" is perfectly sufficient for small use-cases as the user does not need to spend much time looking"},{"text":" ","type":"text"},{"text":"into the library.","type":"text"}]},{"inlineContent":[{"text":"However, ","type":"text"},{"code":"SimpleLambdaHandler","type":"codeVoice"},{"text":" cannot be used when services such as a database client need to be initialized before the","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Lambda runtime starts and then also gracefully shutdown prior to the runtime terminating. This is because the only way"},{"type":"text","text":" "},{"text":"to register termination logic is through the ","type":"text"},{"type":"codeVoice","code":"LambdaInitializationContext"},{"text":" (containing a field","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"terminator: LambdaTerminator"},{"type":"text","text":") which is created and used "},{"inlineContent":[{"text":"internally","type":"text"}],"type":"emphasis"},{"type":"text","text":" within "},{"type":"codeVoice","code":"LambdaRuntime"},{"text":" and never exposed through","type":"text"},{"text":" ","type":"text"},{"code":"SimpleLambdaHandler","type":"codeVoice"},{"text":". For such use-cases, other handler protocols like ","type":"text"},{"type":"codeVoice","code":"LambdaHandler"},{"type":"text","text":" must be used. "},{"code":"LambdaHandler","type":"codeVoice"},{"text":" ","type":"text"},{"type":"text","text":"exposes a "},{"code":"context","type":"codeVoice"},{"type":"text","text":" argument of type "},{"type":"codeVoice","code":"LambdaInitializationContext"},{"type":"text","text":" through its initializer. Within the initializer,"},{"text":" ","type":"text"},{"text":"required services can be initialized and their graceful shutdown logic can be registered with the","type":"text"},{"text":" ","type":"text"},{"type":"codeVoice","code":"context.terminator.register"},{"type":"text","text":" function."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"Yet, ","type":"text"},{"type":"codeVoice","code":"LambdaHandler"},{"type":"text","text":" is quite cumbersome to use in such use-cases as users have to deviate from the established norms of"},{"type":"text","text":" "},{"text":"the Swift on Server ecosystem in order to cleanly manage the lifecycle of the services intended to be used. This is","type":"text"},{"type":"text","text":" "},{"type":"text","text":"because the convenient "},{"type":"codeVoice","code":"swift-service-lifecycle"},{"text":" v2 library — which is commonly used for cleanly managing the lifecycles","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"of required services and widely supported by many libraries — cannot be used in a structured concurrency manner."}]},{"level":4,"type":"heading","text":"Does not integrate well with swift-service-lifecycle in a structured concurrency manner","anchor":"Does-not-integrate-well-with-swift-service-lifecycle-in-a-structured-concurrency-manner"},{"type":"paragraph","inlineContent":[{"text":"The Lambda runtime can only be started using the ","type":"text"},{"type":"strong","inlineContent":[{"text":"internal","type":"text"}]},{"type":"text","text":" "},{"code":"Lambda.run()","type":"codeVoice"},{"type":"text","text":" function. This function is called by the"},{"type":"text","text":" "},{"code":"main()","type":"codeVoice"},{"text":" function defined by the ","type":"text"},{"type":"codeVoice","code":"LambdaHandler"},{"type":"text","text":" protocol, preventing users from injecting initialized services into the"},{"text":" ","type":"text"},{"type":"text","text":"runtime "},{"inlineContent":[{"type":"text","text":"prior"}],"type":"emphasis"},{"type":"text","text":" to it starting. As shown below, this forces users to use an "},{"type":"strong","inlineContent":[{"text":"unstructured concurrency","type":"text"}]},{"type":"text","text":" approach and"},{"type":"text","text":" "},{"text":"manually initialize services, leading to the issue of the user then perhaps forgetting to gracefully shutdown the","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"initialized services:"}]},{"code":["struct MyLambda: LambdaHandler {","    let pgClient: PostgresClient","","    init(context: AWSLambdaRuntimeCore.LambdaInitializationContext) async throws {","        \/\/\/ Instantiate service","        let client = PostgresClient(configuration: ...)","","        \/\/\/ Unstructured concurrency to initialize the service","        let pgTask = Task {","            await client.run()","        }","","        \/\/\/ Store the client in `self` so that it can be used in `handle(...)`","        self.pgClient = client","","        \/\/\/ !!! Must remember to explicitly register termination logic for PostgresClient !!!","        context.terminator.register(","           name: \"PostgreSQL Client\",","           handler: { eventLoop in","               pgTask.cancel()","               return eventLoop.makeFutureWithTask {","                  await pgTask.value","               }","           }","        )","    }","","    func handle(_ event: Event, context: LambdaContext) async throws -> Output {","        \/\/\/ Use the initialized service stored in `self.pgClient`","        try await self.pgClient.query(...)","    }","}"],"type":"codeListing","syntax":"swift"},{"level":4,"anchor":"Verbose-Codable-support","text":"Verbose Codable support","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the current API, there are extensions and Codable wrapper classes for decoding events and encoding computed responses"},{"text":" ","type":"text"},{"text":"for ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"each"}]},{"text":" different handler protocol and for both ","type":"text"},{"code":"String","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"JSON","type":"codeVoice"},{"text":" formats. This has resulted in a lot of","type":"text"},{"text":" ","type":"text"},{"text":"boilerplate code which can very easily be made generic and simplified in v2.","type":"text"}]},{"anchor":"New-features","level":3,"type":"heading","text":"New features"},{"type":"heading","level":4,"anchor":"Support-response-streaming","text":"Support response streaming"},{"inlineContent":[{"type":"text","text":"In April 2023"},{"text":" ","type":"text"},{"identifier":"https:\/\/aws.amazon.com\/blogs\/compute\/introducing-aws-lambda-response-streaming\/","isActive":true,"type":"reference"},{"text":" ","type":"text"},{"text":"in Lambda. The current API does not support streaming. For v2 we want to change this.","type":"text"}],"type":"paragraph"},{"text":"Scheduling background work","type":"heading","anchor":"Scheduling-background-work","level":4},{"inlineContent":[{"type":"text","text":"In May"},{"text":" ","type":"text"},{"identifier":"https:\/\/aws.amazon.com\/blogs\/compute\/running-code-after-returning-a-response-from-an-aws-lambda-function\/","isActive":true,"type":"reference"},{"type":"text","text":" "},{"type":"text","text":"until the runtime asks for more work from the control plane. We want to support this by adding new API that allows"},{"type":"text","text":" "},{"text":"background processing, even after the response has been returned.","type":"text"}],"type":"paragraph"},{"type":"heading","level":2,"anchor":"Proposed-Solution","text":"Proposed Solution"},{"level":3,"text":"async\/await-first API","anchor":"asyncawait-first-API","type":"heading"},{"inlineContent":[{"text":"Large parts of ","type":"text"},{"type":"codeVoice","code":"Lambda"},{"text":", ","type":"text"},{"type":"codeVoice","code":"LambdaHandler"},{"type":"text","text":", and "},{"type":"codeVoice","code":"LambdaRuntime"},{"type":"text","text":" will be re-written to use async\/await constructs in place"},{"type":"text","text":" "},{"text":"of the ","type":"text"},{"type":"codeVoice","code":"EventLoop"},{"text":" family of interfaces.","type":"text"}],"type":"paragraph"},{"type":"heading","anchor":"Providing-ownership-of-main-and-support-for-swift-service-lifecycle","level":3,"text":"Providing ownership of main() and support for swift-service-lifecycle"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Instead of conforming to a handler protocol, users can now create a ","type":"text"},{"code":"LambdaRuntime","type":"codeVoice"},{"text":" by passing in a handler closure.","type":"text"}]}]},{"content":[{"inlineContent":[{"code":"LambdaRuntime","type":"codeVoice"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"ServiceLifecycle.Service"},{"text":" by implementing a ","type":"text"},{"type":"codeVoice","code":"run()"},{"type":"text","text":" method that contains initialization"},{"type":"text","text":" "},{"text":"and graceful shutdown logic.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"This allows the lifecycle of the "},{"type":"codeVoice","code":"LambdaRuntime"},{"text":" to be managed with ","type":"text"},{"type":"codeVoice","code":"swift-service-lifecycle"},{"text":" ","type":"text"},{"inlineContent":[{"type":"text","text":"alongside"}],"type":"emphasis"},{"text":" and in the","type":"text"},{"type":"text","text":" "},{"type":"text","text":"same way the lifecycles of the required services are managed, e.g."},{"text":" ","type":"text"},{"type":"codeVoice","code":"try await ServiceGroup(services: [postgresClient, ..., lambdaRuntime], ...).run()"},{"text":".","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Dependencies can now be injected into "},{"type":"codeVoice","code":"LambdaRuntime"},{"type":"text","text":". With "},{"code":"swift-service-lifecycle","type":"codeVoice"},{"type":"text","text":", services will be initialized"},{"type":"text","text":" "},{"type":"text","text":"together with "},{"code":"LambdaRuntime","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"The required services can then be used within the handler in a structured concurrency manner."},{"type":"text","text":" "},{"code":"swift-service-lifecycle","type":"codeVoice"},{"text":" takes care of listening for termination signals and terminating the services as well as the","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"LambdaRuntime"},{"text":" in correct order.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"code":"LambdaTerminator","type":"codeVoice"},{"text":" can now be eliminated because its role is replaced with ","type":"text"},{"type":"codeVoice","code":"swift-service-lifecycle"},{"text":". The termination","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"logic of the Lambda function will be implemented in the conforming "},{"type":"codeVoice","code":"run()"},{"type":"text","text":" function of "},{"type":"codeVoice","code":"LambdaRuntime"},{"type":"text","text":"."}]}]}]},{"type":"paragraph","inlineContent":[{"text":"With this, the earlier code snippet can be replaced with something much easier to read, maintain, and debug:","type":"text"}]},{"syntax":"swift","code":["\/\/\/ Instantiate services","let postgresClient = PostgresClient()","","\/\/\/ Instantiate LambdaRuntime with a closure handler implementing the business logic of the Lambda function","let runtime = LambdaRuntime { (event: Input, context: LambdaContext) in","    \/\/\/ Use initialized service within the handler","    try await postgresClient.query(...)","}","","\/\/\/ Use ServiceLifecycle to manage the initialization and termination","\/\/\/ of the services as well as the LambdaRuntime","let serviceGroup = ServiceGroup(","    services: [postgresClient, runtime],","    configuration: .init(gracefulShutdownSignals: [.sigterm]),","    logger: logger",")","try await serviceGroup.run()"],"type":"codeListing"},{"level":3,"text":"Simplifying Codable support","type":"heading","anchor":"Simplifying-Codable-support"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A detailed explanation is provided in the "},{"type":"strong","inlineContent":[{"type":"text","text":"Codable Support"}]},{"type":"text","text":" section. In short, much of the boilerplate code defined"},{"text":" ","type":"text"},{"text":"for each handler protocol in ","type":"text"},{"type":"codeVoice","code":"Lambda+Codable"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Lambda+String"},{"type":"text","text":" will be replaced with a single "},{"code":"LambdaCodableAdapter","type":"codeVoice"},{"text":" ","type":"text"},{"type":"text","text":"struct."}]},{"type":"paragraph","inlineContent":[{"text":"This adapter struct is generic over (1) any handler conforming to a new handler protocol","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"LambdaWithBackgroundProcessingHandler"},{"type":"text","text":", (2) the user-specified input and output types, and (3) any decoder and encoder"},{"type":"text","text":" "},{"type":"text","text":"conforming to protocols "},{"type":"codeVoice","code":"LambdaEventDecoder"},{"text":" and ","type":"text"},{"code":"LambdaOutputDecoder","type":"codeVoice"},{"type":"text","text":". The adapter will wrap the underlying handler"},{"type":"text","text":" "},{"type":"text","text":"with encoding\/decoding logic."}]},{"type":"heading","level":2,"anchor":"Detailed-Solution","text":"Detailed Solution"},{"type":"paragraph","inlineContent":[{"text":"Below are explanations for all types that we want to use in AWS Lambda Runtime v2.","type":"text"}]},{"text":"LambdaResponseStreamWriter","anchor":"LambdaResponseStreamWriter","level":3,"type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"We will introduce a new "},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"type":"text","text":" protocol. It is used in the new "},{"type":"codeVoice","code":"StreamingLambdaHandler"},{"text":" (defined","type":"text"},{"text":" ","type":"text"},{"text":"below), which is the new base protocol for the ","type":"text"},{"type":"codeVoice","code":"LambdaRuntime"},{"type":"text","text":" (defined below as well)."}]},{"type":"codeListing","syntax":"swift","code":["\/\/\/ A writer object to write the Lambda response stream into","public protocol LambdaResponseStreamWriter {","    \/\/\/ Write a response part into the stream. The HTTP response is started lazily before the first call to `write(_:)`.","    \/\/\/ Bytes written to the writer are streamed continually.","    func write(_ buffer: ByteBuffer) async throws","    \/\/\/ End the response stream and the underlying HTTP response.","    func finish() async throws","    \/\/\/ Write a response part into the stream and end the response stream as well as the underlying HTTP response.","    func writeAndFinish(_ buffer: ByteBuffer) async throws","}"]},{"inlineContent":[{"text":"If the user does not call ","type":"text"},{"code":"finish()","type":"codeVoice"},{"type":"text","text":", the library will automatically finish the stream after the last "},{"type":"codeVoice","code":"write"},{"text":".","type":"text"},{"text":" ","type":"text"},{"text":"Appropriate errors will be thrown if ","type":"text"},{"code":"finish()","type":"codeVoice"},{"text":" is called multiple times, or if ","type":"text"},{"code":"write","type":"codeVoice"},{"type":"text","text":"\/"},{"type":"codeVoice","code":"writeAndFinish"},{"text":" is called after","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"finish()"},{"type":"text","text":"."}],"type":"paragraph"},{"text":"LambdaContext","level":3,"anchor":"LambdaContext","type":"heading"},{"inlineContent":[{"type":"codeVoice","code":"LambdaContext"},{"text":" will be largely unchanged, but the ","type":"text"},{"type":"codeVoice","code":"eventLoop"},{"type":"text","text":" property will be removed. The "},{"type":"codeVoice","code":"allocator"},{"text":" property of","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"type "},{"code":"ByteBufferAllocator","type":"codeVoice"},{"text":" will also be removed because (1), we generally want to reduce the number of SwiftNIO types","type":"text"},{"type":"text","text":" "},{"type":"text","text":"exposed in the API, and (2), "},{"type":"codeVoice","code":"ByteBufferAllocator"},{"text":" does not optimize the allocation strategies. The common pattern","type":"text"},{"text":" ","type":"text"},{"text":"observed across many libraries is to re-use existing ","type":"text"},{"code":"ByteBuffer","type":"codeVoice"},{"type":"text","text":"s as much as possible. This is also what we do for the"},{"text":" ","type":"text"},{"type":"codeVoice","code":"LambdaCodableAdapter"},{"text":" (explained in the ","type":"text"},{"type":"strong","inlineContent":[{"type":"text","text":"Codable Support"}]},{"text":" section) implementation.","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["\/\/\/ A context object passed as part of an invocation in LambdaHandler handle functions.","public struct LambdaContext: Sendable {","    \/\/\/ The request ID, which identifies the request that triggered the function invocation.","    public var requestID: String { get }","","    \/\/\/ The AWS X-Ray tracing header.","    public var traceID: String { get }","","    \/\/\/ The ARN of the Lambda function, version, or alias that's specified in the invocation.","    public var invokedFunctionARN: String { get }","","    \/\/\/ The timestamp that the function times out.","    public var deadline: DispatchWallTime { get }","","    \/\/\/ For invocations from the AWS Mobile SDK, data about the Amazon Cognito identity provider.","    public var cognitoIdentity: String? { get }","","    \/\/\/ For invocations from the AWS Mobile SDK, data about the client application and device.","    public var clientContext: String? { get }","","    \/\/\/ `Logger` to log with.","    \/\/\/","    \/\/\/ - note: The `LogLevel` can be configured using the `LOG_LEVEL` environment variable.","    public var logger: Logger { get }","}"]},{"type":"heading","level":3,"text":"Handlers","anchor":"Handlers"},{"type":"paragraph","inlineContent":[{"type":"text","text":"We introduce three handler protocols: "},{"type":"codeVoice","code":"StreamingLambdaHandler"},{"text":", ","type":"text"},{"code":"LambdaHandler","type":"codeVoice"},{"type":"text","text":", and"},{"text":" ","type":"text"},{"type":"codeVoice","code":"LambdaWithBackgroundProcessingHandler"},{"text":".","type":"text"}]},{"text":"StreamingLambdaHandler","anchor":"StreamingLambdaHandler","level":4,"type":"heading"},{"inlineContent":[{"text":"The new ","type":"text"},{"type":"codeVoice","code":"StreamingLambdaHandler"},{"type":"text","text":" protocol is the base protocol to implement a Lambda function. Most users will not use"},{"text":" ","type":"text"},{"type":"text","text":"this protocol and instead use the "},{"type":"codeVoice","code":"LambdaHandler"},{"text":" protocol defined below.","type":"text"}],"type":"paragraph"},{"code":["\/\/\/ The base StreamingLambdaHandler protocol","public protocol StreamingLambdaHandler {","    \/\/\/ The business logic of the Lambda function","    \/\/\/ - Parameters:","    \/\/\/   - event: The invocation's input data","    \/\/\/   - responseWriter: A ``LambdaResponseStreamWriter`` to write the invocation's response to.","    \/\/\/                     If no response or error is written to the `responseWriter` it will","    \/\/\/                     report an error to the invoker.","    \/\/\/   - context: The LambdaContext containing the invocation's metadata","    \/\/\/ - Throws:","    \/\/\/ How the thrown error will be handled by the runtime:","    \/\/\/   - An invocation error will be reported if the error is thrown before the first call to","    \/\/\/     ``LambdaResponseStreamWriter.write(_:)``.","    \/\/\/   - If the error is thrown after call(s) to ``LambdaResponseStreamWriter.write(_:)`` but before","    \/\/\/     a call to ``LambdaResponseStreamWriter.finish()``, the response stream will be closed and trailing","    \/\/\/     headers will be sent.","    \/\/\/   - If ``LambdaResponseStreamWriter.finish()`` has already been called before the error is thrown, the","    \/\/\/     error will be logged.","    mutating func handle(_ event: ByteBuffer, responseWriter: some LambdaResponseStreamWriter, context: LambdaContext) async throws","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"Using this protocol requires the ","type":"text"},{"type":"codeVoice","code":"handle"},{"text":" method to receive the incoming event as a ","type":"text"},{"type":"codeVoice","code":"ByteBuffer"},{"text":" and return the output","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"as a "},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":" too."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Through the "},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"text":", which is passed as an argument in the ","type":"text"},{"code":"handle","type":"codeVoice"},{"type":"text","text":" function, the "},{"inlineContent":[{"type":"text","text":"response can be"},{"type":"text","text":" "},{"text":"streamed","type":"text"}],"type":"strong"},{"type":"text","text":" by calling the "},{"type":"codeVoice","code":"write(_:)"},{"text":" function of the ","type":"text"},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"type":"text","text":" with partial data repeatedly before"},{"text":" ","type":"text"},{"text":"finally closing the response stream by calling ","type":"text"},{"type":"codeVoice","code":"finish()"},{"text":". Users can also choose to return the entire output and not","type":"text"},{"type":"text","text":" "},{"type":"text","text":"stream the response by calling "},{"code":"writeAndFinish(_:)","type":"codeVoice"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This protocol also allows for background tasks to be run after a result has been reported to the AWS Lambda control"},{"text":" ","type":"text"},{"type":"text","text":"plane, since the "},{"code":"handle(...)","type":"codeVoice"},{"text":" function is free to implement any background work after the call to","type":"text"},{"type":"text","text":" "},{"code":"responseWriter.finish()","type":"codeVoice"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"text":"The protocol is defined in a way that supports a broad range of use-cases. The handle method is marked as ","type":"text"},{"type":"codeVoice","code":"mutating"},{"text":" to","type":"text"},{"type":"text","text":" "},{"text":"allow handlers to be implemented with a ","type":"text"},{"type":"codeVoice","code":"struct"},{"type":"text","text":"."}]},{"inlineContent":[{"text":"An implementation that sends the number 1 to 10 every 500ms could look like this:","type":"text"}],"type":"paragraph"},{"code":["struct SendNumbersWithPause: StreamingLambdaHandler {","    func handle(","        _ event: ByteBuffer,","        responseWriter: some LambdaResponseStreamWriter,","        context: LambdaContext","    ) async throws {","        for i in 1...10 {","            \/\/ Send partial data","            responseWriter.write(ByteBuffer(string: #\"\\#(i)\\n\\r\"#))","            \/\/ Perform some long asynchronous work","            try await Task.sleep(for: .milliseconds(500))","        }","        \/\/ All data has been sent. Close off the response stream.","        responseWriter.finish()","    }","}"],"type":"codeListing","syntax":"swift"},{"text":"LambdaHandler:","level":4,"anchor":"LambdaHandler","type":"heading"},{"inlineContent":[{"text":"This handler protocol will be the go-to choice for most use-cases because it is completely agnostic to any","type":"text"},{"text":" ","type":"text"},{"text":"encoding\/decoding logic – conforming objects simply have to implement the ","type":"text"},{"type":"codeVoice","code":"handle"},{"text":" function where the input and return","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"types are Swift objects."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that the "},{"code":"handle","type":"codeVoice"},{"type":"text","text":" function does not receive a "},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"type":"text","text":" as an argument. Response streaming is"},{"text":" ","type":"text"},{"type":"text","text":"not viable for "},{"type":"codeVoice","code":"LambdaHandler"},{"type":"text","text":" because the output has to be encoded prior to it being sent, e.g. it is not possible to"},{"text":" ","type":"text"},{"text":"encode a partial\/incomplete JSON string.","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["public protocol LambdaHandler {","    \/\/\/ Generic input type","    \/\/\/ The body of the request sent to Lambda will be decoded into this type for the handler to consume","    associatedtype Event","    \/\/\/ Generic output type","    \/\/\/ This is the return type of the handle() function.","    associatedtype Output","","    \/\/\/ The business logic of the Lambda function. Receives a generic input type and returns a generic output type.","    \/\/\/ Agnostic to encoding\/decoding","    mutating func handle(_ event: Event, context: LambdaContext) async throws -> Output","}"]},{"level":4,"anchor":"LambdaWithBackgroundProcessingHandler","type":"heading","text":"LambdaWithBackgroundProcessingHandler:"},{"type":"paragraph","inlineContent":[{"text":"This protocol is exactly like ","type":"text"},{"code":"LambdaHandler","type":"codeVoice"},{"text":", with the only difference being the added support for executing background","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"work after the result has been sent to the AWS Lambda control plane."}]},{"type":"paragraph","inlineContent":[{"text":"This is achieved by not having a return type in the ","type":"text"},{"type":"codeVoice","code":"handle"},{"text":" function. The output is instead written into a","type":"text"},{"type":"text","text":" "},{"code":"LambdaResponseWriter","type":"codeVoice"},{"type":"text","text":" that is passed in as an argument, meaning that the "},{"type":"codeVoice","code":"handle"},{"type":"text","text":" function is then free to implement"},{"type":"text","text":" "},{"text":"any background work after the result has been sent to the AWS Lambda control plane.","type":"text"}]},{"inlineContent":[{"code":"LambdaResponseWriter","type":"codeVoice"},{"text":" has different semantics to the ","type":"text"},{"code":"LambdaResponseStreamWriter","type":"codeVoice"},{"type":"text","text":". Where the "},{"code":"write(_:)","type":"codeVoice"},{"type":"text","text":" function of"},{"type":"text","text":" "},{"code":"LambdaResponseStreamWriter","type":"codeVoice"},{"text":" means writing into a response stream, the ","type":"text"},{"type":"codeVoice","code":"write(_:)"},{"type":"text","text":" function of "},{"type":"codeVoice","code":"LambdaResponseWriter"},{"type":"text","text":" "},{"type":"text","text":"simply serves as a mechanism to return the output without explicitly returning from the "},{"type":"codeVoice","code":"handle"},{"type":"text","text":" function."}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["public protocol LambdaResponseWriter<Output> {","    associatedtype Output","","    \/\/\/ Sends the generic Output object (representing the computed result of the handler)","    \/\/\/ to the AWS Lambda response endpoint.","    \/\/\/ An error will be thrown if this function is called more than once.","    func write(_: Output) async throws","}","","public protocol LambdaWithBackgroundProcessingHandler {","    \/\/\/ Generic input type","    \/\/\/ The body of the request sent to Lambda will be decoded into this type for the handler to consume","    associatedtype Event","    \/\/\/ Generic output type","    \/\/\/ This is the type that the handle() function will send through the ``LambdaResponseWriter``.","    associatedtype Output","","    \/\/\/ The business logic of the Lambda function. Receives a generic input type and returns a generic output type.","    \/\/\/ Agnostic to JSON encoding\/decoding","    func handle(","        _ event: Event,","        outputWriter: some LambdaResponseWriter<Output>,","        context: LambdaContext","    ) async throws","}"]},{"level":5,"text":"Example Usage:","type":"heading","anchor":"Example-Usage"},{"type":"codeListing","syntax":"swift","code":["struct BackgroundProcessingHandler: LambdaWithBackgroundProcessingHandler {","    struct Input: Decodable {","        let message: String","    }","","    struct Greeting: Encodable {","        let echoedMessage: String","    }","","    typealias Event = Input","    typealias Output = Greeting","","    func handle(","        _ event: Event,","        outputWriter: some LambdaResponseWriter<Output>,","        context: LambdaContext","    ) async throws {","        \/\/ Return result to the Lambda control plane","        try await outputWriter.write(result: Greeting(echoedMessage: event.messageToEcho))","","        \/\/ Perform some background work, e.g:","        try await Task.sleep(for: .seconds(10))","","        \/\/ Exit the function. All asynchronous work has been executed before exiting the scope of this function.","        \/\/ Follows structured concurrency principles.","        return","    }","}"]},{"text":"Handler Adapters","anchor":"Handler-Adapters","level":4,"type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Since the "},{"type":"codeVoice","code":"StreamingLambdaHandler"},{"text":" protocol is the base protocol the ","type":"text"},{"type":"codeVoice","code":"LambdaRuntime"},{"text":" works with, there are adapters to","type":"text"},{"type":"text","text":" "},{"type":"text","text":"make both "},{"code":"LambdaHandler","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"LambdaWithBackgroundProcessingHandler","type":"codeVoice"},{"type":"text","text":" compatible with "},{"type":"codeVoice","code":"StreamingLambdaHandler"},{"text":".","type":"text"}]},{"type":"orderedList","items":[{"content":[{"inlineContent":[{"type":"codeVoice","code":"LambdaHandlerAdapter"},{"text":" accepts a ","type":"text"},{"code":"LambdaHandler","type":"codeVoice"},{"text":" and conforms it to ","type":"text"},{"type":"codeVoice","code":"LambdaWithBackgroundProcessingHandler"},{"type":"text","text":". This is"},{"type":"text","text":" "},{"type":"text","text":"achieved by taking the generic "},{"code":"Output","type":"codeVoice"},{"type":"text","text":" object returned from the "},{"code":"handle","type":"codeVoice"},{"type":"text","text":" function of "},{"code":"LambdaHandler","type":"codeVoice"},{"type":"text","text":" and passing it"},{"text":" ","type":"text"},{"text":"to the ","type":"text"},{"type":"codeVoice","code":"write(_:)"},{"text":" function of the ","type":"text"},{"code":"LambdaResponseWriter","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"LambdaCodableAdapter"},{"type":"text","text":" accepts a "},{"type":"codeVoice","code":"LambdaWithBackgroundProcessingHandler"},{"text":" and conforms it to ","type":"text"},{"code":"StreamingLambdaHandler","type":"codeVoice"},{"text":".","type":"text"},{"type":"text","text":" "},{"text":"This is achieved by wrapping the ","type":"text"},{"code":"LambdaResponseWriter","type":"codeVoice"},{"type":"text","text":" with the "},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"text":" provided by","type":"text"},{"type":"text","text":" "},{"code":"StreamingLambdaHandler","type":"codeVoice"},{"type":"text","text":". A call to the "},{"type":"codeVoice","code":"write(_:)"},{"type":"text","text":" function of "},{"type":"codeVoice","code":"LambdaResponseWriter"},{"type":"text","text":" is translated into a call to"},{"text":" ","type":"text"},{"text":"the ","type":"text"},{"type":"codeVoice","code":"writeAndFinish(_:)"},{"type":"text","text":" function of "},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"type":"text","text":"."}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Both "},{"type":"codeVoice","code":"LambdaHandlerAdapter"},{"type":"text","text":" and "},{"code":"LambdaCodableAdapter","type":"codeVoice"},{"type":"text","text":" are described in greater detail in the "},{"inlineContent":[{"text":"Codable Support","type":"text"}],"type":"strong"},{"text":" ","type":"text"},{"type":"text","text":"section."}]},{"type":"paragraph","inlineContent":[{"text":"To summarize, ","type":"text"},{"type":"codeVoice","code":"LambdaHandler"},{"type":"text","text":" can be used with the "},{"type":"codeVoice","code":"LambdaRuntime"},{"type":"text","text":" by first going through "},{"code":"LambdaHandlerAdapter","type":"codeVoice"},{"type":"text","text":" and"},{"type":"text","text":" "},{"text":"then through ","type":"text"},{"type":"codeVoice","code":"LambdaCodableAdapter"},{"text":". ","type":"text"},{"type":"codeVoice","code":"LambdaWithBackgroundHandler"},{"text":" just requires ","type":"text"},{"type":"codeVoice","code":"LambdaCodableAdapter"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For the common JSON-in and JSON-out use-case, there is an extension on "},{"type":"codeVoice","code":"LambdaRuntime"},{"type":"text","text":" that abstracts away this wrapping"},{"text":" ","type":"text"},{"type":"text","text":"from the user."}]},{"anchor":"LambdaRuntime","text":"LambdaRuntime","level":3,"type":"heading"},{"inlineContent":[{"code":"LambdaRuntime","type":"codeVoice"},{"text":" is the class that communicates with the Lambda control plane as defined in","type":"text"},{"text":" ","type":"text"},{"type":"reference","identifier":"https:\/\/docs.aws.amazon.com\/lambda\/latest\/dg\/runtimes-custom.html","isActive":true},{"text":" and","type":"text"},{"type":"text","text":" "},{"type":"text","text":"forward the invocations to the provided "},{"type":"codeVoice","code":"StreamingLambdaHandler"},{"type":"text","text":". It will conform to "},{"type":"codeVoice","code":"ServiceLifecycle.Service"},{"type":"text","text":" to"},{"type":"text","text":" "},{"text":"provide support for ","type":"text"},{"type":"codeVoice","code":"swift-service-lifecycle"},{"type":"text","text":"."}],"type":"paragraph"},{"code":["\/\/\/ The LambdaRuntime object. This object communicates with the Lambda control plane","\/\/\/ to fetch work and report errors.","public final class LambdaRuntime<Handler>: ServiceLifecycle.Service, Sendable","    where Handler: StreamingLambdaHandler","{","","    \/\/\/ Create a LambdaRuntime by passing a handler, an eventLoop and a logger.","    \/\/\/ - Parameter handler: A ``StreamingLambdaHandler`` that will be invoked","    \/\/\/ - Parameter eventLoop: An ``EventLoop`` on which the LambdaRuntime will be","    \/\/\/                        executed. Defaults to an EventLoop from","    \/\/\/                        ``NIOSingletons.posixEventLoopGroup``.","    \/\/\/ - Parameter logger: A logger","    public init(","        handler: sending Handler,","        eventLoop: EventLoop = Lambda.defaultEventLoop,","        logger: Logger = Logger(label: \"Lambda\")","    )","","    \/\/\/ Create a LambdaRuntime by passing a ``StreamingLambdaHandler``.","    public convenience init(handler: sending Handler)","","    \/\/\/ Starts the LambdaRuntime by connecting to the Lambda control plane to ask","    \/\/\/ for events to process. If the environment variable AWS_LAMBDA_RUNTIME_API is","    \/\/\/ set, the LambdaRuntime will connect to the Lambda control plane. Otherwise","    \/\/\/ it will start a mock server that can be used for testing at port 8080","    \/\/\/ locally.","    \/\/\/ Cancel the task that runs this function to close the communication with","    \/\/\/ the Lambda control plane or close the local mock server. This function","    \/\/\/ only returns once cancelled.","    public func run() async throws","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"The current API allows for a Lambda function to be tested locally through a mock server by requiring an environment","type":"text"},{"type":"text","text":" "},{"text":"variable named ","type":"text"},{"type":"codeVoice","code":"LOCAL_LAMBDA_SERVER_ENABLED"},{"type":"text","text":" to be set to "},{"type":"codeVoice","code":"true"},{"type":"text","text":". If this environment variable is not set, the program"},{"type":"text","text":" "},{"text":"immediately crashes as the user will not have the ","type":"text"},{"code":"AWS_LAMBDA_RUNTIME_API","type":"codeVoice"},{"type":"text","text":" environment variable on their local machine"},{"type":"text","text":" "},{"text":"(set automatically when deployed to AWS Lambda). However, making the user set the ","type":"text"},{"code":"LOCAL_LAMBDA_SERVER_ENABLED","type":"codeVoice"},{"type":"text","text":" "},{"type":"text","text":"environment variable is an unnecessary step that can be avoided. In the v2 API, the "},{"type":"codeVoice","code":"run()"},{"type":"text","text":" function will automatically"},{"type":"text","text":" "},{"text":"start the mock server when the ","type":"text"},{"type":"codeVoice","code":"AWS_LAMBDA_RUNTIME_API"},{"text":" environment variable cannot be found.","type":"text"}],"type":"paragraph"},{"anchor":"Lambda","text":"Lambda","type":"heading","level":3},{"inlineContent":[{"type":"text","text":"We also add an enum to store a static function and a property on. We put this on the static "},{"type":"codeVoice","code":"Lambda"},{"type":"text","text":" because"},{"type":"text","text":" "},{"type":"codeVoice","code":"LambdaRuntime"},{"type":"text","text":" is generic and thus has bad ergonomics for static properties and functions."}],"type":"paragraph"},{"code":["enum Lambda {","    \/\/\/ This returns the default EventLoop that a LambdaRuntime is scheduled on.","    \/\/\/ It uses `NIOSingletons.posixEventLoopGroup.next()` under the hood.","    public static var defaultEventLoop: any EventLoop { get }","","    \/\/\/ Report a startup error to the Lambda Control Plane API","    public static func reportStartupError(any Error) async","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Since the library now provides ownership of the "},{"code":"main()","type":"codeVoice"},{"text":" function and allows users to initialize services before the","type":"text"},{"type":"text","text":" "},{"code":"LambdaRuntime","type":"codeVoice"},{"type":"text","text":" is initialized, the library cannot implicitly report"},{"text":" ","type":"text"},{"type":"reference","isActive":true,"identifier":"https:\/\/docs.aws.amazon.com\/lambda\/latest\/dg\/runtimes-api.html#runtimes-api-initerror"},{"text":" ","type":"text"},{"type":"text","text":"like it currently does through the "},{"type":"codeVoice","code":"initialize()"},{"text":" function of ","type":"text"},{"code":"LambdaRunner","type":"codeVoice"},{"text":" which wraps the handler’s ","type":"text"},{"code":"init(...)","type":"codeVoice"},{"type":"text","text":" and"},{"type":"text","text":" "},{"text":"handles any errors thrown by reporting it to the dedicated AWS endpoint.","type":"text"}]},{"inlineContent":[{"type":"text","text":"To retain support for initialization error reporting, the "},{"code":"Lambda.reportStartupError(any Error)","type":"codeVoice"},{"type":"text","text":" function gives users"},{"type":"text","text":" "},{"type":"text","text":"the option to manually report initialization errors in their closure handler. Although this should ideally happen"},{"type":"text","text":" "},{"type":"text","text":"implicitly like it currently does in v1, we believe this is a small compromise in comparison to the benefits gained in"},{"text":" ","type":"text"},{"type":"text","text":"now being able to cleanly manage the lifecycles of required services in a structured concurrency manner."}],"type":"paragraph"},{"type":"aside","style":"note","name":"Use-case","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"type":"paragraph","inlineContent":[{"text":"Assume we want to load a secret for the Lambda function from a secret vault first. If this fails, we want to report","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the error to the control plane:"}]},{"type":"codeListing","syntax":"swift","code":["let secretVault = SecretVault()","","do {","   \/\/\/ !!! Error thrown: secret \"foo\" does not exist !!!","   let secret = try await secretVault.getSecret(\"foo\")","","   let runtime = LambdaRuntime { (event: Input, context: LambdaContext) in","       \/\/\/ Lambda business logic","   }","","   let serviceGroup = ServiceGroup(","       services: [postgresClient, runtime],","       configuration: .init(gracefulShutdownSignals: [.sigterm]),","       logger: logger","   )","   try await serviceGroup.run()","} catch {","   \/\/\/ Report startup error straight away to the dedicated initialization error endpoint","   try await Lambda.reportStartupError(error)","}"]}]},{"level":3,"type":"heading","anchor":"Codable-support","text":"Codable support"},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"LambdaHandler"},{"type":"text","text":" and "},{"type":"codeVoice","code":"LambdaWithBackgroundProcessingHandler"},{"type":"text","text":" protocols abstract away encoding\/decoding logic from the"},{"text":" ","type":"text"},{"text":"conformers as they are generic over custom ","type":"text"},{"type":"codeVoice","code":"Event"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Output"},{"type":"text","text":" types. We introduce two adapters "},{"code":"LambdaHandlerAdapter","type":"codeVoice"},{"text":" ","type":"text"},{"type":"text","text":"and "},{"type":"codeVoice","code":"CodableLambdaAdapter"},{"type":"text","text":" that implement the encoding\/decoding logic and in turn allow the respective handlers to"},{"type":"text","text":" "},{"text":"conform to ","type":"text"},{"type":"codeVoice","code":"StreamingLambdaHandler"},{"type":"text","text":"."}]},{"type":"heading","anchor":"LambdaHandlerAdapter","text":"LambdaHandlerAdapter","level":4},{"type":"paragraph","inlineContent":[{"type":"text","text":"Any handler conforming to "},{"type":"codeVoice","code":"LambdaHandler"},{"type":"text","text":" can be conformed to "},{"code":"LambdaWithBackgroundProcessingHandler","type":"codeVoice"},{"text":" through","type":"text"},{"text":" ","type":"text"},{"code":"LambdaHandlerAdapter","type":"codeVoice"},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"swift","code":["\/\/\/ Wraps an underlying handler conforming to ``LambdaHandler``","\/\/\/ with ``LambdaWithBackgroundProcessingHandler``.","public struct LambdaHandlerAdapter<","    Event: Decodable,","    Output,","    Handler: LambdaHandler",">: LambdaWithBackgroundProcessingHandler where Handler.Event == Event, Handler.Output == Output {","    let handler: Handler","","    \/\/\/ Register the concrete handler.","    public init(handler: Handler)","","    \/\/\/ 1. Call the `self.handler.handle(...)` with `event` and `context`.","    \/\/\/ 2. Pass the generic `Output` object returned from `self.handler.handle(...)` to `outputWriter.write(_:)`","    public func handle(_ event: Event, outputWriter: some LambdaResponseWriter<Output>, context: LambdaContext) async throws","}"]},{"text":"LambdaCodableAdapter","type":"heading","level":4,"anchor":"LambdaCodableAdapter"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"LambdaCodableAdapter"},{"text":" accepts any generic underlying handler conforming to ","type":"text"},{"code":"LambdaWithBackgroundProcessingHandler","type":"codeVoice"},{"text":". It","type":"text"},{"type":"text","text":" "},{"text":"also accepts ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"any","type":"text"}]},{"text":" encoder and decoder object conforming to the ","type":"text"},{"code":"LambdaEventDecoder","type":"codeVoice"},{"type":"text","text":" and "},{"type":"codeVoice","code":"LambdaOutputEncoder"},{"type":"text","text":" "},{"text":"protocols:","type":"text"}]},{"level":5,"anchor":"LambdaEventDecoder-and-LambdaOutputEncoder-protocols","text":"LambdaEventDecoder and LambdaOutputEncoder protocols","type":"heading"},{"syntax":"swift","code":["public protocol LambdaEventDecoder {","    \/\/\/ Decode the ByteBuffer representing the received event into the generic type Event","    \/\/\/ the handler will receive","    func decode<Event: Decodable>(_ type: Event.Type, from buffer: ByteBuffer) throws -> Event","}","","public protocol LambdaOutputEncoder {","    \/\/\/ Encode the generic type Output the handler has produced into a ByteBuffer","    func encode<Output: Encodable>(_ value: Output, into buffer: inout ByteBuffer) throws","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"We provide conformances for Foundation’s ","type":"text"},{"type":"codeVoice","code":"JSONDecoder"},{"type":"text","text":" to "},{"code":"LambdaEventDecoder","type":"codeVoice"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"JSONEncoder"},{"type":"text","text":" to"},{"text":" ","type":"text"},{"type":"codeVoice","code":"LambdaOutputEncoder"},{"type":"text","text":"."}]},{"inlineContent":[{"code":"LambdaCodableAdapter","type":"codeVoice"},{"text":" implements its ","type":"text"},{"type":"codeVoice","code":"handle()"},{"text":" method by:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"text":"Decoding the ","type":"text"},{"code":"ByteBuffer","type":"codeVoice"},{"type":"text","text":" event into the generic "},{"code":"Event","type":"codeVoice"},{"text":" type.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Wrapping the "},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"text":" with a concrete ","type":"text"},{"code":"LambdaResponseWriter","type":"codeVoice"},{"type":"text","text":" such that calls to"},{"type":"text","text":" "},{"code":"LambdaResponseWriter","type":"codeVoice"},{"type":"text","text":"s "},{"type":"codeVoice","code":"write(_:)"},{"type":"text","text":" are mapped to "},{"code":"LambdaResponseStreamWriter","type":"codeVoice"},{"text":"s ","type":"text"},{"type":"codeVoice","code":"writeAndFinish(_:)"},{"type":"text","text":"."}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that the argument to "},{"type":"codeVoice","code":"LambdaResponseWriter"},{"text":"s ","type":"text"},{"type":"codeVoice","code":"write(_:)"},{"type":"text","text":" is a generic "},{"code":"Output","type":"codeVoice"},{"type":"text","text":" object whereas"},{"text":" ","type":"text"},{"code":"LambdaResponseStreamWriter","type":"codeVoice"},{"type":"text","text":"s "},{"code":"writeAndFinish(_:)","type":"codeVoice"},{"text":" requires a ","type":"text"},{"type":"codeVoice","code":"ByteBuffer"},{"text":".","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Therefore, the concrete implementation of ","type":"text"},{"code":"LambdaResponseWriter","type":"codeVoice"},{"type":"text","text":" also accepts an encoder. Its "},{"type":"codeVoice","code":"write(_:)"},{"text":" function","type":"text"},{"type":"text","text":" "},{"text":"first encodes the generic ","type":"text"},{"code":"Output","type":"codeVoice"},{"text":" object and then passes it to the underlying ","type":"text"},{"code":"LambdaResponseStreamWriter","type":"codeVoice"},{"text":".","type":"text"}]}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Passing the generic "},{"code":"Event","type":"codeVoice"},{"text":" instance, the concrete ","type":"text"},{"type":"codeVoice","code":"LambdaResponseWriter"},{"type":"text","text":", as well as the "},{"code":"LambdaContext","type":"codeVoice"},{"type":"text","text":" to the"},{"type":"text","text":" "},{"text":"underlying handler’s ","type":"text"},{"code":"handle()","type":"codeVoice"},{"type":"text","text":" method."}]}]}],"type":"orderedList"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"LambdaCodableAdapter"},{"type":"text","text":" can implement encoding\/decoding for "},{"inlineContent":[{"type":"text","text":"any"}],"type":"emphasis"},{"type":"text","text":" handler conforming to"},{"type":"text","text":" "},{"code":"LambdaWithBackgroundProcessingHandler","type":"codeVoice"},{"type":"text","text":" if "},{"type":"codeVoice","code":"Event"},{"type":"text","text":" is "},{"code":"Decodable","type":"codeVoice"},{"type":"text","text":" and the "},{"type":"codeVoice","code":"Output"},{"type":"text","text":" is "},{"code":"Encodable","type":"codeVoice"},{"type":"text","text":" or "},{"type":"codeVoice","code":"Void"},{"type":"text","text":", meaning"},{"type":"text","text":" "},{"type":"text","text":"that the encoding\/decoding stubs do not need to be implemented by the user."}]},{"syntax":"swift","type":"codeListing","code":["\/\/\/ Wraps an underlying handler conforming to `LambdaWithBackgroundProcessingHandler`","\/\/\/ with encoding\/decoding logic","public struct LambdaCodableAdapter<","    Handler: LambdaWithBackgroundProcessingHandler,","    Event: Decodable,","    Output,","    Decoder: LambdaEventDecoder,","    Encoder: LambdaOutputEncoder",">: StreamingLambdaHandler where Handler.Output == Output, Handler.Event == Event {","","    \/\/\/ Register the concrete handler, encoder, and decoder.","    public init(","        handler: Handler,","        encoder: Encoder,","        decoder: Decoder","    ) where Output: Encodable","","    \/\/\/ For handler with a void output -- the user doesn't specify an encoder.","    public init(","        handler: Handler,","        decoder: Decoder","    ) where Output == Void, Encoder == VoidEncoder","","    \/\/\/ 1. Decode the invocation event using `self.decoder`","    \/\/\/ 2. Create a concrete `LambdaResponseWriter` that maps calls to `write(_:)` with the `responseWriter`s `writeAndFinish(_:)`","    \/\/\/ 2. Call the underlying `self.handler.handle()` method with the decoded event data, the concrete `LambdaResponseWriter`,","    \/\/\/ and the `LambdaContext`.","    public mutating func handle(","        _ request: ByteBuffer,","        responseWriter: some LambdaResponseStreamWriter,","        context: LambdaContext","    ) async throws","}"]},{"text":"Handler as a Closure","anchor":"Handler-as-a-Closure","type":"heading","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"To create a Lambda function using the current API, a user first has to create an object and conform it to one of the"},{"text":" ","type":"text"},{"type":"text","text":"handler protocols by implementing the initializer and the "},{"type":"codeVoice","code":"handle(...)"},{"text":" function. Now that ","type":"text"},{"code":"LambdaRuntime","type":"codeVoice"},{"text":" is public,","type":"text"},{"text":" ","type":"text"},{"text":"this verbosity can very easily be simplified.","type":"text"}]},{"type":"heading","level":4,"anchor":"ClosureHandler","text":"ClosureHandler"},{"inlineContent":[{"type":"text","text":"This handler is generic over any "},{"type":"codeVoice","code":"Event"},{"text":" type conforming to ","type":"text"},{"type":"codeVoice","code":"Decodable"},{"type":"text","text":" and any "},{"type":"codeVoice","code":"Output"},{"type":"text","text":" type conforming to "},{"type":"codeVoice","code":"Encodable"},{"text":" ","type":"text"},{"type":"text","text":"or "},{"type":"codeVoice","code":"Void"},{"text":".","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["public struct ClosureHandler<Event, Output>: LambdaHandler {","    \/\/\/ Initialize with a closure handler over generic Input and Output types","    public init(body: @escaping (Event, LambdaContext) async throws -> Output) where Output: Encodable","    \/\/\/ Initialize with a closure handler over a generic Input type (Void Output).","    public init(body: @escaping (Event, LambdaContext) async throws -> Void) where Output == Void","    \/\/\/ The business logic of the Lambda function.","    public func handle(_ event: Event, context: LambdaContext) async throws -> Output","}"],"syntax":"swift"},{"inlineContent":[{"text":"Given that ","type":"text"},{"code":"ClosureHandler","type":"codeVoice"},{"type":"text","text":" conforms to "},{"code":"LambdaHandler","type":"codeVoice"},{"text":":","type":"text"}],"type":"paragraph"},{"type":"orderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"We can extend the "},{"type":"codeVoice","code":"LambdaRuntime"},{"text":" initializer such that it accepts a closure as an argument.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Within the initializer, the closure handler is wrapped with "},{"type":"codeVoice","code":"LambdaCodableAdapter"},{"type":"text","text":"."}]}]}]},{"code":["extension LambdaRuntime {","    \/\/\/ Initialize a LambdaRuntime with a closure handler over generic Event and Output types.","    \/\/\/ This initializer bolts on encoding\/decoding logic by wrapping the closure handler with","    \/\/\/ LambdaCodableAdapter.","    public init<Event: Decodable, Output: Encodable>(","        body: @escaping (Event, LambdaContext) async throws -> Output","    ) where Handler == LambdaCodableAdapter<ClosureHandler<Event, Output>, Event, Output, JSONDecoder, JSONEncoder>","","    \/\/\/ Same as above but for handlers with a void output","    public init<Event: Decodable>(","        body: @escaping (Event, LambdaContext) async throws -> Void","    ) where Handler == LambdaCodableAdapter<ClosureHandler<Event, Void>, Event, Void, JSONDecoder, VoidEncoder>","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"We can now significantly reduce the verbosity and leverage Swift’s trailing closure syntax to cleanly create and run a"},{"text":" ","type":"text"},{"type":"text","text":"Lambda function, abstracting away the decoding and encoding logic from the user:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["\/\/\/ The type the handler will use as input","struct Input: Decodable {","    var message: String","}","","\/\/\/ The type the handler will output","struct Greeting: Encodable {","    var echoedMessage: String","}","","\/\/\/ A simple Lambda function that echoes the input","let runtime = LambdaRuntime { (event: Input, context: LambdaContext) in","    Greeting(echoedMessage: event.message)","}","","try await runtime.run()"]},{"inlineContent":[{"text":"We also add a ","type":"text"},{"code":"StreamingClosureHandler","type":"codeVoice"},{"text":" conforming to ","type":"text"},{"type":"codeVoice","code":"StreamingLambdaHandler"},{"type":"text","text":" for use-cases where the user wants to"},{"type":"text","text":" "},{"type":"text","text":"handle encoding\/decoding themselves:"}],"type":"paragraph"},{"code":["public struct StreamingClosureHandler: StreamingLambdaHandler {","","    public init(","        body: @escaping sending (ByteBuffer, LambdaResponseStreamWriter, LambdaContext) async throws -> ()","    )","","    public func handle(","        _ request: ByteBuffer,","        responseWriter: LambdaResponseStreamWriter,","        context: LambdaContext","    ) async throws","}","","extension LambdaRuntime {","    public init(","        body: @escaping sending (ByteBuffer, LambdaResponseStreamWriter, LambdaContext) async throws -> ()","    )","}"],"type":"codeListing","syntax":"swift"},{"type":"heading","anchor":"Alternatives-considered","level":2,"text":"Alternatives considered"},{"type":"heading","text":"[UInt8] instead of ByteBuffer","level":3,"anchor":"UInt8-instead-of-ByteBuffer"},{"inlineContent":[{"type":"text","text":"We considered using "},{"code":"[UInt8]","type":"codeVoice"},{"text":" instead of ","type":"text"},{"type":"codeVoice","code":"ByteBuffer"},{"text":" in the base ","type":"text"},{"type":"codeVoice","code":"LambdaHandler"},{"type":"text","text":" API. We decided to use "},{"code":"ByteBuffer","type":"codeVoice"},{"text":" ","type":"text"},{"type":"text","text":"for two reasons."}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"99% of use-cases will use the JSON codable API and will not directly get in touch with ByteBuffer anyway. For those"},{"type":"text","text":" "},{"type":"text","text":"users it does not matter if the base API uses "},{"type":"codeVoice","code":"ByteBuffer"},{"text":" or ","type":"text"},{"type":"codeVoice","code":"[UInt8]"},{"type":"text","text":"."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The incoming and outgoing data must be in the "},{"code":"ByteBuffer","type":"codeVoice"},{"text":" format anyway, as Lambda uses SwiftNIO under the hood and","type":"text"},{"type":"text","text":" "},{"type":"text","text":"SwiftNIO uses "},{"code":"ByteBuffer","type":"codeVoice"},{"type":"text","text":" in its APIs. By using "},{"type":"codeVoice","code":"ByteBuffer"},{"text":" we can save a copies to and from ","type":"text"},{"type":"codeVoice","code":"[UInt8]"},{"type":"text","text":". This will"},{"type":"text","text":" "},{"text":"reduce the invocation time for all users.","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"The base "},{"type":"codeVoice","code":"LambdaHandler"},{"text":" API is most likely mainly being used by developers that want to integrate their web","type":"text"},{"type":"text","text":" "},{"text":"framework with Lambda (examples: Vapor, Hummingbird, …). Those developers will most likely prefer to get the data","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"in the "},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":" format anyway, as their lower level networking stack also depends on SwiftNIO."}],"type":"paragraph"}]}],"type":"orderedList"},{"text":"Users create a LambdaResponse, that supports streaming instead of being passed a LambdaResponseStreamWriter","level":3,"anchor":"Users-create-a-LambdaResponse-that-supports-streaming-instead-of-being-passed-a-LambdaResponseStreamWriter","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Instead of passing the "},{"code":"LambdaResponseStreamWriter","type":"codeVoice"},{"type":"text","text":" in the invocation we considered a new type "},{"type":"codeVoice","code":"LambdaResponse"},{"type":"text","text":", that"},{"type":"text","text":" "},{"text":"users must return in the ","type":"text"},{"type":"codeVoice","code":"StreamingLambdaHandler"},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Its API would look like this:","type":"text"}]},{"syntax":"swift","code":["\/\/\/ A response returned from a ``LambdaHandler``.","\/\/\/ The response can be empty, a single ByteBuffer or a response stream.","public struct LambdaResponse {","    \/\/\/ A writer to be used when creating a streamed response.","    public struct Writer {","        \/\/\/ Writes data to the response stream","        public func write(_ byteBuffer: ByteBuffer) async throws","        \/\/\/ Closes off the response stream","        public func finish() async throws","        \/\/\/ Writes the `byteBuffer` to the response stream and subsequently closes the stream","        public func writeAndFinish(_ byteBuffer: ByteBuffer) async throws","    }","","    \/\/\/ Creates an empty lambda response","    public init()","","    \/\/\/ Creates a LambdaResponse with a fixed ByteBuffer.","    public init(_ byteBuffer: ByteBuffer)","","    \/\/\/ Creates a streamed lambda response. Use the ``Writer`` to send","    \/\/\/ response chunks on the stream.","    public init(_ stream: @escaping sending (Writer) async throws -> ())","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"StreamingLambdaHandler"},{"type":"text","text":" would look like this:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["\/\/\/ The base LambdaHandler protocol","public protocol StreamingLambdaHandler {","    \/\/\/ The business logic of the Lambda function","    \/\/\/ - Parameters:","    \/\/\/   - event: The invocation's input data","    \/\/\/   - context: The LambdaContext containing the invocation's metadata","    \/\/\/ - Returns: A LambdaResponse, that can be streamed","    mutating func handle(","        _ event: ByteBuffer,","        context: LambdaContext","    ) async throws -> LambdaResponse","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"There are pros and cons for the API that returns the "},{"type":"codeVoice","code":"LambdaResponses"},{"type":"text","text":" and there are pros and cons for the API that"},{"type":"text","text":" "},{"type":"text","text":"receives a "},{"code":"LambdaResponseStreamWriter","type":"codeVoice"},{"type":"text","text":" as a parameter."}]},{"type":"paragraph","inlineContent":[{"text":"Concerning following structured concurrency principles the approach that receives a ","type":"text"},{"code":"LambdaResponseStreamWriter","type":"codeVoice"},{"type":"text","text":" as a"},{"text":" ","type":"text"},{"type":"text","text":"parameter has benefits as the lifetime of the handle function is tied to the invocation runtime. The approach that"},{"type":"text","text":" "},{"text":"returns a ","type":"text"},{"code":"LambdaResponse","type":"codeVoice"},{"text":" splits the invocation into two separate function calls. First the handle method is invoked,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"second the "},{"type":"codeVoice","code":"LambdaResponse"},{"type":"text","text":" writer closure is invoked. This means that it is impossible to use Swift APIs that use"},{"text":" ","type":"text"},{"type":"codeVoice","code":"with"},{"text":" style lifecycle management patterns from before creating the response until sending the full response stream off.","type":"text"},{"text":" ","type":"text"},{"text":"For example, users instrumenting their lambdas with Swift tracing likely can not use the ","type":"text"},{"code":"withSpan","type":"codeVoice"},{"text":" API for the full","type":"text"},{"type":"text","text":" "},{"text":"lifetime of the request, if they return a streamed response.","type":"text"}]},{"inlineContent":[{"text":"However, if it comes to consistency with the larger Swift on server ecosystem, the API that returns a ","type":"text"},{"type":"codeVoice","code":"LambdaResponse"},{"text":" ","type":"text"},{"type":"text","text":"is likely the better choice. Hummingbird v2, OpenAPI and the new Swift gRPC v2 implementation all use this approach."},{"text":" ","type":"text"},{"type":"text","text":"This might be due to the fact that writing middleware becomes easier, if a Response is explicitly returned."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"We decided to implement the approach in which a "},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"text":" is passed to the function, since the","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"approach in which a "},{"type":"codeVoice","code":"LambdaResponse"},{"type":"text","text":" is returned can trivially be built on top of it. This is not true vice versa."}]},{"inlineContent":[{"type":"text","text":"We welcome the discussion on this topic and are open to change our minds and API here."}],"type":"paragraph"},{"type":"heading","level":3,"text":"Adding a function `addBackgroundTask(_ body: sending @escaping () async -> ())` in `LambdaContext`","anchor":"Adding-a-function-addBackgroundTask-body-sending-escaping--async-%3E--in-LambdaContext"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Initially we proposed an explicit "},{"type":"codeVoice","code":"addBackgroundTask(_:)"},{"text":" function in ","type":"text"},{"code":"LambdaContext","type":"codeVoice"},{"type":"text","text":" that users could call from their"},{"type":"text","text":" "},{"type":"text","text":"handler object to schedule a background task to be run after the result is reported to AWS. We received feedback that"},{"type":"text","text":" "},{"text":"this approach for supporting background tasks does not exhibit structured concurrency, as code could still be in","type":"text"},{"text":" ","type":"text"},{"text":"execution after leaving the scope of the ","type":"text"},{"code":"handle(...)","type":"codeVoice"},{"type":"text","text":" function."}]},{"inlineContent":[{"type":"text","text":"For handlers conforming to the "},{"type":"codeVoice","code":"StreamingLambdaHandler"},{"type":"text","text":", "},{"type":"codeVoice","code":"addBackgroundTask(_:)"},{"type":"text","text":" was anyways unnecessary as background"},{"text":" ","type":"text"},{"type":"text","text":"work could be executed in a structured concurrency manner within the "},{"type":"codeVoice","code":"handle(...)"},{"type":"text","text":" function after the call to"},{"type":"text","text":" "},{"type":"codeVoice","code":"LambdaResponseStreamWriter.finish()"},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"For handlers conforming to the "},{"type":"codeVoice","code":"LambdaHandler"},{"type":"text","text":" protocol, we considered extending "},{"type":"codeVoice","code":"LambdaHandler"},{"type":"text","text":" with a"},{"type":"text","text":" "},{"type":"codeVoice","code":"performPostHandleWork(...)"},{"text":" function that will be called after the ","type":"text"},{"code":"handle","type":"codeVoice"},{"type":"text","text":" function by the library. Users wishing to"},{"type":"text","text":" "},{"type":"text","text":"add background work can override this function in their "},{"code":"LambdaHandler","type":"codeVoice"},{"type":"text","text":" conforming object."}],"type":"paragraph"},{"code":["public protocol LambdaHandler {","    associatedtype Event","    associatedtype Output","","    func handle(_ event: Event, context: LambdaContext) async throws -> Output","","    func performPostHandleWork(...) async throws -> Void","}","","extension LambdaHandler {","    \/\/ User's can override this function if they wish to perform background work","    \/\/ after returning a response from ``handle``.","    func performPostHandleWork(...) async throws -> Void {","        \/\/ nothing to do","    }","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"Yet this poses difficulties when the user wishes to use any state created in the "},{"code":"handle(...)","type":"codeVoice"},{"text":" function as part of the","type":"text"},{"type":"text","text":" "},{"type":"text","text":"background work."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"In general, the most common use-case for this library will be to implement simple Lambda functions that do not have"},{"text":" ","type":"text"},{"type":"text","text":"requirements for response streaming, nor to perform any background work after returning the output. To keep things easy"},{"type":"text","text":" "},{"type":"text","text":"for the common use-case, and with Swift’s principle of progressive disclosure of complexity in mind, we settled on three"},{"type":"text","text":" "},{"text":"handler protocols:","type":"text"}],"type":"paragraph"},{"type":"orderedList","items":[{"content":[{"inlineContent":[{"type":"codeVoice","code":"LambdaHandler"},{"type":"text","text":": Most common use-case. JSON-in, JSON-out. Does not support background work execution. An intuitive"},{"type":"text","text":" "},{"code":"handle(event: Event, context: LambdaContext) -> Output","type":"codeVoice"},{"text":" API that is simple to understand, i.e. users are not exposed","type":"text"},{"type":"text","text":" "},{"text":"to the concept of sending their response through a writer. ","type":"text"},{"code":"LambdaHandler","type":"codeVoice"},{"type":"text","text":" can be very cleanly implemented and used"},{"type":"text","text":" "},{"text":"with ","type":"text"},{"code":"LambdaRuntime","type":"codeVoice"},{"type":"text","text":", especially with "},{"type":"codeVoice","code":"ClosureHandler"},{"type":"text","text":"."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"code":"LambdaWithBackgroundProcessingHandler","type":"codeVoice"},{"text":": If users wish to augment their ","type":"text"},{"code":"LambdaHandler","type":"codeVoice"},{"text":" with the ability to run","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"background tasks, they can easily migrate. A user simply has to:"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Change the conformance to ","type":"text"},{"type":"codeVoice","code":"LambdaWithBackgroundProcessingHandler"},{"type":"text","text":"."}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Add an additional "},{"type":"codeVoice","code":"outputWriter: some LambdaResponseWriter<Output>"},{"text":" argument to the ","type":"text"},{"type":"codeVoice","code":"handle"},{"text":" function.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Replace the "},{"type":"codeVoice","code":"return ..."},{"text":" with ","type":"text"},{"code":"outputWriter.write(...)","type":"codeVoice"},{"text":".","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Implement any background work after "},{"code":"outputWriter.write(...)","type":"codeVoice"},{"text":".","type":"text"}]}]}],"type":"orderedList"}]},{"content":[{"inlineContent":[{"code":"StreamingLambdaHandler","type":"codeVoice"},{"type":"text","text":": This is the base handler protocol which is intended to be used directly only for advanced"},{"type":"text","text":" "},{"type":"text","text":"use-cases. Users are provided the invocation event as a "},{"code":"ByteBuffer","type":"codeVoice"},{"text":" and a ","type":"text"},{"code":"LambdaResponseStreamWriter","type":"codeVoice"},{"text":" where the","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"computed result (as "},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":") can either be streamed (with repeated calls to "},{"type":"codeVoice","code":"write(_:)"},{"text":") or sent all at once","type":"text"},{"text":" ","type":"text"},{"text":"(with a single call to ","type":"text"},{"type":"codeVoice","code":"writeAndFinish(_:)"},{"type":"text","text":"). After closing the "},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"text":", any background work can","type":"text"},{"type":"text","text":" "},{"type":"text","text":"be implemented."}],"type":"paragraph"}]}]},{"text":"Making LambdaResponseStreamWriter and LambdaResponseWriter ~Copyable","anchor":"Making-LambdaResponseStreamWriter-and-LambdaResponseWriter-~Copyable","level":3,"type":"heading"},{"inlineContent":[{"type":"text","text":"We initially proposed to make the "},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"text":" and ","type":"text"},{"code":"LambdaResponseWriter","type":"codeVoice"},{"type":"text","text":" protocols "},{"code":"~Copyable","type":"codeVoice"},{"type":"text","text":", with"},{"type":"text","text":" "},{"text":"the functions that close the response having the ","type":"text"},{"type":"codeVoice","code":"consuming"},{"text":" ownership keyword. This was so that the compiler could","type":"text"},{"type":"text","text":" "},{"type":"text","text":"enforce the restriction of not being able to interact with the writer after the response stream has closed."}],"type":"paragraph"},{"inlineContent":[{"text":"However, non-copyable types do not compose nicely and add complexity for users. Further, for the compiler to actually","type":"text"},{"text":" ","type":"text"},{"text":"enforce the ","type":"text"},{"code":"consuming","type":"codeVoice"},{"text":" restrictions, user’s have to explicitly mark the writer argument as ","type":"text"},{"type":"codeVoice","code":"consuming"},{"text":" in the ","type":"text"},{"code":"handle","type":"codeVoice"},{"text":" ","type":"text"},{"type":"text","text":"function."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Therefore, throwing appropriate errors to prevent abnormal interaction with the writers seems to be the simplest"},{"text":" ","type":"text"},{"type":"text","text":"approach."}]},{"type":"heading","anchor":"A-word-about-versioning","text":"A word about versioning","level":2},{"inlineContent":[{"text":"We are aware that AWS Lambda Runtime has not reached a proper 1.0. We intend to keep the current implementation around","type":"text"},{"type":"text","text":" "},{"type":"text","text":"at 1.0-alpha. We don’t want to change the current API without releasing a new major. We think there are lots of adopters"},{"type":"text","text":" "},{"type":"text","text":"out there that depend on the API in v1. Because of this we intend to release the proposed API here as AWS Lambda Runtime"},{"text":" ","type":"text"},{"type":"text","text":"v2."}],"type":"paragraph"}]}],"abstract":[{"type":"codeVoice","code":"swift-aws-lambda-runtime"},{"text":" is an important library for the Swift on Server ecosystem. The initial API was written before","type":"text"},{"text":" ","type":"text"},{"text":"async\/await was introduced to Swift. When async\/await was introduced, shims were added to bridge between the underlying","type":"text"},{"text":" ","type":"text"},{"text":"SwiftNIO ","type":"text"},{"code":"EventLoop","type":"codeVoice"},{"type":"text","text":" interfaces and async\/await. However, just like "},{"type":"codeVoice","code":"gRPC-swift"},{"type":"text","text":" and "},{"type":"codeVoice","code":"postgres-nio"},{"type":"text","text":", we now want to"},{"text":" ","type":"text"},{"type":"text","text":"shift to solely using async\/await instead of "},{"type":"codeVoice","code":"EventLoop"},{"type":"text","text":" interfaces. For this, large parts of the current API have to be"},{"text":" ","type":"text"},{"text":"reconsidered.","type":"text"}],"sections":[],"kind":"article","metadata":{"roleHeading":"Article","modules":[{"name":"AWSLambdaRuntimeCore"}],"role":"article","title":"v2 API proposal for swift-aws-lambda-runtime"},"schemaVersion":{"minor":3,"patch":0,"major":0},"references":{"doc://AWSLambdaRuntimeCore/documentation/AWSLambdaRuntimeCore":{"url":"\/documentation\/awslambdaruntimecore","abstract":[{"type":"text","text":"An AWS Lambda runtime for the Swift programming language"}],"role":"collection","title":"AWSLambdaRuntimeCore","type":"topic","identifier":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore","kind":"symbol"},"https://github.com/swift-server/swift-aws-lambda-runtime/issues/265":{"titleInlineContent":[{"text":"set up global properties before the Lambda starts-up","type":"text"}],"type":"link","identifier":"https:\/\/github.com\/swift-server\/swift-aws-lambda-runtime\/issues\/265","url":"https:\/\/github.com\/swift-server\/swift-aws-lambda-runtime\/issues\/265","title":"set up global properties before the Lambda starts-up"},"https://aws.amazon.com/blogs/compute/running-code-after-returning-a-response-from-an-aws-lambda-function/":{"titleInlineContent":[{"type":"text","text":"AWS described in a blog post that you can run background tasks in Lambda"}],"type":"link","identifier":"https:\/\/aws.amazon.com\/blogs\/compute\/running-code-after-returning-a-response-from-an-aws-lambda-function\/","url":"https:\/\/aws.amazon.com\/blogs\/compute\/running-code-after-returning-a-response-from-an-aws-lambda-function\/","title":"AWS described in a blog post that you can run background tasks in Lambda"},"https://docs.aws.amazon.com/lambda/latest/dg/runtimes-custom.html":{"titleInlineContent":[{"text":"Building a custom runtime for AWS Lambda","type":"text"}],"type":"link","identifier":"https:\/\/docs.aws.amazon.com\/lambda\/latest\/dg\/runtimes-custom.html","url":"https:\/\/docs.aws.amazon.com\/lambda\/latest\/dg\/runtimes-custom.html","title":"Building a custom runtime for AWS Lambda"},"https://aws.amazon.com/blogs/compute/introducing-aws-lambda-response-streaming/":{"titleInlineContent":[{"type":"text","text":"AWS introduced support for response streaming"}],"type":"link","identifier":"https:\/\/aws.amazon.com\/blogs\/compute\/introducing-aws-lambda-response-streaming\/","url":"https:\/\/aws.amazon.com\/blogs\/compute\/introducing-aws-lambda-response-streaming\/","title":"AWS introduced support for response streaming"},"https://docs.aws.amazon.com/lambda/latest/dg/runtimes-api.html#runtimes-api-initerror":{"titleInlineContent":[{"text":"errors that occur during initialization to the dedicated endpoint AWS exposes","type":"text"}],"type":"link","identifier":"https:\/\/docs.aws.amazon.com\/lambda\/latest\/dg\/runtimes-api.html#runtimes-api-initerror","url":"https:\/\/docs.aws.amazon.com\/lambda\/latest\/dg\/runtimes-api.html#runtimes-api-initerror","title":"errors that occur during initialization to the dedicated endpoint AWS exposes"}}}