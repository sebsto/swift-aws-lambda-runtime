{"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","text":"Overview","level":2,"type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Versions:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"v1 (2024-08-07): Initial version"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"v1.1:"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Remove the ","type":"text"},{"type":"codeVoice","code":"reportError(_:)"},{"type":"text","text":" method from "},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"text":" and instead make the ","type":"text"},{"type":"codeVoice","code":"handle(...)"},{"type":"text","text":" method of"},{"text":" ","type":"text"},{"code":"StreamingLambdaHandler","type":"codeVoice"},{"type":"text","text":" throwing."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Remove the ","type":"text"},{"type":"codeVoice","code":"addBackgroundTask(_:)"},{"text":" method from ","type":"text"},{"type":"codeVoice","code":"LambdaContext"},{"type":"text","text":" due to structured concurrency concerns and introduce"},{"type":"text","text":" "},{"text":"the ","type":"text"},{"code":"LambdaWithBackgroundProcessingHandler","type":"codeVoice"},{"type":"text","text":" protocol as a solution."}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"Introduce "},{"type":"codeVoice","code":"LambdaHandlerAdapter"},{"type":"text","text":", which adapts handlers conforming to "},{"type":"codeVoice","code":"LambdaHandler"},{"type":"text","text":" with"},{"type":"text","text":" "},{"code":"LambdaWithBackgroundProcessingHandler","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Update ","type":"text"},{"type":"codeVoice","code":"LambdaCodableAdapter"},{"type":"text","text":" to now be generic over any handler conforming to"},{"type":"text","text":" "},{"code":"LambdaWithBackgroundProcessingHandler","type":"codeVoice"},{"type":"text","text":" instead of "},{"type":"codeVoice","code":"LambdaHandler"},{"type":"text","text":"."}]}]}]}]}],"type":"unorderedList"}]},{"content":[{"inlineContent":[{"text":"v1.2:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"Remove "},{"type":"codeVoice","code":"~Copyable"},{"text":" from ","type":"text"},{"code":"LambdaResponseStreamWriter","type":"codeVoice"},{"type":"text","text":" and "},{"type":"codeVoice","code":"LambdaResponseWriter"},{"text":". Instead throw an error when","type":"text"},{"text":" ","type":"text"},{"code":"finish()","type":"codeVoice"},{"type":"text","text":" is called multiple times or when "},{"code":"write","type":"codeVoice"},{"type":"text","text":"\/"},{"type":"codeVoice","code":"writeAndFinish"},{"type":"text","text":" is called after "},{"type":"codeVoice","code":"finish()"},{"type":"text","text":"."}],"type":"paragraph"}]}],"type":"unorderedList"}]}]},{"type":"heading","level":2,"text":"Motivation","anchor":"Motivation"},{"level":3,"text":"Current Limitations","type":"heading","anchor":"Current-Limitations"},{"text":"EventLoop interfaces","level":4,"type":"heading","anchor":"EventLoop-interfaces"},{"inlineContent":[{"type":"text","text":"The current API extensively uses the "},{"code":"EventLoop","type":"codeVoice"},{"type":"text","text":" family of interfaces from SwiftNIO in many areas. To use these"},{"text":" ","type":"text"},{"type":"text","text":"interfaces correctly though, it requires developers to exercise great care and understand the various transform methods"},{"type":"text","text":" "},{"type":"text","text":"that are used to work with "},{"code":"EventLoop","type":"codeVoice"},{"text":"s and ","type":"text"},{"type":"codeVoice","code":"EventLoopFuture"},{"type":"text","text":"s. This results in a lot of cognitive complexity and makes"},{"type":"text","text":" "},{"type":"text","text":"the code in the current API hard to reason about and maintain. For these reasons, the overarching trend in the Swift on"},{"type":"text","text":" "},{"type":"text","text":"Server ecosystem is to shift to newer, more readable, Swift concurrency constructs and de-couple from SwiftNIO’s"},{"text":" ","type":"text"},{"code":"EventLoop","type":"codeVoice"},{"type":"text","text":" interfaces."}],"type":"paragraph"},{"anchor":"No-ownership-of-the-main-function","text":"No ownership of the main() function","level":4,"type":"heading"},{"inlineContent":[{"type":"text","text":"A Lambda function can currently be implemented through conformance to the various handler protocols defined in"},{"text":" ","type":"text"},{"type":"codeVoice","code":"AWSLambdaRuntimeCore\/LambdaHandler"},{"type":"text","text":". Each of these protocols have an extension which implements a "},{"type":"codeVoice","code":"static func main()"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"This allows users to annotate their "},{"type":"codeVoice","code":"LambdaHandler"},{"text":" conforming object with ","type":"text"},{"type":"codeVoice","code":"@main"},{"type":"text","text":". The "},{"code":"static func main()","type":"codeVoice"},{"type":"text","text":" calls the"},{"type":"text","text":" "},{"text":"internal ","type":"text"},{"code":"Lambda.run()","type":"codeVoice"},{"type":"text","text":" function, which starts the Lambda function. Since the "},{"code":"Lambda.run()","type":"codeVoice"},{"type":"text","text":" method is internal, users"},{"text":" ","type":"text"},{"type":"text","text":"cannot override the default implementation. This has proven challenging for users who want to"},{"type":"text","text":" "},{"isActive":true,"type":"reference","identifier":"https:\/\/github.com\/swift-server\/swift-aws-lambda-runtime\/issues\/265"},{"type":"text","text":"."},{"text":" ","type":"text"},{"text":"Setting up global properties is required to customize the Swift Logging, Metric and Tracing backend.","type":"text"}],"type":"paragraph"},{"type":"heading","level":4,"text":"Non-trivial transition from SimpleLambdaHandler to LambdaHandler","anchor":"Non-trivial-transition-from-SimpleLambdaHandler-to-LambdaHandler"},{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"SimpleLambdaHandler"},{"type":"text","text":" protocol provides a quick and easy way to implement a basic Lambda function. It only requires"},{"text":" ","type":"text"},{"type":"text","text":"an implementation of the "},{"type":"codeVoice","code":"handle"},{"type":"text","text":" function where the business logic of the Lambda function can be written."},{"text":" ","type":"text"},{"type":"codeVoice","code":"SimpleLambdaHandler"},{"type":"text","text":" is perfectly sufficient for small use-cases as the user does not need to spend much time looking"},{"type":"text","text":" "},{"type":"text","text":"into the library."}],"type":"paragraph"},{"inlineContent":[{"text":"However, ","type":"text"},{"code":"SimpleLambdaHandler","type":"codeVoice"},{"text":" cannot be used when services such as a database client need to be initialized before the","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"Lambda runtime starts and then also gracefully shutdown prior to the runtime terminating. This is because the only way"},{"text":" ","type":"text"},{"type":"text","text":"to register termination logic is through the "},{"type":"codeVoice","code":"LambdaInitializationContext"},{"text":" (containing a field","type":"text"},{"text":" ","type":"text"},{"type":"codeVoice","code":"terminator: LambdaTerminator"},{"text":") which is created and used ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"internally","type":"text"}]},{"type":"text","text":" within "},{"type":"codeVoice","code":"LambdaRuntime"},{"type":"text","text":" and never exposed through"},{"type":"text","text":" "},{"code":"SimpleLambdaHandler","type":"codeVoice"},{"type":"text","text":". For such use-cases, other handler protocols like "},{"code":"LambdaHandler","type":"codeVoice"},{"type":"text","text":" must be used. "},{"type":"codeVoice","code":"LambdaHandler"},{"type":"text","text":" "},{"text":"exposes a ","type":"text"},{"code":"context","type":"codeVoice"},{"type":"text","text":" argument of type "},{"type":"codeVoice","code":"LambdaInitializationContext"},{"type":"text","text":" through its initializer. Within the initializer,"},{"type":"text","text":" "},{"type":"text","text":"required services can be initialized and their graceful shutdown logic can be registered with the"},{"text":" ","type":"text"},{"code":"context.terminator.register","type":"codeVoice"},{"type":"text","text":" function."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Yet, "},{"type":"codeVoice","code":"LambdaHandler"},{"text":" is quite cumbersome to use in such use-cases as users have to deviate from the established norms of","type":"text"},{"type":"text","text":" "},{"text":"the Swift on Server ecosystem in order to cleanly manage the lifecycle of the services intended to be used. This is","type":"text"},{"type":"text","text":" "},{"type":"text","text":"because the convenient "},{"code":"swift-service-lifecycle","type":"codeVoice"},{"type":"text","text":" v2 library — which is commonly used for cleanly managing the lifecycles"},{"type":"text","text":" "},{"type":"text","text":"of required services and widely supported by many libraries — cannot be used in a structured concurrency manner."}],"type":"paragraph"},{"level":4,"anchor":"Does-not-integrate-well-with-swift-service-lifecycle-in-a-structured-concurrency-manner","type":"heading","text":"Does not integrate well with swift-service-lifecycle in a structured concurrency manner"},{"inlineContent":[{"type":"text","text":"The Lambda runtime can only be started using the "},{"type":"strong","inlineContent":[{"text":"internal","type":"text"}]},{"text":" ","type":"text"},{"type":"codeVoice","code":"Lambda.run()"},{"text":" function. This function is called by the","type":"text"},{"type":"text","text":" "},{"code":"main()","type":"codeVoice"},{"text":" function defined by the ","type":"text"},{"type":"codeVoice","code":"LambdaHandler"},{"text":" protocol, preventing users from injecting initialized services into the","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"runtime "},{"type":"emphasis","inlineContent":[{"text":"prior","type":"text"}]},{"text":" to it starting. As shown below, this forces users to use an ","type":"text"},{"inlineContent":[{"type":"text","text":"unstructured concurrency"}],"type":"strong"},{"text":" approach and","type":"text"},{"type":"text","text":" "},{"type":"text","text":"manually initialize services, leading to the issue of the user then perhaps forgetting to gracefully shutdown the"},{"type":"text","text":" "},{"text":"initialized services:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["struct MyLambda: LambdaHandler {","    let pgClient: PostgresClient","","    init(context: AWSLambdaRuntimeCore.LambdaInitializationContext) async throws {","        \/\/\/ Instantiate service","        let client = PostgresClient(configuration: ...)","","        \/\/\/ Unstructured concurrency to initialize the service","        let pgTask = Task {","            await client.run()","        }","","        \/\/\/ Store the client in `self` so that it can be used in `handle(...)`","        self.pgClient = client","","        \/\/\/ !!! Must remember to explicitly register termination logic for PostgresClient !!!","        context.terminator.register(","           name: \"PostgreSQL Client\",","           handler: { eventLoop in","               pgTask.cancel()","               return eventLoop.makeFutureWithTask {","                  await pgTask.value","               }","           }","        )","    }","","    func handle(_ event: Event, context: LambdaContext) async throws -> Output {","        \/\/\/ Use the initialized service stored in `self.pgClient`","        try await self.pgClient.query(...)","    }","}"]},{"level":4,"type":"heading","anchor":"Verbose-Codable-support","text":"Verbose Codable support"},{"inlineContent":[{"text":"In the current API, there are extensions and Codable wrapper classes for decoding events and encoding computed responses","type":"text"},{"type":"text","text":" "},{"type":"text","text":"for "},{"type":"emphasis","inlineContent":[{"type":"text","text":"each"}]},{"text":" different handler protocol and for both ","type":"text"},{"type":"codeVoice","code":"String"},{"type":"text","text":" and "},{"code":"JSON","type":"codeVoice"},{"text":" formats. This has resulted in a lot of","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"boilerplate code which can very easily be made generic and simplified in v2."}],"type":"paragraph"},{"level":3,"anchor":"New-features","type":"heading","text":"New features"},{"type":"heading","anchor":"Support-response-streaming","level":4,"text":"Support response streaming"},{"type":"paragraph","inlineContent":[{"text":"In April 2023","type":"text"},{"type":"text","text":" "},{"identifier":"https:\/\/aws.amazon.com\/blogs\/compute\/introducing-aws-lambda-response-streaming\/","isActive":true,"type":"reference"},{"text":" ","type":"text"},{"text":"in Lambda. The current API does not support streaming. For v2 we want to change this.","type":"text"}]},{"text":"Scheduling background work","anchor":"Scheduling-background-work","level":4,"type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In May"},{"type":"text","text":" "},{"isActive":true,"identifier":"https:\/\/aws.amazon.com\/blogs\/compute\/running-code-after-returning-a-response-from-an-aws-lambda-function\/","type":"reference"},{"text":" ","type":"text"},{"text":"until the runtime asks for more work from the control plane. We want to support this by adding new API that allows","type":"text"},{"text":" ","type":"text"},{"text":"background processing, even after the response has been returned.","type":"text"}]},{"text":"Proposed Solution","type":"heading","anchor":"Proposed-Solution","level":2},{"type":"heading","level":3,"text":"async\/await-first API","anchor":"asyncawait-first-API"},{"type":"paragraph","inlineContent":[{"text":"Large parts of ","type":"text"},{"code":"Lambda","type":"codeVoice"},{"type":"text","text":", "},{"type":"codeVoice","code":"LambdaHandler"},{"type":"text","text":", and "},{"type":"codeVoice","code":"LambdaRuntime"},{"type":"text","text":" will be re-written to use async\/await constructs in place"},{"text":" ","type":"text"},{"text":"of the ","type":"text"},{"type":"codeVoice","code":"EventLoop"},{"type":"text","text":" family of interfaces."}]},{"anchor":"Providing-ownership-of-main-and-support-for-swift-service-lifecycle","type":"heading","text":"Providing ownership of main() and support for swift-service-lifecycle","level":3},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"Instead of conforming to a handler protocol, users can now create a "},{"code":"LambdaRuntime","type":"codeVoice"},{"type":"text","text":" by passing in a handler closure."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"codeVoice","code":"LambdaRuntime"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"ServiceLifecycle.Service"},{"type":"text","text":" by implementing a "},{"type":"codeVoice","code":"run()"},{"type":"text","text":" method that contains initialization"},{"type":"text","text":" "},{"text":"and graceful shutdown logic.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"This allows the lifecycle of the "},{"code":"LambdaRuntime","type":"codeVoice"},{"text":" to be managed with ","type":"text"},{"code":"swift-service-lifecycle","type":"codeVoice"},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"alongside","type":"text"}]},{"text":" and in the","type":"text"},{"type":"text","text":" "},{"text":"same way the lifecycles of the required services are managed, e.g.","type":"text"},{"text":" ","type":"text"},{"code":"try await ServiceGroup(services: [postgresClient, ..., lambdaRuntime], ...).run()","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Dependencies can now be injected into "},{"code":"LambdaRuntime","type":"codeVoice"},{"text":". With ","type":"text"},{"type":"codeVoice","code":"swift-service-lifecycle"},{"type":"text","text":", services will be initialized"},{"type":"text","text":" "},{"text":"together with ","type":"text"},{"type":"codeVoice","code":"LambdaRuntime"},{"type":"text","text":"."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"The required services can then be used within the handler in a structured concurrency manner.","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"swift-service-lifecycle"},{"type":"text","text":" takes care of listening for termination signals and terminating the services as well as the"},{"type":"text","text":" "},{"code":"LambdaRuntime","type":"codeVoice"},{"type":"text","text":" in correct order."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"LambdaTerminator"},{"text":" can now be eliminated because its role is replaced with ","type":"text"},{"code":"swift-service-lifecycle","type":"codeVoice"},{"text":". The termination","type":"text"},{"type":"text","text":" "},{"text":"logic of the Lambda function will be implemented in the conforming ","type":"text"},{"code":"run()","type":"codeVoice"},{"text":" function of ","type":"text"},{"type":"codeVoice","code":"LambdaRuntime"},{"type":"text","text":"."}]}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"text":"With this, the earlier code snippet can be replaced with something much easier to read, maintain, and debug:","type":"text"}]},{"syntax":"swift","code":["\/\/\/ Instantiate services","let postgresClient = PostgresClient()","","\/\/\/ Instantiate LambdaRuntime with a closure handler implementing the business logic of the Lambda function","let runtime = LambdaRuntime { (event: Input, context: LambdaContext) in","    \/\/\/ Use initialized service within the handler","    try await postgresClient.query(...)","}","","\/\/\/ Use ServiceLifecycle to manage the initialization and termination","\/\/\/ of the services as well as the LambdaRuntime","let serviceGroup = ServiceGroup(","    services: [postgresClient, runtime],","    configuration: .init(gracefulShutdownSignals: [.sigterm]),","    logger: logger",")","try await serviceGroup.run()"],"type":"codeListing"},{"anchor":"Simplifying-Codable-support","text":"Simplifying Codable support","type":"heading","level":3},{"inlineContent":[{"text":"A detailed explanation is provided in the ","type":"text"},{"type":"strong","inlineContent":[{"type":"text","text":"Codable Support"}]},{"text":" section. In short, much of the boilerplate code defined","type":"text"},{"type":"text","text":" "},{"type":"text","text":"for each handler protocol in "},{"type":"codeVoice","code":"Lambda+Codable"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Lambda+String"},{"type":"text","text":" will be replaced with a single "},{"code":"LambdaCodableAdapter","type":"codeVoice"},{"type":"text","text":" "},{"type":"text","text":"struct."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This adapter struct is generic over (1) any handler conforming to a new handler protocol"},{"text":" ","type":"text"},{"code":"LambdaWithBackgroundProcessingHandler","type":"codeVoice"},{"type":"text","text":", (2) the user-specified input and output types, and (3) any decoder and encoder"},{"type":"text","text":" "},{"text":"conforming to protocols ","type":"text"},{"type":"codeVoice","code":"LambdaEventDecoder"},{"type":"text","text":" and "},{"type":"codeVoice","code":"LambdaOutputDecoder"},{"text":". The adapter will wrap the underlying handler","type":"text"},{"type":"text","text":" "},{"text":"with encoding\/decoding logic.","type":"text"}]},{"anchor":"Detailed-Solution","text":"Detailed Solution","level":2,"type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Below are explanations for all types that we want to use in AWS Lambda Runtime v2."}]},{"text":"LambdaResponseStreamWriter","type":"heading","anchor":"LambdaResponseStreamWriter","level":3},{"inlineContent":[{"type":"text","text":"We will introduce a new "},{"code":"LambdaResponseStreamWriter","type":"codeVoice"},{"type":"text","text":" protocol. It is used in the new "},{"type":"codeVoice","code":"StreamingLambdaHandler"},{"type":"text","text":" (defined"},{"type":"text","text":" "},{"type":"text","text":"below), which is the new base protocol for the "},{"type":"codeVoice","code":"LambdaRuntime"},{"text":" (defined below as well).","type":"text"}],"type":"paragraph"},{"code":["\/\/\/ A writer object to write the Lambda response stream into","public protocol LambdaResponseStreamWriter {","    \/\/\/ Write a response part into the stream. The HTTP response is started lazily before the first call to `write(_:)`.","    \/\/\/ Bytes written to the writer are streamed continually.","    func write(_ buffer: ByteBuffer) async throws","    \/\/\/ End the response stream and the underlying HTTP response.","    func finish() async throws","    \/\/\/ Write a response part into the stream and end the response stream as well as the underlying HTTP response.","    func writeAndFinish(_ buffer: ByteBuffer) async throws","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"If the user does not call ","type":"text"},{"type":"codeVoice","code":"finish()"},{"type":"text","text":", the library will automatically finish the stream after the last "},{"code":"write","type":"codeVoice"},{"type":"text","text":"."},{"text":" ","type":"text"},{"text":"Appropriate errors will be thrown if ","type":"text"},{"code":"finish()","type":"codeVoice"},{"text":" is called multiple times, or if ","type":"text"},{"type":"codeVoice","code":"write"},{"type":"text","text":"\/"},{"code":"writeAndFinish","type":"codeVoice"},{"text":" is called after","type":"text"},{"type":"text","text":" "},{"code":"finish()","type":"codeVoice"},{"type":"text","text":"."}]},{"level":3,"text":"LambdaContext","anchor":"LambdaContext","type":"heading"},{"inlineContent":[{"type":"codeVoice","code":"LambdaContext"},{"text":" will be largely unchanged, but the ","type":"text"},{"type":"codeVoice","code":"eventLoop"},{"type":"text","text":" property will be removed. The "},{"type":"codeVoice","code":"allocator"},{"type":"text","text":" property of"},{"type":"text","text":" "},{"text":"type ","type":"text"},{"code":"ByteBufferAllocator","type":"codeVoice"},{"type":"text","text":" will also be removed because (1), we generally want to reduce the number of SwiftNIO types"},{"type":"text","text":" "},{"text":"exposed in the API, and (2), ","type":"text"},{"code":"ByteBufferAllocator","type":"codeVoice"},{"type":"text","text":" does not optimize the allocation strategies. The common pattern"},{"type":"text","text":" "},{"type":"text","text":"observed across many libraries is to re-use existing "},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":"s as much as possible. This is also what we do for the"},{"type":"text","text":" "},{"type":"codeVoice","code":"LambdaCodableAdapter"},{"type":"text","text":" (explained in the "},{"type":"strong","inlineContent":[{"type":"text","text":"Codable Support"}]},{"type":"text","text":" section) implementation."}],"type":"paragraph"},{"code":["\/\/\/ A context object passed as part of an invocation in LambdaHandler handle functions.","public struct LambdaContext: Sendable {","    \/\/\/ The request ID, which identifies the request that triggered the function invocation.","    public var requestID: String { get }","","    \/\/\/ The AWS X-Ray tracing header.","    public var traceID: String { get }","","    \/\/\/ The ARN of the Lambda function, version, or alias that's specified in the invocation.","    public var invokedFunctionARN: String { get }","","    \/\/\/ The timestamp that the function times out.","    public var deadline: DispatchWallTime { get }","","    \/\/\/ For invocations from the AWS Mobile SDK, data about the Amazon Cognito identity provider.","    public var cognitoIdentity: String? { get }","","    \/\/\/ For invocations from the AWS Mobile SDK, data about the client application and device.","    public var clientContext: String? { get }","","    \/\/\/ `Logger` to log with.","    \/\/\/","    \/\/\/ - note: The `LogLevel` can be configured using the `LOG_LEVEL` environment variable.","    public var logger: Logger { get }","}"],"type":"codeListing","syntax":"swift"},{"type":"heading","anchor":"Handlers","text":"Handlers","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"We introduce three handler protocols: "},{"type":"codeVoice","code":"StreamingLambdaHandler"},{"text":", ","type":"text"},{"code":"LambdaHandler","type":"codeVoice"},{"text":", and","type":"text"},{"text":" ","type":"text"},{"code":"LambdaWithBackgroundProcessingHandler","type":"codeVoice"},{"text":".","type":"text"}]},{"type":"heading","anchor":"StreamingLambdaHandler","level":4,"text":"StreamingLambdaHandler"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The new "},{"code":"StreamingLambdaHandler","type":"codeVoice"},{"type":"text","text":" protocol is the base protocol to implement a Lambda function. Most users will not use"},{"text":" ","type":"text"},{"text":"this protocol and instead use the ","type":"text"},{"code":"LambdaHandler","type":"codeVoice"},{"text":" protocol defined below.","type":"text"}]},{"code":["\/\/\/ The base StreamingLambdaHandler protocol","public protocol StreamingLambdaHandler {","    \/\/\/ The business logic of the Lambda function","    \/\/\/ - Parameters:","    \/\/\/   - event: The invocation's input data","    \/\/\/   - responseWriter: A ``LambdaResponseStreamWriter`` to write the invocation's response to.","    \/\/\/                     If no response or error is written to the `responseWriter` it will","    \/\/\/                     report an error to the invoker.","    \/\/\/   - context: The LambdaContext containing the invocation's metadata","    \/\/\/ - Throws:","    \/\/\/ How the thrown error will be handled by the runtime:","    \/\/\/   - An invocation error will be reported if the error is thrown before the first call to","    \/\/\/     ``LambdaResponseStreamWriter.write(_:)``.","    \/\/\/   - If the error is thrown after call(s) to ``LambdaResponseStreamWriter.write(_:)`` but before","    \/\/\/     a call to ``LambdaResponseStreamWriter.finish()``, the response stream will be closed and trailing","    \/\/\/     headers will be sent.","    \/\/\/   - If ``LambdaResponseStreamWriter.finish()`` has already been called before the error is thrown, the","    \/\/\/     error will be logged.","    mutating func handle(_ event: ByteBuffer, responseWriter: some LambdaResponseStreamWriter, context: LambdaContext) async throws","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"Using this protocol requires the ","type":"text"},{"code":"handle","type":"codeVoice"},{"text":" method to receive the incoming event as a ","type":"text"},{"type":"codeVoice","code":"ByteBuffer"},{"text":" and return the output","type":"text"},{"text":" ","type":"text"},{"text":"as a ","type":"text"},{"type":"codeVoice","code":"ByteBuffer"},{"text":" too.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Through the "},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"type":"text","text":", which is passed as an argument in the "},{"code":"handle","type":"codeVoice"},{"text":" function, the ","type":"text"},{"inlineContent":[{"type":"text","text":"response can be"},{"type":"text","text":" "},{"text":"streamed","type":"text"}],"type":"strong"},{"type":"text","text":" by calling the "},{"code":"write(_:)","type":"codeVoice"},{"text":" function of the ","type":"text"},{"code":"LambdaResponseStreamWriter","type":"codeVoice"},{"text":" with partial data repeatedly before","type":"text"},{"type":"text","text":" "},{"type":"text","text":"finally closing the response stream by calling "},{"code":"finish()","type":"codeVoice"},{"type":"text","text":". Users can also choose to return the entire output and not"},{"text":" ","type":"text"},{"text":"stream the response by calling ","type":"text"},{"type":"codeVoice","code":"writeAndFinish(_:)"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"This protocol also allows for background tasks to be run after a result has been reported to the AWS Lambda control","type":"text"},{"type":"text","text":" "},{"type":"text","text":"plane, since the "},{"code":"handle(...)","type":"codeVoice"},{"type":"text","text":" function is free to implement any background work after the call to"},{"type":"text","text":" "},{"code":"responseWriter.finish()","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"text":"The protocol is defined in a way that supports a broad range of use-cases. The handle method is marked as ","type":"text"},{"type":"codeVoice","code":"mutating"},{"type":"text","text":" to"},{"type":"text","text":" "},{"type":"text","text":"allow handlers to be implemented with a "},{"code":"struct","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"An implementation that sends the number 1 to 10 every 500ms could look like this:"}],"type":"paragraph"},{"code":["struct SendNumbersWithPause: StreamingLambdaHandler {","    func handle(","        _ event: ByteBuffer,","        responseWriter: some LambdaResponseStreamWriter,","        context: LambdaContext","    ) async throws {","        for i in 1...10 {","            \/\/ Send partial data","            responseWriter.write(ByteBuffer(string: #\"\\#(i)\\n\\r\"#))","            \/\/ Perform some long asynchronous work","            try await Task.sleep(for: .milliseconds(500))","        }","        \/\/ All data has been sent. Close off the response stream.","        responseWriter.finish()","    }","}"],"type":"codeListing","syntax":"swift"},{"level":4,"type":"heading","anchor":"LambdaHandler","text":"LambdaHandler:"},{"inlineContent":[{"text":"This handler protocol will be the go-to choice for most use-cases because it is completely agnostic to any","type":"text"},{"type":"text","text":" "},{"type":"text","text":"encoding\/decoding logic – conforming objects simply have to implement the "},{"code":"handle","type":"codeVoice"},{"text":" function where the input and return","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"types are Swift objects."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Note that the "},{"code":"handle","type":"codeVoice"},{"type":"text","text":" function does not receive a "},{"code":"LambdaResponseStreamWriter","type":"codeVoice"},{"type":"text","text":" as an argument. Response streaming is"},{"type":"text","text":" "},{"type":"text","text":"not viable for "},{"code":"LambdaHandler","type":"codeVoice"},{"type":"text","text":" because the output has to be encoded prior to it being sent, e.g. it is not possible to"},{"type":"text","text":" "},{"text":"encode a partial\/incomplete JSON string.","type":"text"}],"type":"paragraph"},{"code":["public protocol LambdaHandler {","    \/\/\/ Generic input type","    \/\/\/ The body of the request sent to Lambda will be decoded into this type for the handler to consume","    associatedtype Event","    \/\/\/ Generic output type","    \/\/\/ This is the return type of the handle() function.","    associatedtype Output","","    \/\/\/ The business logic of the Lambda function. Receives a generic input type and returns a generic output type.","    \/\/\/ Agnostic to encoding\/decoding","    mutating func handle(_ event: Event, context: LambdaContext) async throws -> Output","}"],"type":"codeListing","syntax":"swift"},{"type":"heading","text":"LambdaWithBackgroundProcessingHandler:","anchor":"LambdaWithBackgroundProcessingHandler","level":4},{"type":"paragraph","inlineContent":[{"type":"text","text":"This protocol is exactly like "},{"type":"codeVoice","code":"LambdaHandler"},{"text":", with the only difference being the added support for executing background","type":"text"},{"type":"text","text":" "},{"text":"work after the result has been sent to the AWS Lambda control plane.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This is achieved by not having a return type in the "},{"code":"handle","type":"codeVoice"},{"type":"text","text":" function. The output is instead written into a"},{"type":"text","text":" "},{"type":"codeVoice","code":"LambdaResponseWriter"},{"type":"text","text":" that is passed in as an argument, meaning that the "},{"type":"codeVoice","code":"handle"},{"text":" function is then free to implement","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"any background work after the result has been sent to the AWS Lambda control plane."}]},{"inlineContent":[{"type":"codeVoice","code":"LambdaResponseWriter"},{"text":" has different semantics to the ","type":"text"},{"code":"LambdaResponseStreamWriter","type":"codeVoice"},{"type":"text","text":". Where the "},{"type":"codeVoice","code":"write(_:)"},{"type":"text","text":" function of"},{"text":" ","type":"text"},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"type":"text","text":" means writing into a response stream, the "},{"type":"codeVoice","code":"write(_:)"},{"text":" function of ","type":"text"},{"code":"LambdaResponseWriter","type":"codeVoice"},{"text":" ","type":"text"},{"text":"simply serves as a mechanism to return the output without explicitly returning from the ","type":"text"},{"type":"codeVoice","code":"handle"},{"type":"text","text":" function."}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["public protocol LambdaResponseWriter<Output> {","    associatedtype Output","","    \/\/\/ Sends the generic Output object (representing the computed result of the handler)","    \/\/\/ to the AWS Lambda response endpoint.","    \/\/\/ An error will be thrown if this function is called more than once.","    func write(_: Output) async throws","}","","public protocol LambdaWithBackgroundProcessingHandler {","    \/\/\/ Generic input type","    \/\/\/ The body of the request sent to Lambda will be decoded into this type for the handler to consume","    associatedtype Event","    \/\/\/ Generic output type","    \/\/\/ This is the type that the handle() function will send through the ``LambdaResponseWriter``.","    associatedtype Output","","    \/\/\/ The business logic of the Lambda function. Receives a generic input type and returns a generic output type.","    \/\/\/ Agnostic to JSON encoding\/decoding","    func handle(","        _ event: Event,","        outputWriter: some LambdaResponseWriter<Output>,","        context: LambdaContext","    ) async throws","}"]},{"anchor":"Example-Usage","text":"Example Usage:","type":"heading","level":5},{"type":"codeListing","syntax":"swift","code":["struct BackgroundProcessingHandler: LambdaWithBackgroundProcessingHandler {","    struct Input: Decodable {","        let message: String","    }","","    struct Greeting: Encodable {","        let echoedMessage: String","    }","","    typealias Event = Input","    typealias Output = Greeting","","    func handle(","        _ event: Event,","        outputWriter: some LambdaResponseWriter<Output>,","        context: LambdaContext","    ) async throws {","        \/\/ Return result to the Lambda control plane","        try await outputWriter.write(result: Greeting(echoedMessage: event.messageToEcho))","","        \/\/ Perform some background work, e.g:","        try await Task.sleep(for: .seconds(10))","","        \/\/ Exit the function. All asynchronous work has been executed before exiting the scope of this function.","        \/\/ Follows structured concurrency principles.","        return","    }","}"]},{"type":"heading","text":"Handler Adapters","level":4,"anchor":"Handler-Adapters"},{"type":"paragraph","inlineContent":[{"text":"Since the ","type":"text"},{"type":"codeVoice","code":"StreamingLambdaHandler"},{"text":" protocol is the base protocol the ","type":"text"},{"code":"LambdaRuntime","type":"codeVoice"},{"text":" works with, there are adapters to","type":"text"},{"text":" ","type":"text"},{"text":"make both ","type":"text"},{"code":"LambdaHandler","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"LambdaWithBackgroundProcessingHandler","type":"codeVoice"},{"type":"text","text":" compatible with "},{"type":"codeVoice","code":"StreamingLambdaHandler"},{"type":"text","text":"."}]},{"type":"orderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"code":"LambdaHandlerAdapter","type":"codeVoice"},{"text":" accepts a ","type":"text"},{"type":"codeVoice","code":"LambdaHandler"},{"type":"text","text":" and conforms it to "},{"code":"LambdaWithBackgroundProcessingHandler","type":"codeVoice"},{"text":". This is","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"achieved by taking the generic "},{"type":"codeVoice","code":"Output"},{"type":"text","text":" object returned from the "},{"type":"codeVoice","code":"handle"},{"type":"text","text":" function of "},{"code":"LambdaHandler","type":"codeVoice"},{"text":" and passing it","type":"text"},{"type":"text","text":" "},{"text":"to the ","type":"text"},{"type":"codeVoice","code":"write(_:)"},{"type":"text","text":" function of the "},{"type":"codeVoice","code":"LambdaResponseWriter"},{"text":".","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"code":"LambdaCodableAdapter","type":"codeVoice"},{"text":" accepts a ","type":"text"},{"type":"codeVoice","code":"LambdaWithBackgroundProcessingHandler"},{"type":"text","text":" and conforms it to "},{"type":"codeVoice","code":"StreamingLambdaHandler"},{"type":"text","text":"."},{"text":" ","type":"text"},{"text":"This is achieved by wrapping the ","type":"text"},{"code":"LambdaResponseWriter","type":"codeVoice"},{"text":" with the ","type":"text"},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"type":"text","text":" provided by"},{"type":"text","text":" "},{"type":"codeVoice","code":"StreamingLambdaHandler"},{"type":"text","text":". A call to the "},{"type":"codeVoice","code":"write(_:)"},{"text":" function of ","type":"text"},{"code":"LambdaResponseWriter","type":"codeVoice"},{"text":" is translated into a call to","type":"text"},{"type":"text","text":" "},{"text":"the ","type":"text"},{"code":"writeAndFinish(_:)","type":"codeVoice"},{"text":" function of ","type":"text"},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"text":".","type":"text"}]}]}]},{"inlineContent":[{"text":"Both ","type":"text"},{"type":"codeVoice","code":"LambdaHandlerAdapter"},{"type":"text","text":" and "},{"type":"codeVoice","code":"LambdaCodableAdapter"},{"type":"text","text":" are described in greater detail in the "},{"type":"strong","inlineContent":[{"type":"text","text":"Codable Support"}]},{"text":" ","type":"text"},{"type":"text","text":"section."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"To summarize, "},{"code":"LambdaHandler","type":"codeVoice"},{"type":"text","text":" can be used with the "},{"type":"codeVoice","code":"LambdaRuntime"},{"type":"text","text":" by first going through "},{"type":"codeVoice","code":"LambdaHandlerAdapter"},{"type":"text","text":" and"},{"text":" ","type":"text"},{"type":"text","text":"then through "},{"type":"codeVoice","code":"LambdaCodableAdapter"},{"type":"text","text":". "},{"type":"codeVoice","code":"LambdaWithBackgroundHandler"},{"type":"text","text":" just requires "},{"type":"codeVoice","code":"LambdaCodableAdapter"},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For the common JSON-in and JSON-out use-case, there is an extension on "},{"code":"LambdaRuntime","type":"codeVoice"},{"text":" that abstracts away this wrapping","type":"text"},{"type":"text","text":" "},{"type":"text","text":"from the user."}]},{"anchor":"LambdaRuntime","type":"heading","text":"LambdaRuntime","level":3},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"LambdaRuntime"},{"text":" is the class that communicates with the Lambda control plane as defined in","type":"text"},{"text":" ","type":"text"},{"type":"reference","identifier":"https:\/\/docs.aws.amazon.com\/lambda\/latest\/dg\/runtimes-custom.html","isActive":true},{"text":" and","type":"text"},{"text":" ","type":"text"},{"text":"forward the invocations to the provided ","type":"text"},{"type":"codeVoice","code":"StreamingLambdaHandler"},{"type":"text","text":". It will conform to "},{"code":"ServiceLifecycle.Service","type":"codeVoice"},{"text":" to","type":"text"},{"type":"text","text":" "},{"text":"provide support for ","type":"text"},{"code":"swift-service-lifecycle","type":"codeVoice"},{"text":".","type":"text"}]},{"code":["\/\/\/ The LambdaRuntime object. This object communicates with the Lambda control plane","\/\/\/ to fetch work and report errors.","public final class LambdaRuntime<Handler>: ServiceLifecycle.Service, Sendable","    where Handler: StreamingLambdaHandler","{","","    \/\/\/ Create a LambdaRuntime by passing a handler, an eventLoop and a logger.","    \/\/\/ - Parameter handler: A ``StreamingLambdaHandler`` that will be invoked","    \/\/\/ - Parameter eventLoop: An ``EventLoop`` on which the LambdaRuntime will be","    \/\/\/                        executed. Defaults to an EventLoop from","    \/\/\/                        ``NIOSingletons.posixEventLoopGroup``.","    \/\/\/ - Parameter logger: A logger","    public init(","        handler: sending Handler,","        eventLoop: EventLoop = Lambda.defaultEventLoop,","        logger: Logger = Logger(label: \"Lambda\")","    )","","    \/\/\/ Create a LambdaRuntime by passing a ``StreamingLambdaHandler``.","    public convenience init(handler: sending Handler)","","    \/\/\/ Starts the LambdaRuntime by connecting to the Lambda control plane to ask","    \/\/\/ for events to process. If the environment variable AWS_LAMBDA_RUNTIME_API is","    \/\/\/ set, the LambdaRuntime will connect to the Lambda control plane. Otherwise","    \/\/\/ it will start a mock server that can be used for testing at port 8080","    \/\/\/ locally.","    \/\/\/ Cancel the task that runs this function to close the communication with","    \/\/\/ the Lambda control plane or close the local mock server. This function","    \/\/\/ only returns once cancelled.","    public func run() async throws","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"The current API allows for a Lambda function to be tested locally through a mock server by requiring an environment","type":"text"},{"type":"text","text":" "},{"text":"variable named ","type":"text"},{"type":"codeVoice","code":"LOCAL_LAMBDA_SERVER_ENABLED"},{"text":" to be set to ","type":"text"},{"type":"codeVoice","code":"true"},{"type":"text","text":". If this environment variable is not set, the program"},{"type":"text","text":" "},{"type":"text","text":"immediately crashes as the user will not have the "},{"type":"codeVoice","code":"AWS_LAMBDA_RUNTIME_API"},{"type":"text","text":" environment variable on their local machine"},{"text":" ","type":"text"},{"type":"text","text":"(set automatically when deployed to AWS Lambda). However, making the user set the "},{"code":"LOCAL_LAMBDA_SERVER_ENABLED","type":"codeVoice"},{"type":"text","text":" "},{"text":"environment variable is an unnecessary step that can be avoided. In the v2 API, the ","type":"text"},{"type":"codeVoice","code":"run()"},{"text":" function will automatically","type":"text"},{"text":" ","type":"text"},{"text":"start the mock server when the ","type":"text"},{"code":"AWS_LAMBDA_RUNTIME_API","type":"codeVoice"},{"type":"text","text":" environment variable cannot be found."}]},{"text":"Lambda","level":3,"anchor":"Lambda","type":"heading"},{"inlineContent":[{"text":"We also add an enum to store a static function and a property on. We put this on the static ","type":"text"},{"code":"Lambda","type":"codeVoice"},{"text":" because","type":"text"},{"text":" ","type":"text"},{"type":"codeVoice","code":"LambdaRuntime"},{"type":"text","text":" is generic and thus has bad ergonomics for static properties and functions."}],"type":"paragraph"},{"code":["enum Lambda {","    \/\/\/ This returns the default EventLoop that a LambdaRuntime is scheduled on.","    \/\/\/ It uses `NIOSingletons.posixEventLoopGroup.next()` under the hood.","    public static var defaultEventLoop: any EventLoop { get }","","    \/\/\/ Report a startup error to the Lambda Control Plane API","    public static func reportStartupError(any Error) async","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"Since the library now provides ownership of the ","type":"text"},{"code":"main()","type":"codeVoice"},{"text":" function and allows users to initialize services before the","type":"text"},{"text":" ","type":"text"},{"type":"codeVoice","code":"LambdaRuntime"},{"text":" is initialized, the library cannot implicitly report","type":"text"},{"type":"text","text":" "},{"type":"reference","identifier":"https:\/\/docs.aws.amazon.com\/lambda\/latest\/dg\/runtimes-api.html#runtimes-api-initerror","isActive":true},{"type":"text","text":" "},{"text":"like it currently does through the ","type":"text"},{"type":"codeVoice","code":"initialize()"},{"text":" function of ","type":"text"},{"code":"LambdaRunner","type":"codeVoice"},{"type":"text","text":" which wraps the handler’s "},{"code":"init(...)","type":"codeVoice"},{"text":" and","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"handles any errors thrown by reporting it to the dedicated AWS endpoint."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"To retain support for initialization error reporting, the "},{"type":"codeVoice","code":"Lambda.reportStartupError(any Error)"},{"text":" function gives users","type":"text"},{"type":"text","text":" "},{"text":"the option to manually report initialization errors in their closure handler. Although this should ideally happen","type":"text"},{"type":"text","text":" "},{"type":"text","text":"implicitly like it currently does in v1, we believe this is a small compromise in comparison to the benefits gained in"},{"type":"text","text":" "},{"type":"text","text":"now being able to cleanly manage the lifecycles of required services in a structured concurrency manner."}]},{"type":"aside","content":[{"inlineContent":[{"text":"","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"Assume we want to load a secret for the Lambda function from a secret vault first. If this fails, we want to report","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"the error to the control plane:"}]},{"code":["let secretVault = SecretVault()","","do {","   \/\/\/ !!! Error thrown: secret \"foo\" does not exist !!!","   let secret = try await secretVault.getSecret(\"foo\")","","   let runtime = LambdaRuntime { (event: Input, context: LambdaContext) in","       \/\/\/ Lambda business logic","   }","","   let serviceGroup = ServiceGroup(","       services: [postgresClient, runtime],","       configuration: .init(gracefulShutdownSignals: [.sigterm]),","       logger: logger","   )","   try await serviceGroup.run()","} catch {","   \/\/\/ Report startup error straight away to the dedicated initialization error endpoint","   try await Lambda.reportStartupError(error)","}"],"type":"codeListing","syntax":"swift"}],"style":"note","name":"Use-case"},{"type":"heading","anchor":"Codable-support","text":"Codable support","level":3},{"inlineContent":[{"type":"text","text":"The "},{"code":"LambdaHandler","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"LambdaWithBackgroundProcessingHandler","type":"codeVoice"},{"text":" protocols abstract away encoding\/decoding logic from the","type":"text"},{"type":"text","text":" "},{"type":"text","text":"conformers as they are generic over custom "},{"type":"codeVoice","code":"Event"},{"text":" and ","type":"text"},{"code":"Output","type":"codeVoice"},{"text":" types. We introduce two adapters ","type":"text"},{"code":"LambdaHandlerAdapter","type":"codeVoice"},{"type":"text","text":" "},{"text":"and ","type":"text"},{"code":"CodableLambdaAdapter","type":"codeVoice"},{"text":" that implement the encoding\/decoding logic and in turn allow the respective handlers to","type":"text"},{"text":" ","type":"text"},{"text":"conform to ","type":"text"},{"code":"StreamingLambdaHandler","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"},{"text":"LambdaHandlerAdapter","type":"heading","level":4,"anchor":"LambdaHandlerAdapter"},{"inlineContent":[{"text":"Any handler conforming to ","type":"text"},{"type":"codeVoice","code":"LambdaHandler"},{"text":" can be conformed to ","type":"text"},{"type":"codeVoice","code":"LambdaWithBackgroundProcessingHandler"},{"text":" through","type":"text"},{"text":" ","type":"text"},{"type":"codeVoice","code":"LambdaHandlerAdapter"},{"type":"text","text":"."}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["\/\/\/ Wraps an underlying handler conforming to ``LambdaHandler``","\/\/\/ with ``LambdaWithBackgroundProcessingHandler``.","public struct LambdaHandlerAdapter<","    Event: Decodable,","    Output,","    Handler: LambdaHandler",">: LambdaWithBackgroundProcessingHandler where Handler.Event == Event, Handler.Output == Output {","    let handler: Handler","","    \/\/\/ Register the concrete handler.","    public init(handler: Handler)","","    \/\/\/ 1. Call the `self.handler.handle(...)` with `event` and `context`.","    \/\/\/ 2. Pass the generic `Output` object returned from `self.handler.handle(...)` to `outputWriter.write(_:)`","    public func handle(_ event: Event, outputWriter: some LambdaResponseWriter<Output>, context: LambdaContext) async throws","}"]},{"anchor":"LambdaCodableAdapter","text":"LambdaCodableAdapter","level":4,"type":"heading"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"LambdaCodableAdapter"},{"text":" accepts any generic underlying handler conforming to ","type":"text"},{"code":"LambdaWithBackgroundProcessingHandler","type":"codeVoice"},{"type":"text","text":". It"},{"type":"text","text":" "},{"text":"also accepts ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"any"}]},{"type":"text","text":" encoder and decoder object conforming to the "},{"type":"codeVoice","code":"LambdaEventDecoder"},{"type":"text","text":" and "},{"type":"codeVoice","code":"LambdaOutputEncoder"},{"text":" ","type":"text"},{"text":"protocols:","type":"text"}]},{"type":"heading","text":"LambdaEventDecoder and LambdaOutputEncoder protocols","level":5,"anchor":"LambdaEventDecoder-and-LambdaOutputEncoder-protocols"},{"code":["public protocol LambdaEventDecoder {","    \/\/\/ Decode the ByteBuffer representing the received event into the generic type Event","    \/\/\/ the handler will receive","    func decode<Event: Decodable>(_ type: Event.Type, from buffer: ByteBuffer) throws -> Event","}","","public protocol LambdaOutputEncoder {","    \/\/\/ Encode the generic type Output the handler has produced into a ByteBuffer","    func encode<Output: Encodable>(_ value: Output, into buffer: inout ByteBuffer) throws","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"We provide conformances for Foundation’s "},{"code":"JSONDecoder","type":"codeVoice"},{"type":"text","text":" to "},{"code":"LambdaEventDecoder","type":"codeVoice"},{"type":"text","text":" and "},{"code":"JSONEncoder","type":"codeVoice"},{"type":"text","text":" to"},{"type":"text","text":" "},{"type":"codeVoice","code":"LambdaOutputEncoder"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"code":"LambdaCodableAdapter","type":"codeVoice"},{"type":"text","text":" implements its "},{"type":"codeVoice","code":"handle()"},{"text":" method by:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"text":"Decoding the ","type":"text"},{"code":"ByteBuffer","type":"codeVoice"},{"text":" event into the generic ","type":"text"},{"type":"codeVoice","code":"Event"},{"type":"text","text":" type."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Wrapping the "},{"code":"LambdaResponseStreamWriter","type":"codeVoice"},{"type":"text","text":" with a concrete "},{"code":"LambdaResponseWriter","type":"codeVoice"},{"type":"text","text":" such that calls to"},{"type":"text","text":" "},{"type":"codeVoice","code":"LambdaResponseWriter"},{"type":"text","text":"s "},{"type":"codeVoice","code":"write(_:)"},{"type":"text","text":" are mapped to "},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"text":"s ","type":"text"},{"type":"codeVoice","code":"writeAndFinish(_:)"},{"type":"text","text":"."}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"Note that the argument to "},{"type":"codeVoice","code":"LambdaResponseWriter"},{"text":"s ","type":"text"},{"type":"codeVoice","code":"write(_:)"},{"type":"text","text":" is a generic "},{"type":"codeVoice","code":"Output"},{"text":" object whereas","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"text":"s ","type":"text"},{"type":"codeVoice","code":"writeAndFinish(_:)"},{"text":" requires a ","type":"text"},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":"."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Therefore, the concrete implementation of ","type":"text"},{"code":"LambdaResponseWriter","type":"codeVoice"},{"type":"text","text":" also accepts an encoder. Its "},{"type":"codeVoice","code":"write(_:)"},{"type":"text","text":" function"},{"type":"text","text":" "},{"type":"text","text":"first encodes the generic "},{"type":"codeVoice","code":"Output"},{"text":" object and then passes it to the underlying ","type":"text"},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"type":"text","text":"."}]}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Passing the generic ","type":"text"},{"type":"codeVoice","code":"Event"},{"text":" instance, the concrete ","type":"text"},{"type":"codeVoice","code":"LambdaResponseWriter"},{"text":", as well as the ","type":"text"},{"type":"codeVoice","code":"LambdaContext"},{"type":"text","text":" to the"},{"text":" ","type":"text"},{"type":"text","text":"underlying handler’s "},{"code":"handle()","type":"codeVoice"},{"text":" method.","type":"text"}]}]}],"type":"orderedList"},{"inlineContent":[{"code":"LambdaCodableAdapter","type":"codeVoice"},{"type":"text","text":" can implement encoding\/decoding for "},{"type":"emphasis","inlineContent":[{"text":"any","type":"text"}]},{"text":" handler conforming to","type":"text"},{"text":" ","type":"text"},{"code":"LambdaWithBackgroundProcessingHandler","type":"codeVoice"},{"type":"text","text":" if "},{"code":"Event","type":"codeVoice"},{"type":"text","text":" is "},{"type":"codeVoice","code":"Decodable"},{"type":"text","text":" and the "},{"type":"codeVoice","code":"Output"},{"type":"text","text":" is "},{"type":"codeVoice","code":"Encodable"},{"text":" or ","type":"text"},{"type":"codeVoice","code":"Void"},{"text":", meaning","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"that the encoding\/decoding stubs do not need to be implemented by the user."}],"type":"paragraph"},{"type":"codeListing","code":["\/\/\/ Wraps an underlying handler conforming to `LambdaWithBackgroundProcessingHandler`","\/\/\/ with encoding\/decoding logic","public struct LambdaCodableAdapter<","    Handler: LambdaWithBackgroundProcessingHandler,","    Event: Decodable,","    Output,","    Decoder: LambdaEventDecoder,","    Encoder: LambdaOutputEncoder",">: StreamingLambdaHandler where Handler.Output == Output, Handler.Event == Event {","","    \/\/\/ Register the concrete handler, encoder, and decoder.","    public init(","        handler: Handler,","        encoder: Encoder,","        decoder: Decoder","    ) where Output: Encodable","","    \/\/\/ For handler with a void output -- the user doesn't specify an encoder.","    public init(","        handler: Handler,","        decoder: Decoder","    ) where Output == Void, Encoder == VoidEncoder","","    \/\/\/ 1. Decode the invocation event using `self.decoder`","    \/\/\/ 2. Create a concrete `LambdaResponseWriter` that maps calls to `write(_:)` with the `responseWriter`s `writeAndFinish(_:)`","    \/\/\/ 2. Call the underlying `self.handler.handle()` method with the decoded event data, the concrete `LambdaResponseWriter`,","    \/\/\/ and the `LambdaContext`.","    public mutating func handle(","        _ request: ByteBuffer,","        responseWriter: some LambdaResponseStreamWriter,","        context: LambdaContext","    ) async throws","}"],"syntax":"swift"},{"type":"heading","level":3,"anchor":"Handler-as-a-Closure","text":"Handler as a Closure"},{"type":"paragraph","inlineContent":[{"text":"To create a Lambda function using the current API, a user first has to create an object and conform it to one of the","type":"text"},{"text":" ","type":"text"},{"text":"handler protocols by implementing the initializer and the ","type":"text"},{"code":"handle(...)","type":"codeVoice"},{"text":" function. Now that ","type":"text"},{"code":"LambdaRuntime","type":"codeVoice"},{"text":" is public,","type":"text"},{"type":"text","text":" "},{"text":"this verbosity can very easily be simplified.","type":"text"}]},{"anchor":"ClosureHandler","text":"ClosureHandler","type":"heading","level":4},{"inlineContent":[{"type":"text","text":"This handler is generic over any "},{"code":"Event","type":"codeVoice"},{"type":"text","text":" type conforming to "},{"type":"codeVoice","code":"Decodable"},{"type":"text","text":" and any "},{"type":"codeVoice","code":"Output"},{"type":"text","text":" type conforming to "},{"code":"Encodable","type":"codeVoice"},{"type":"text","text":" "},{"type":"text","text":"or "},{"type":"codeVoice","code":"Void"},{"type":"text","text":"."}],"type":"paragraph"},{"type":"codeListing","code":["public struct ClosureHandler<Event, Output>: LambdaHandler {","    \/\/\/ Initialize with a closure handler over generic Input and Output types","    public init(body: @escaping (Event, LambdaContext) async throws -> Output) where Output: Encodable","    \/\/\/ Initialize with a closure handler over a generic Input type (Void Output).","    public init(body: @escaping (Event, LambdaContext) async throws -> Void) where Output == Void","    \/\/\/ The business logic of the Lambda function.","    public func handle(_ event: Event, context: LambdaContext) async throws -> Output","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Given that "},{"code":"ClosureHandler","type":"codeVoice"},{"type":"text","text":" conforms to "},{"code":"LambdaHandler","type":"codeVoice"},{"type":"text","text":":"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"We can extend the ","type":"text"},{"code":"LambdaRuntime","type":"codeVoice"},{"text":" initializer such that it accepts a closure as an argument.","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"Within the initializer, the closure handler is wrapped with ","type":"text"},{"type":"codeVoice","code":"LambdaCodableAdapter"},{"type":"text","text":"."}],"type":"paragraph"}]}],"type":"orderedList"},{"type":"codeListing","code":["extension LambdaRuntime {","    \/\/\/ Initialize a LambdaRuntime with a closure handler over generic Event and Output types.","    \/\/\/ This initializer bolts on encoding\/decoding logic by wrapping the closure handler with","    \/\/\/ LambdaCodableAdapter.","    public init<Event: Decodable, Output: Encodable>(","        body: @escaping (Event, LambdaContext) async throws -> Output","    ) where Handler == LambdaCodableAdapter<ClosureHandler<Event, Output>, Event, Output, JSONDecoder, JSONEncoder>","","    \/\/\/ Same as above but for handlers with a void output","    public init<Event: Decodable>(","        body: @escaping (Event, LambdaContext) async throws -> Void","    ) where Handler == LambdaCodableAdapter<ClosureHandler<Event, Void>, Event, Void, JSONDecoder, VoidEncoder>","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"We can now significantly reduce the verbosity and leverage Swift’s trailing closure syntax to cleanly create and run a"},{"type":"text","text":" "},{"type":"text","text":"Lambda function, abstracting away the decoding and encoding logic from the user:"}]},{"syntax":"swift","code":["\/\/\/ The type the handler will use as input","struct Input: Decodable {","    var message: String","}","","\/\/\/ The type the handler will output","struct Greeting: Encodable {","    var echoedMessage: String","}","","\/\/\/ A simple Lambda function that echoes the input","let runtime = LambdaRuntime { (event: Input, context: LambdaContext) in","    Greeting(echoedMessage: event.message)","}","","try await runtime.run()"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"We also add a "},{"type":"codeVoice","code":"StreamingClosureHandler"},{"type":"text","text":" conforming to "},{"code":"StreamingLambdaHandler","type":"codeVoice"},{"type":"text","text":" for use-cases where the user wants to"},{"text":" ","type":"text"},{"type":"text","text":"handle encoding\/decoding themselves:"}],"type":"paragraph"},{"code":["public struct StreamingClosureHandler: StreamingLambdaHandler {","","    public init(","        body: @escaping sending (ByteBuffer, LambdaResponseStreamWriter, LambdaContext) async throws -> ()","    )","","    public func handle(","        _ request: ByteBuffer,","        responseWriter: LambdaResponseStreamWriter,","        context: LambdaContext","    ) async throws","}","","extension LambdaRuntime {","    public init(","        body: @escaping sending (ByteBuffer, LambdaResponseStreamWriter, LambdaContext) async throws -> ()","    )","}"],"type":"codeListing","syntax":"swift"},{"level":2,"type":"heading","text":"Alternatives considered","anchor":"Alternatives-considered"},{"type":"heading","level":3,"text":"[UInt8] instead of ByteBuffer","anchor":"UInt8-instead-of-ByteBuffer"},{"type":"paragraph","inlineContent":[{"type":"text","text":"We considered using "},{"type":"codeVoice","code":"[UInt8]"},{"text":" instead of ","type":"text"},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":" in the base "},{"code":"LambdaHandler","type":"codeVoice"},{"type":"text","text":" API. We decided to use "},{"code":"ByteBuffer","type":"codeVoice"},{"text":" ","type":"text"},{"type":"text","text":"for two reasons."}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"99% of use-cases will use the JSON codable API and will not directly get in touch with ByteBuffer anyway. For those"},{"type":"text","text":" "},{"text":"users it does not matter if the base API uses ","type":"text"},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":" or "},{"type":"codeVoice","code":"[UInt8]"},{"text":".","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The incoming and outgoing data must be in the "},{"type":"codeVoice","code":"ByteBuffer"},{"text":" format anyway, as Lambda uses SwiftNIO under the hood and","type":"text"},{"type":"text","text":" "},{"type":"text","text":"SwiftNIO uses "},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":" in its APIs. By using "},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":" we can save a copies to and from "},{"code":"[UInt8]","type":"codeVoice"},{"type":"text","text":". This will"},{"text":" ","type":"text"},{"type":"text","text":"reduce the invocation time for all users."}]}]},{"content":[{"inlineContent":[{"type":"text","text":"The base "},{"type":"codeVoice","code":"LambdaHandler"},{"type":"text","text":" API is most likely mainly being used by developers that want to integrate their web"},{"text":" ","type":"text"},{"type":"text","text":"framework with Lambda (examples: Vapor, Hummingbird, …). Those developers will most likely prefer to get the data"},{"type":"text","text":" "},{"text":"in the ","type":"text"},{"type":"codeVoice","code":"ByteBuffer"},{"text":" format anyway, as their lower level networking stack also depends on SwiftNIO.","type":"text"}],"type":"paragraph"}]}],"type":"orderedList"},{"type":"heading","text":"Users create a LambdaResponse, that supports streaming instead of being passed a LambdaResponseStreamWriter","anchor":"Users-create-a-LambdaResponse-that-supports-streaming-instead-of-being-passed-a-LambdaResponseStreamWriter","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"Instead of passing the "},{"code":"LambdaResponseStreamWriter","type":"codeVoice"},{"type":"text","text":" in the invocation we considered a new type "},{"type":"codeVoice","code":"LambdaResponse"},{"text":", that","type":"text"},{"type":"text","text":" "},{"type":"text","text":"users must return in the "},{"type":"codeVoice","code":"StreamingLambdaHandler"},{"text":".","type":"text"}]},{"inlineContent":[{"text":"Its API would look like this:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["\/\/\/ A response returned from a ``LambdaHandler``.","\/\/\/ The response can be empty, a single ByteBuffer or a response stream.","public struct LambdaResponse {","    \/\/\/ A writer to be used when creating a streamed response.","    public struct Writer {","        \/\/\/ Writes data to the response stream","        public func write(_ byteBuffer: ByteBuffer) async throws","        \/\/\/ Closes off the response stream","        public func finish() async throws","        \/\/\/ Writes the `byteBuffer` to the response stream and subsequently closes the stream","        public func writeAndFinish(_ byteBuffer: ByteBuffer) async throws","    }","","    \/\/\/ Creates an empty lambda response","    public init()","","    \/\/\/ Creates a LambdaResponse with a fixed ByteBuffer.","    public init(_ byteBuffer: ByteBuffer)","","    \/\/\/ Creates a streamed lambda response. Use the ``Writer`` to send","    \/\/\/ response chunks on the stream.","    public init(_ stream: @escaping sending (Writer) async throws -> ())","}"]},{"inlineContent":[{"type":"text","text":"The "},{"code":"StreamingLambdaHandler","type":"codeVoice"},{"text":" would look like this:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["\/\/\/ The base LambdaHandler protocol","public protocol StreamingLambdaHandler {","    \/\/\/ The business logic of the Lambda function","    \/\/\/ - Parameters:","    \/\/\/   - event: The invocation's input data","    \/\/\/   - context: The LambdaContext containing the invocation's metadata","    \/\/\/ - Returns: A LambdaResponse, that can be streamed","    mutating func handle(","        _ event: ByteBuffer,","        context: LambdaContext","    ) async throws -> LambdaResponse","}"]},{"inlineContent":[{"text":"There are pros and cons for the API that returns the ","type":"text"},{"type":"codeVoice","code":"LambdaResponses"},{"text":" and there are pros and cons for the API that","type":"text"},{"type":"text","text":" "},{"text":"receives a ","type":"text"},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"type":"text","text":" as a parameter."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"Concerning following structured concurrency principles the approach that receives a ","type":"text"},{"code":"LambdaResponseStreamWriter","type":"codeVoice"},{"text":" as a","type":"text"},{"type":"text","text":" "},{"type":"text","text":"parameter has benefits as the lifetime of the handle function is tied to the invocation runtime. The approach that"},{"text":" ","type":"text"},{"text":"returns a ","type":"text"},{"type":"codeVoice","code":"LambdaResponse"},{"type":"text","text":" splits the invocation into two separate function calls. First the handle method is invoked,"},{"text":" ","type":"text"},{"text":"second the ","type":"text"},{"type":"codeVoice","code":"LambdaResponse"},{"type":"text","text":" writer closure is invoked. This means that it is impossible to use Swift APIs that use"},{"text":" ","type":"text"},{"code":"with","type":"codeVoice"},{"type":"text","text":" style lifecycle management patterns from before creating the response until sending the full response stream off."},{"text":" ","type":"text"},{"text":"For example, users instrumenting their lambdas with Swift tracing likely can not use the ","type":"text"},{"type":"codeVoice","code":"withSpan"},{"type":"text","text":" API for the full"},{"type":"text","text":" "},{"type":"text","text":"lifetime of the request, if they return a streamed response."}]},{"inlineContent":[{"type":"text","text":"However, if it comes to consistency with the larger Swift on server ecosystem, the API that returns a "},{"type":"codeVoice","code":"LambdaResponse"},{"type":"text","text":" "},{"type":"text","text":"is likely the better choice. Hummingbird v2, OpenAPI and the new Swift gRPC v2 implementation all use this approach."},{"text":" ","type":"text"},{"type":"text","text":"This might be due to the fact that writing middleware becomes easier, if a Response is explicitly returned."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"We decided to implement the approach in which a ","type":"text"},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"type":"text","text":" is passed to the function, since the"},{"type":"text","text":" "},{"type":"text","text":"approach in which a "},{"type":"codeVoice","code":"LambdaResponse"},{"type":"text","text":" is returned can trivially be built on top of it. This is not true vice versa."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"We welcome the discussion on this topic and are open to change our minds and API here."}]},{"level":3,"text":"Adding a function `addBackgroundTask(_ body: sending @escaping () async -> ())` in `LambdaContext`","type":"heading","anchor":"Adding-a-function-addBackgroundTask-body-sending-escaping--async-%3E--in-LambdaContext"},{"inlineContent":[{"text":"Initially we proposed an explicit ","type":"text"},{"type":"codeVoice","code":"addBackgroundTask(_:)"},{"type":"text","text":" function in "},{"code":"LambdaContext","type":"codeVoice"},{"type":"text","text":" that users could call from their"},{"text":" ","type":"text"},{"type":"text","text":"handler object to schedule a background task to be run after the result is reported to AWS. We received feedback that"},{"text":" ","type":"text"},{"text":"this approach for supporting background tasks does not exhibit structured concurrency, as code could still be in","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"execution after leaving the scope of the "},{"code":"handle(...)","type":"codeVoice"},{"text":" function.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"For handlers conforming to the "},{"type":"codeVoice","code":"StreamingLambdaHandler"},{"type":"text","text":", "},{"type":"codeVoice","code":"addBackgroundTask(_:)"},{"text":" was anyways unnecessary as background","type":"text"},{"type":"text","text":" "},{"text":"work could be executed in a structured concurrency manner within the ","type":"text"},{"code":"handle(...)","type":"codeVoice"},{"type":"text","text":" function after the call to"},{"text":" ","type":"text"},{"type":"codeVoice","code":"LambdaResponseStreamWriter.finish()"},{"text":".","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"For handlers conforming to the "},{"type":"codeVoice","code":"LambdaHandler"},{"type":"text","text":" protocol, we considered extending "},{"type":"codeVoice","code":"LambdaHandler"},{"text":" with a","type":"text"},{"text":" ","type":"text"},{"type":"codeVoice","code":"performPostHandleWork(...)"},{"text":" function that will be called after the ","type":"text"},{"code":"handle","type":"codeVoice"},{"type":"text","text":" function by the library. Users wishing to"},{"type":"text","text":" "},{"type":"text","text":"add background work can override this function in their "},{"type":"codeVoice","code":"LambdaHandler"},{"text":" conforming object.","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["public protocol LambdaHandler {","    associatedtype Event","    associatedtype Output","","    func handle(_ event: Event, context: LambdaContext) async throws -> Output","","    func performPostHandleWork(...) async throws -> Void","}","","extension LambdaHandler {","    \/\/ User's can override this function if they wish to perform background work","    \/\/ after returning a response from ``handle``.","    func performPostHandleWork(...) async throws -> Void {","        \/\/ nothing to do","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Yet this poses difficulties when the user wishes to use any state created in the "},{"type":"codeVoice","code":"handle(...)"},{"text":" function as part of the","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"background work."}]},{"type":"paragraph","inlineContent":[{"text":"In general, the most common use-case for this library will be to implement simple Lambda functions that do not have","type":"text"},{"type":"text","text":" "},{"text":"requirements for response streaming, nor to perform any background work after returning the output. To keep things easy","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"for the common use-case, and with Swift’s principle of progressive disclosure of complexity in mind, we settled on three"},{"type":"text","text":" "},{"type":"text","text":"handler protocols:"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"code":"LambdaHandler","type":"codeVoice"},{"text":": Most common use-case. JSON-in, JSON-out. Does not support background work execution. An intuitive","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"handle(event: Event, context: LambdaContext) -> Output"},{"type":"text","text":" API that is simple to understand, i.e. users are not exposed"},{"type":"text","text":" "},{"text":"to the concept of sending their response through a writer. ","type":"text"},{"code":"LambdaHandler","type":"codeVoice"},{"type":"text","text":" can be very cleanly implemented and used"},{"type":"text","text":" "},{"type":"text","text":"with "},{"type":"codeVoice","code":"LambdaRuntime"},{"type":"text","text":", especially with "},{"type":"codeVoice","code":"ClosureHandler"},{"type":"text","text":"."}]}]},{"content":[{"inlineContent":[{"code":"LambdaWithBackgroundProcessingHandler","type":"codeVoice"},{"text":": If users wish to augment their ","type":"text"},{"code":"LambdaHandler","type":"codeVoice"},{"text":" with the ability to run","type":"text"},{"type":"text","text":" "},{"type":"text","text":"background tasks, they can easily migrate. A user simply has to:"}],"type":"paragraph"},{"type":"orderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Change the conformance to ","type":"text"},{"type":"codeVoice","code":"LambdaWithBackgroundProcessingHandler"},{"type":"text","text":"."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Add an additional "},{"type":"codeVoice","code":"outputWriter: some LambdaResponseWriter<Output>"},{"type":"text","text":" argument to the "},{"type":"codeVoice","code":"handle"},{"text":" function.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Replace the "},{"type":"codeVoice","code":"return ..."},{"type":"text","text":" with "},{"type":"codeVoice","code":"outputWriter.write(...)"},{"type":"text","text":"."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Implement any background work after ","type":"text"},{"type":"codeVoice","code":"outputWriter.write(...)"},{"type":"text","text":"."}]}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"code":"StreamingLambdaHandler","type":"codeVoice"},{"text":": This is the base handler protocol which is intended to be used directly only for advanced","type":"text"},{"type":"text","text":" "},{"type":"text","text":"use-cases. Users are provided the invocation event as a "},{"type":"codeVoice","code":"ByteBuffer"},{"text":" and a ","type":"text"},{"code":"LambdaResponseStreamWriter","type":"codeVoice"},{"type":"text","text":" where the"},{"text":" ","type":"text"},{"type":"text","text":"computed result (as "},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":") can either be streamed (with repeated calls to "},{"code":"write(_:)","type":"codeVoice"},{"text":") or sent all at once","type":"text"},{"type":"text","text":" "},{"text":"(with a single call to ","type":"text"},{"type":"codeVoice","code":"writeAndFinish(_:)"},{"type":"text","text":"). After closing the "},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"type":"text","text":", any background work can"},{"type":"text","text":" "},{"type":"text","text":"be implemented."}]}]}],"type":"orderedList"},{"level":3,"type":"heading","anchor":"Making-LambdaResponseStreamWriter-and-LambdaResponseWriter-~Copyable","text":"Making LambdaResponseStreamWriter and LambdaResponseWriter ~Copyable"},{"type":"paragraph","inlineContent":[{"text":"We initially proposed to make the ","type":"text"},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"type":"text","text":" and "},{"code":"LambdaResponseWriter","type":"codeVoice"},{"text":" protocols ","type":"text"},{"type":"codeVoice","code":"~Copyable"},{"text":", with","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the functions that close the response having the "},{"code":"consuming","type":"codeVoice"},{"text":" ownership keyword. This was so that the compiler could","type":"text"},{"type":"text","text":" "},{"type":"text","text":"enforce the restriction of not being able to interact with the writer after the response stream has closed."}]},{"type":"paragraph","inlineContent":[{"text":"However, non-copyable types do not compose nicely and add complexity for users. Further, for the compiler to actually","type":"text"},{"type":"text","text":" "},{"text":"enforce the ","type":"text"},{"type":"codeVoice","code":"consuming"},{"type":"text","text":" restrictions, user’s have to explicitly mark the writer argument as "},{"code":"consuming","type":"codeVoice"},{"type":"text","text":" in the "},{"code":"handle","type":"codeVoice"},{"text":" ","type":"text"},{"text":"function.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Therefore, throwing appropriate errors to prevent abnormal interaction with the writers seems to be the simplest","type":"text"},{"type":"text","text":" "},{"text":"approach.","type":"text"}]},{"type":"heading","level":2,"anchor":"A-word-about-versioning","text":"A word about versioning"},{"type":"paragraph","inlineContent":[{"type":"text","text":"We are aware that AWS Lambda Runtime has not reached a proper 1.0. We intend to keep the current implementation around"},{"type":"text","text":" "},{"type":"text","text":"at 1.0-alpha. We don’t want to change the current API without releasing a new major. We think there are lots of adopters"},{"text":" ","type":"text"},{"type":"text","text":"out there that depend on the API in v1. Because of this we intend to release the proposed API here as AWS Lambda Runtime"},{"text":" ","type":"text"},{"type":"text","text":"v2."}]}]}],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/awslambdaruntimecore\/0001-v2-api"]}],"metadata":{"roleHeading":"Article","title":"v2 API proposal for swift-aws-lambda-runtime","role":"article","modules":[{"name":"AWSLambdaRuntimeCore"}]},"hierarchy":{"paths":[["doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore"]]},"identifier":{"url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/0001-v2-api","interfaceLanguage":"swift"},"kind":"article","sections":[],"schemaVersion":{"minor":3,"patch":0,"major":0},"abstract":[{"type":"codeVoice","code":"swift-aws-lambda-runtime"},{"type":"text","text":" is an important library for the Swift on Server ecosystem. The initial API was written before"},{"text":" ","type":"text"},{"type":"text","text":"async\/await was introduced to Swift. When async\/await was introduced, shims were added to bridge between the underlying"},{"type":"text","text":" "},{"type":"text","text":"SwiftNIO "},{"type":"codeVoice","code":"EventLoop"},{"text":" interfaces and async\/await. However, just like ","type":"text"},{"type":"codeVoice","code":"gRPC-swift"},{"type":"text","text":" and "},{"type":"codeVoice","code":"postgres-nio"},{"type":"text","text":", we now want to"},{"text":" ","type":"text"},{"type":"text","text":"shift to solely using async\/await instead of "},{"type":"codeVoice","code":"EventLoop"},{"type":"text","text":" interfaces. For this, large parts of the current API have to be"},{"text":" ","type":"text"},{"text":"reconsidered.","type":"text"}],"references":{"https://docs.aws.amazon.com/lambda/latest/dg/runtimes-api.html#runtimes-api-initerror":{"title":"errors that occur during initialization to the dedicated endpoint AWS exposes","url":"https:\/\/docs.aws.amazon.com\/lambda\/latest\/dg\/runtimes-api.html#runtimes-api-initerror","titleInlineContent":[{"text":"errors that occur during initialization to the dedicated endpoint AWS exposes","type":"text"}],"type":"link","identifier":"https:\/\/docs.aws.amazon.com\/lambda\/latest\/dg\/runtimes-api.html#runtimes-api-initerror"},"https://github.com/swift-server/swift-aws-lambda-runtime/issues/265":{"title":"set up global properties before the Lambda starts-up","url":"https:\/\/github.com\/swift-server\/swift-aws-lambda-runtime\/issues\/265","titleInlineContent":[{"text":"set up global properties before the Lambda starts-up","type":"text"}],"type":"link","identifier":"https:\/\/github.com\/swift-server\/swift-aws-lambda-runtime\/issues\/265"},"doc://AWSLambdaRuntimeCore/documentation/AWSLambdaRuntimeCore":{"url":"\/documentation\/awslambdaruntimecore","type":"topic","identifier":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore","role":"collection","abstract":[{"type":"text","text":"An AWS Lambda runtime for the Swift programming language"}],"kind":"symbol","title":"AWSLambdaRuntimeCore"},"https://docs.aws.amazon.com/lambda/latest/dg/runtimes-custom.html":{"title":"Building a custom runtime for AWS Lambda","url":"https:\/\/docs.aws.amazon.com\/lambda\/latest\/dg\/runtimes-custom.html","titleInlineContent":[{"text":"Building a custom runtime for AWS Lambda","type":"text"}],"identifier":"https:\/\/docs.aws.amazon.com\/lambda\/latest\/dg\/runtimes-custom.html","type":"link"},"https://aws.amazon.com/blogs/compute/running-code-after-returning-a-response-from-an-aws-lambda-function/":{"title":"AWS described in a blog post that you can run background tasks in Lambda","url":"https:\/\/aws.amazon.com\/blogs\/compute\/running-code-after-returning-a-response-from-an-aws-lambda-function\/","type":"link","identifier":"https:\/\/aws.amazon.com\/blogs\/compute\/running-code-after-returning-a-response-from-an-aws-lambda-function\/","titleInlineContent":[{"text":"AWS described in a blog post that you can run background tasks in Lambda","type":"text"}]},"https://aws.amazon.com/blogs/compute/introducing-aws-lambda-response-streaming/":{"title":"AWS introduced support for response streaming","url":"https:\/\/aws.amazon.com\/blogs\/compute\/introducing-aws-lambda-response-streaming\/","type":"link","identifier":"https:\/\/aws.amazon.com\/blogs\/compute\/introducing-aws-lambda-response-streaming\/","titleInlineContent":[{"text":"AWS introduced support for response streaming","type":"text"}]}}}