{"variants":[{"paths":["\/documentation\/awslambdaruntimecore\/0001-v2-api"],"traits":[{"interfaceLanguage":"swift"}]}],"hierarchy":{"paths":[["doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore"]]},"schemaVersion":{"minor":3,"patch":0,"major":0},"abstract":[{"code":"swift-aws-lambda-runtime","type":"codeVoice"},{"text":" is an important library for the Swift on Server ecosystem. The initial API was written before","type":"text"},{"type":"text","text":" "},{"type":"text","text":"async\/await was introduced to Swift. When async\/await was introduced, shims were added to bridge between the underlying"},{"type":"text","text":" "},{"text":"SwiftNIO ","type":"text"},{"type":"codeVoice","code":"EventLoop"},{"text":" interfaces and async\/await. However, just like ","type":"text"},{"code":"gRPC-swift","type":"codeVoice"},{"type":"text","text":" and "},{"code":"postgres-nio","type":"codeVoice"},{"text":", we now want to","type":"text"},{"type":"text","text":" "},{"type":"text","text":"shift to solely using async\/await instead of "},{"code":"EventLoop","type":"codeVoice"},{"type":"text","text":" interfaces. For this, large parts of the current API have to be"},{"text":" ","type":"text"},{"type":"text","text":"reconsidered."}],"metadata":{"title":"v2 API proposal for swift-aws-lambda-runtime","roleHeading":"Article","role":"article","modules":[{"name":"AWSLambdaRuntimeCore"}]},"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","type":"heading","text":"Overview","level":2},{"type":"paragraph","inlineContent":[{"text":"Versions:","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"v1 (2024-08-07): Initial version"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"v1.1:"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Remove the "},{"code":"reportError(_:)","type":"codeVoice"},{"type":"text","text":" method from "},{"code":"LambdaResponseStreamWriter","type":"codeVoice"},{"type":"text","text":" and instead make the "},{"code":"handle(...)","type":"codeVoice"},{"text":" method of","type":"text"},{"type":"text","text":" "},{"code":"StreamingLambdaHandler","type":"codeVoice"},{"text":" throwing.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Remove the "},{"code":"addBackgroundTask(_:)","type":"codeVoice"},{"type":"text","text":" method from "},{"code":"LambdaContext","type":"codeVoice"},{"type":"text","text":" due to structured concurrency concerns and introduce"},{"text":" ","type":"text"},{"text":"the ","type":"text"},{"type":"codeVoice","code":"LambdaWithBackgroundProcessingHandler"},{"text":" protocol as a solution.","type":"text"}]},{"items":[{"content":[{"inlineContent":[{"text":"Introduce ","type":"text"},{"type":"codeVoice","code":"LambdaHandlerAdapter"},{"type":"text","text":", which adapts handlers conforming to "},{"type":"codeVoice","code":"LambdaHandler"},{"text":" with","type":"text"},{"text":" ","type":"text"},{"code":"LambdaWithBackgroundProcessingHandler","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Update ","type":"text"},{"code":"LambdaCodableAdapter","type":"codeVoice"},{"type":"text","text":" to now be generic over any handler conforming to"},{"type":"text","text":" "},{"type":"codeVoice","code":"LambdaWithBackgroundProcessingHandler"},{"text":" instead of ","type":"text"},{"type":"codeVoice","code":"LambdaHandler"},{"text":".","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"}]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"v1.2:"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"Remove "},{"type":"codeVoice","code":"~Copyable"},{"type":"text","text":" from "},{"code":"LambdaResponseStreamWriter","type":"codeVoice"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"LambdaResponseWriter"},{"type":"text","text":". Instead throw an error when"},{"text":" ","type":"text"},{"type":"codeVoice","code":"finish()"},{"type":"text","text":" is called multiple times or when "},{"type":"codeVoice","code":"write"},{"text":"\/","type":"text"},{"type":"codeVoice","code":"writeAndFinish"},{"type":"text","text":" is called after "},{"code":"finish()","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"}]}]}]}]},{"text":"Motivation","type":"heading","level":2,"anchor":"Motivation"},{"anchor":"Current-Limitations","type":"heading","level":3,"text":"Current Limitations"},{"text":"EventLoop interfaces","level":4,"type":"heading","anchor":"EventLoop-interfaces"},{"type":"paragraph","inlineContent":[{"text":"The current API extensively uses the ","type":"text"},{"type":"codeVoice","code":"EventLoop"},{"type":"text","text":" family of interfaces from SwiftNIO in many areas. To use these"},{"text":" ","type":"text"},{"text":"interfaces correctly though, it requires developers to exercise great care and understand the various transform methods","type":"text"},{"type":"text","text":" "},{"text":"that are used to work with ","type":"text"},{"type":"codeVoice","code":"EventLoop"},{"type":"text","text":"s and "},{"type":"codeVoice","code":"EventLoopFuture"},{"type":"text","text":"s. This results in a lot of cognitive complexity and makes"},{"text":" ","type":"text"},{"text":"the code in the current API hard to reason about and maintain. For these reasons, the overarching trend in the Swift on","type":"text"},{"text":" ","type":"text"},{"text":"Server ecosystem is to shift to newer, more readable, Swift concurrency constructs and de-couple from SwiftNIO’s","type":"text"},{"text":" ","type":"text"},{"code":"EventLoop","type":"codeVoice"},{"text":" interfaces.","type":"text"}]},{"text":"No ownership of the main() function","anchor":"No-ownership-of-the-main-function","level":4,"type":"heading"},{"inlineContent":[{"text":"A Lambda function can currently be implemented through conformance to the various handler protocols defined in","type":"text"},{"text":" ","type":"text"},{"code":"AWSLambdaRuntimeCore\/LambdaHandler","type":"codeVoice"},{"type":"text","text":". Each of these protocols have an extension which implements a "},{"type":"codeVoice","code":"static func main()"},{"text":".","type":"text"},{"type":"text","text":" "},{"type":"text","text":"This allows users to annotate their "},{"type":"codeVoice","code":"LambdaHandler"},{"text":" conforming object with ","type":"text"},{"code":"@main","type":"codeVoice"},{"text":". The ","type":"text"},{"code":"static func main()","type":"codeVoice"},{"type":"text","text":" calls the"},{"text":" ","type":"text"},{"type":"text","text":"internal "},{"type":"codeVoice","code":"Lambda.run()"},{"text":" function, which starts the Lambda function. Since the ","type":"text"},{"code":"Lambda.run()","type":"codeVoice"},{"type":"text","text":" method is internal, users"},{"type":"text","text":" "},{"text":"cannot override the default implementation. This has proven challenging for users who want to","type":"text"},{"type":"text","text":" "},{"type":"reference","identifier":"https:\/\/github.com\/swift-server\/swift-aws-lambda-runtime\/issues\/265","isActive":true},{"type":"text","text":"."},{"text":" ","type":"text"},{"type":"text","text":"Setting up global properties is required to customize the Swift Logging, Metric and Tracing backend."}],"type":"paragraph"},{"level":4,"type":"heading","text":"Non-trivial transition from SimpleLambdaHandler to LambdaHandler","anchor":"Non-trivial-transition-from-SimpleLambdaHandler-to-LambdaHandler"},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"SimpleLambdaHandler"},{"type":"text","text":" protocol provides a quick and easy way to implement a basic Lambda function. It only requires"},{"type":"text","text":" "},{"type":"text","text":"an implementation of the "},{"type":"codeVoice","code":"handle"},{"text":" function where the business logic of the Lambda function can be written.","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"SimpleLambdaHandler"},{"type":"text","text":" is perfectly sufficient for small use-cases as the user does not need to spend much time looking"},{"type":"text","text":" "},{"text":"into the library.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"However, "},{"type":"codeVoice","code":"SimpleLambdaHandler"},{"type":"text","text":" cannot be used when services such as a database client need to be initialized before the"},{"type":"text","text":" "},{"type":"text","text":"Lambda runtime starts and then also gracefully shutdown prior to the runtime terminating. This is because the only way"},{"type":"text","text":" "},{"text":"to register termination logic is through the ","type":"text"},{"type":"codeVoice","code":"LambdaInitializationContext"},{"text":" (containing a field","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"terminator: LambdaTerminator"},{"type":"text","text":") which is created and used "},{"inlineContent":[{"type":"text","text":"internally"}],"type":"emphasis"},{"text":" within ","type":"text"},{"type":"codeVoice","code":"LambdaRuntime"},{"type":"text","text":" and never exposed through"},{"text":" ","type":"text"},{"type":"codeVoice","code":"SimpleLambdaHandler"},{"type":"text","text":". For such use-cases, other handler protocols like "},{"code":"LambdaHandler","type":"codeVoice"},{"text":" must be used. ","type":"text"},{"code":"LambdaHandler","type":"codeVoice"},{"type":"text","text":" "},{"text":"exposes a ","type":"text"},{"code":"context","type":"codeVoice"},{"text":" argument of type ","type":"text"},{"type":"codeVoice","code":"LambdaInitializationContext"},{"text":" through its initializer. Within the initializer,","type":"text"},{"text":" ","type":"text"},{"text":"required services can be initialized and their graceful shutdown logic can be registered with the","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"context.terminator.register"},{"text":" function.","type":"text"}]},{"inlineContent":[{"type":"text","text":"Yet, "},{"type":"codeVoice","code":"LambdaHandler"},{"text":" is quite cumbersome to use in such use-cases as users have to deviate from the established norms of","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"the Swift on Server ecosystem in order to cleanly manage the lifecycle of the services intended to be used. This is"},{"text":" ","type":"text"},{"text":"because the convenient ","type":"text"},{"code":"swift-service-lifecycle","type":"codeVoice"},{"text":" v2 library — which is commonly used for cleanly managing the lifecycles","type":"text"},{"type":"text","text":" "},{"type":"text","text":"of required services and widely supported by many libraries — cannot be used in a structured concurrency manner."}],"type":"paragraph"},{"level":4,"type":"heading","text":"Does not integrate well with swift-service-lifecycle in a structured concurrency manner","anchor":"Does-not-integrate-well-with-swift-service-lifecycle-in-a-structured-concurrency-manner"},{"inlineContent":[{"text":"The Lambda runtime can only be started using the ","type":"text"},{"inlineContent":[{"type":"text","text":"internal"}],"type":"strong"},{"type":"text","text":" "},{"type":"codeVoice","code":"Lambda.run()"},{"type":"text","text":" function. This function is called by the"},{"text":" ","type":"text"},{"code":"main()","type":"codeVoice"},{"type":"text","text":" function defined by the "},{"type":"codeVoice","code":"LambdaHandler"},{"type":"text","text":" protocol, preventing users from injecting initialized services into the"},{"type":"text","text":" "},{"text":"runtime ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"prior","type":"text"}]},{"type":"text","text":" to it starting. As shown below, this forces users to use an "},{"type":"strong","inlineContent":[{"type":"text","text":"unstructured concurrency"}]},{"type":"text","text":" approach and"},{"type":"text","text":" "},{"text":"manually initialize services, leading to the issue of the user then perhaps forgetting to gracefully shutdown the","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"initialized services:"}],"type":"paragraph"},{"syntax":"swift","code":["struct MyLambda: LambdaHandler {","    let pgClient: PostgresClient","","    init(context: AWSLambdaRuntimeCore.LambdaInitializationContext) async throws {","        \/\/\/ Instantiate service","        let client = PostgresClient(configuration: ...)","","        \/\/\/ Unstructured concurrency to initialize the service","        let pgTask = Task {","            await client.run()","        }","","        \/\/\/ Store the client in `self` so that it can be used in `handle(...)`","        self.pgClient = client","","        \/\/\/ !!! Must remember to explicitly register termination logic for PostgresClient !!!","        context.terminator.register(","           name: \"PostgreSQL Client\",","           handler: { eventLoop in","               pgTask.cancel()","               return eventLoop.makeFutureWithTask {","                  await pgTask.value","               }","           }","        )","    }","","    func handle(_ event: Event, context: LambdaContext) async throws -> Output {","        \/\/\/ Use the initialized service stored in `self.pgClient`","        try await self.pgClient.query(...)","    }","}"],"type":"codeListing"},{"anchor":"Verbose-Codable-support","level":4,"text":"Verbose Codable support","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"In the current API, there are extensions and Codable wrapper classes for decoding events and encoding computed responses","type":"text"},{"type":"text","text":" "},{"type":"text","text":"for "},{"type":"emphasis","inlineContent":[{"type":"text","text":"each"}]},{"text":" different handler protocol and for both ","type":"text"},{"type":"codeVoice","code":"String"},{"type":"text","text":" and "},{"type":"codeVoice","code":"JSON"},{"type":"text","text":" formats. This has resulted in a lot of"},{"text":" ","type":"text"},{"type":"text","text":"boilerplate code which can very easily be made generic and simplified in v2."}]},{"text":"New features","level":3,"type":"heading","anchor":"New-features"},{"type":"heading","level":4,"text":"Support response streaming","anchor":"Support-response-streaming"},{"type":"paragraph","inlineContent":[{"text":"In April 2023","type":"text"},{"type":"text","text":" "},{"isActive":true,"type":"reference","identifier":"https:\/\/aws.amazon.com\/blogs\/compute\/introducing-aws-lambda-response-streaming\/"},{"type":"text","text":" "},{"type":"text","text":"in Lambda. The current API does not support streaming. For v2 we want to change this."}]},{"anchor":"Scheduling-background-work","level":4,"type":"heading","text":"Scheduling background work"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In May"},{"type":"text","text":" "},{"identifier":"https:\/\/aws.amazon.com\/blogs\/compute\/running-code-after-returning-a-response-from-an-aws-lambda-function\/","type":"reference","isActive":true},{"text":" ","type":"text"},{"type":"text","text":"until the runtime asks for more work from the control plane. We want to support this by adding new API that allows"},{"text":" ","type":"text"},{"text":"background processing, even after the response has been returned.","type":"text"}]},{"level":2,"type":"heading","text":"Proposed Solution","anchor":"Proposed-Solution"},{"anchor":"asyncawait-first-API","type":"heading","text":"async\/await-first API","level":3},{"type":"paragraph","inlineContent":[{"text":"Large parts of ","type":"text"},{"code":"Lambda","type":"codeVoice"},{"type":"text","text":", "},{"code":"LambdaHandler","type":"codeVoice"},{"type":"text","text":", and "},{"type":"codeVoice","code":"LambdaRuntime"},{"text":" will be re-written to use async\/await constructs in place","type":"text"},{"type":"text","text":" "},{"type":"text","text":"of the "},{"code":"EventLoop","type":"codeVoice"},{"text":" family of interfaces.","type":"text"}]},{"text":"Providing ownership of main() and support for swift-service-lifecycle","anchor":"Providing-ownership-of-main-and-support-for-swift-service-lifecycle","level":3,"type":"heading"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Instead of conforming to a handler protocol, users can now create a "},{"code":"LambdaRuntime","type":"codeVoice"},{"type":"text","text":" by passing in a handler closure."}]}]},{"content":[{"inlineContent":[{"type":"codeVoice","code":"LambdaRuntime"},{"text":" conforms to ","type":"text"},{"type":"codeVoice","code":"ServiceLifecycle.Service"},{"type":"text","text":" by implementing a "},{"code":"run()","type":"codeVoice"},{"text":" method that contains initialization","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and graceful shutdown logic."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"This allows the lifecycle of the "},{"code":"LambdaRuntime","type":"codeVoice"},{"type":"text","text":" to be managed with "},{"code":"swift-service-lifecycle","type":"codeVoice"},{"text":" ","type":"text"},{"inlineContent":[{"type":"text","text":"alongside"}],"type":"emphasis"},{"type":"text","text":" and in the"},{"type":"text","text":" "},{"type":"text","text":"same way the lifecycles of the required services are managed, e.g."},{"type":"text","text":" "},{"code":"try await ServiceGroup(services: [postgresClient, ..., lambdaRuntime], ...).run()","type":"codeVoice"},{"text":".","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Dependencies can now be injected into "},{"code":"LambdaRuntime","type":"codeVoice"},{"type":"text","text":". With "},{"type":"codeVoice","code":"swift-service-lifecycle"},{"text":", services will be initialized","type":"text"},{"text":" ","type":"text"},{"text":"together with ","type":"text"},{"code":"LambdaRuntime","type":"codeVoice"},{"type":"text","text":"."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"The required services can then be used within the handler in a structured concurrency manner.","type":"text"},{"type":"text","text":" "},{"code":"swift-service-lifecycle","type":"codeVoice"},{"type":"text","text":" takes care of listening for termination signals and terminating the services as well as the"},{"type":"text","text":" "},{"code":"LambdaRuntime","type":"codeVoice"},{"type":"text","text":" in correct order."}]}]},{"content":[{"inlineContent":[{"type":"codeVoice","code":"LambdaTerminator"},{"type":"text","text":" can now be eliminated because its role is replaced with "},{"type":"codeVoice","code":"swift-service-lifecycle"},{"type":"text","text":". The termination"},{"type":"text","text":" "},{"type":"text","text":"logic of the Lambda function will be implemented in the conforming "},{"code":"run()","type":"codeVoice"},{"text":" function of ","type":"text"},{"code":"LambdaRuntime","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"With this, the earlier code snippet can be replaced with something much easier to read, maintain, and debug:"}]},{"code":["\/\/\/ Instantiate services","let postgresClient = PostgresClient()","","\/\/\/ Instantiate LambdaRuntime with a closure handler implementing the business logic of the Lambda function","let runtime = LambdaRuntime { (event: Input, context: LambdaContext) in","    \/\/\/ Use initialized service within the handler","    try await postgresClient.query(...)","}","","\/\/\/ Use ServiceLifecycle to manage the initialization and termination","\/\/\/ of the services as well as the LambdaRuntime","let serviceGroup = ServiceGroup(","    services: [postgresClient, runtime],","    configuration: .init(gracefulShutdownSignals: [.sigterm]),","    logger: logger",")","try await serviceGroup.run()"],"type":"codeListing","syntax":"swift"},{"text":"Simplifying Codable support","type":"heading","level":3,"anchor":"Simplifying-Codable-support"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A detailed explanation is provided in the "},{"inlineContent":[{"text":"Codable Support","type":"text"}],"type":"strong"},{"text":" section. In short, much of the boilerplate code defined","type":"text"},{"type":"text","text":" "},{"type":"text","text":"for each handler protocol in "},{"type":"codeVoice","code":"Lambda+Codable"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Lambda+String"},{"type":"text","text":" will be replaced with a single "},{"type":"codeVoice","code":"LambdaCodableAdapter"},{"text":" ","type":"text"},{"text":"struct.","type":"text"}]},{"inlineContent":[{"type":"text","text":"This adapter struct is generic over (1) any handler conforming to a new handler protocol"},{"type":"text","text":" "},{"type":"codeVoice","code":"LambdaWithBackgroundProcessingHandler"},{"text":", (2) the user-specified input and output types, and (3) any decoder and encoder","type":"text"},{"type":"text","text":" "},{"type":"text","text":"conforming to protocols "},{"code":"LambdaEventDecoder","type":"codeVoice"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"LambdaOutputDecoder"},{"type":"text","text":". The adapter will wrap the underlying handler"},{"text":" ","type":"text"},{"type":"text","text":"with encoding\/decoding logic."}],"type":"paragraph"},{"text":"Detailed Solution","level":2,"type":"heading","anchor":"Detailed-Solution"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Below are explanations for all types that we want to use in AWS Lambda Runtime v2."}]},{"text":"LambdaResponseStreamWriter","type":"heading","anchor":"LambdaResponseStreamWriter","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"We will introduce a new "},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"type":"text","text":" protocol. It is used in the new "},{"type":"codeVoice","code":"StreamingLambdaHandler"},{"text":" (defined","type":"text"},{"type":"text","text":" "},{"text":"below), which is the new base protocol for the ","type":"text"},{"code":"LambdaRuntime","type":"codeVoice"},{"type":"text","text":" (defined below as well)."}]},{"type":"codeListing","syntax":"swift","code":["\/\/\/ A writer object to write the Lambda response stream into","public protocol LambdaResponseStreamWriter {","    \/\/\/ Write a response part into the stream. The HTTP response is started lazily before the first call to `write(_:)`.","    \/\/\/ Bytes written to the writer are streamed continually.","    func write(_ buffer: ByteBuffer) async throws","    \/\/\/ End the response stream and the underlying HTTP response.","    func finish() async throws","    \/\/\/ Write a response part into the stream and end the response stream as well as the underlying HTTP response.","    func writeAndFinish(_ buffer: ByteBuffer) async throws","}"]},{"inlineContent":[{"type":"text","text":"If the user does not call "},{"type":"codeVoice","code":"finish()"},{"type":"text","text":", the library will automatically finish the stream after the last "},{"type":"codeVoice","code":"write"},{"type":"text","text":"."},{"type":"text","text":" "},{"text":"Appropriate errors will be thrown if ","type":"text"},{"code":"finish()","type":"codeVoice"},{"type":"text","text":" is called multiple times, or if "},{"code":"write","type":"codeVoice"},{"type":"text","text":"\/"},{"type":"codeVoice","code":"writeAndFinish"},{"type":"text","text":" is called after"},{"text":" ","type":"text"},{"type":"codeVoice","code":"finish()"},{"type":"text","text":"."}],"type":"paragraph"},{"level":3,"anchor":"LambdaContext","type":"heading","text":"LambdaContext"},{"inlineContent":[{"code":"LambdaContext","type":"codeVoice"},{"text":" will be largely unchanged, but the ","type":"text"},{"type":"codeVoice","code":"eventLoop"},{"type":"text","text":" property will be removed. The "},{"code":"allocator","type":"codeVoice"},{"text":" property of","type":"text"},{"text":" ","type":"text"},{"text":"type ","type":"text"},{"type":"codeVoice","code":"ByteBufferAllocator"},{"type":"text","text":" will also be removed because (1), we generally want to reduce the number of SwiftNIO types"},{"text":" ","type":"text"},{"type":"text","text":"exposed in the API, and (2), "},{"code":"ByteBufferAllocator","type":"codeVoice"},{"type":"text","text":" does not optimize the allocation strategies. The common pattern"},{"type":"text","text":" "},{"type":"text","text":"observed across many libraries is to re-use existing "},{"code":"ByteBuffer","type":"codeVoice"},{"type":"text","text":"s as much as possible. This is also what we do for the"},{"type":"text","text":" "},{"code":"LambdaCodableAdapter","type":"codeVoice"},{"text":" (explained in the ","type":"text"},{"inlineContent":[{"text":"Codable Support","type":"text"}],"type":"strong"},{"text":" section) implementation.","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["\/\/\/ A context object passed as part of an invocation in LambdaHandler handle functions.","public struct LambdaContext: Sendable {","    \/\/\/ The request ID, which identifies the request that triggered the function invocation.","    public var requestID: String { get }","","    \/\/\/ The AWS X-Ray tracing header.","    public var traceID: String { get }","","    \/\/\/ The ARN of the Lambda function, version, or alias that's specified in the invocation.","    public var invokedFunctionARN: String { get }","","    \/\/\/ The timestamp that the function times out.","    public var deadline: DispatchWallTime { get }","","    \/\/\/ For invocations from the AWS Mobile SDK, data about the Amazon Cognito identity provider.","    public var cognitoIdentity: String? { get }","","    \/\/\/ For invocations from the AWS Mobile SDK, data about the client application and device.","    public var clientContext: String? { get }","","    \/\/\/ `Logger` to log with.","    \/\/\/","    \/\/\/ - note: The `LogLevel` can be configured using the `LOG_LEVEL` environment variable.","    public var logger: Logger { get }","}"],"syntax":"swift"},{"anchor":"Handlers","text":"Handlers","level":3,"type":"heading"},{"type":"paragraph","inlineContent":[{"text":"We introduce three handler protocols: ","type":"text"},{"code":"StreamingLambdaHandler","type":"codeVoice"},{"type":"text","text":", "},{"code":"LambdaHandler","type":"codeVoice"},{"text":", and","type":"text"},{"type":"text","text":" "},{"code":"LambdaWithBackgroundProcessingHandler","type":"codeVoice"},{"text":".","type":"text"}]},{"level":4,"type":"heading","text":"StreamingLambdaHandler","anchor":"StreamingLambdaHandler"},{"inlineContent":[{"type":"text","text":"The new "},{"code":"StreamingLambdaHandler","type":"codeVoice"},{"text":" protocol is the base protocol to implement a Lambda function. Most users will not use","type":"text"},{"text":" ","type":"text"},{"text":"this protocol and instead use the ","type":"text"},{"type":"codeVoice","code":"LambdaHandler"},{"text":" protocol defined below.","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["\/\/\/ The base StreamingLambdaHandler protocol","public protocol StreamingLambdaHandler {","    \/\/\/ The business logic of the Lambda function","    \/\/\/ - Parameters:","    \/\/\/   - event: The invocation's input data","    \/\/\/   - responseWriter: A ``LambdaResponseStreamWriter`` to write the invocation's response to.","    \/\/\/                     If no response or error is written to the `responseWriter` it will","    \/\/\/                     report an error to the invoker.","    \/\/\/   - context: The LambdaContext containing the invocation's metadata","    \/\/\/ - Throws:","    \/\/\/ How the thrown error will be handled by the runtime:","    \/\/\/   - An invocation error will be reported if the error is thrown before the first call to","    \/\/\/     ``LambdaResponseStreamWriter.write(_:)``.","    \/\/\/   - If the error is thrown after call(s) to ``LambdaResponseStreamWriter.write(_:)`` but before","    \/\/\/     a call to ``LambdaResponseStreamWriter.finish()``, the response stream will be closed and trailing","    \/\/\/     headers will be sent.","    \/\/\/   - If ``LambdaResponseStreamWriter.finish()`` has already been called before the error is thrown, the","    \/\/\/     error will be logged.","    mutating func handle(_ event: ByteBuffer, responseWriter: some LambdaResponseStreamWriter, context: LambdaContext) async throws","}"]},{"inlineContent":[{"text":"Using this protocol requires the ","type":"text"},{"type":"codeVoice","code":"handle"},{"type":"text","text":" method to receive the incoming event as a "},{"code":"ByteBuffer","type":"codeVoice"},{"type":"text","text":" and return the output"},{"text":" ","type":"text"},{"text":"as a ","type":"text"},{"type":"codeVoice","code":"ByteBuffer"},{"text":" too.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Through the ","type":"text"},{"code":"LambdaResponseStreamWriter","type":"codeVoice"},{"type":"text","text":", which is passed as an argument in the "},{"code":"handle","type":"codeVoice"},{"text":" function, the ","type":"text"},{"type":"strong","inlineContent":[{"text":"response can be","type":"text"},{"text":" ","type":"text"},{"text":"streamed","type":"text"}]},{"text":" by calling the ","type":"text"},{"type":"codeVoice","code":"write(_:)"},{"text":" function of the ","type":"text"},{"code":"LambdaResponseStreamWriter","type":"codeVoice"},{"type":"text","text":" with partial data repeatedly before"},{"text":" ","type":"text"},{"type":"text","text":"finally closing the response stream by calling "},{"type":"codeVoice","code":"finish()"},{"type":"text","text":". Users can also choose to return the entire output and not"},{"type":"text","text":" "},{"type":"text","text":"stream the response by calling "},{"code":"writeAndFinish(_:)","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"This protocol also allows for background tasks to be run after a result has been reported to the AWS Lambda control","type":"text"},{"type":"text","text":" "},{"text":"plane, since the ","type":"text"},{"code":"handle(...)","type":"codeVoice"},{"text":" function is free to implement any background work after the call to","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"responseWriter.finish()"},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"The protocol is defined in a way that supports a broad range of use-cases. The handle method is marked as ","type":"text"},{"type":"codeVoice","code":"mutating"},{"type":"text","text":" to"},{"type":"text","text":" "},{"text":"allow handlers to be implemented with a ","type":"text"},{"type":"codeVoice","code":"struct"},{"type":"text","text":"."}]},{"inlineContent":[{"type":"text","text":"An implementation that sends the number 1 to 10 every 500ms could look like this:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["struct SendNumbersWithPause: StreamingLambdaHandler {","    func handle(","        _ event: ByteBuffer,","        responseWriter: some LambdaResponseStreamWriter,","        context: LambdaContext","    ) async throws {","        for i in 1...10 {","            \/\/ Send partial data","            responseWriter.write(ByteBuffer(string: #\"\\#(i)\\n\\r\"#))","            \/\/ Perform some long asynchronous work","            try await Task.sleep(for: .milliseconds(500))","        }","        \/\/ All data has been sent. Close off the response stream.","        responseWriter.finish()","    }","}"]},{"text":"LambdaHandler:","type":"heading","anchor":"LambdaHandler","level":4},{"inlineContent":[{"text":"This handler protocol will be the go-to choice for most use-cases because it is completely agnostic to any","type":"text"},{"type":"text","text":" "},{"type":"text","text":"encoding\/decoding logic – conforming objects simply have to implement the "},{"type":"codeVoice","code":"handle"},{"type":"text","text":" function where the input and return"},{"text":" ","type":"text"},{"type":"text","text":"types are Swift objects."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that the "},{"type":"codeVoice","code":"handle"},{"text":" function does not receive a ","type":"text"},{"code":"LambdaResponseStreamWriter","type":"codeVoice"},{"text":" as an argument. Response streaming is","type":"text"},{"text":" ","type":"text"},{"text":"not viable for ","type":"text"},{"type":"codeVoice","code":"LambdaHandler"},{"text":" because the output has to be encoded prior to it being sent, e.g. it is not possible to","type":"text"},{"text":" ","type":"text"},{"text":"encode a partial\/incomplete JSON string.","type":"text"}]},{"code":["public protocol LambdaHandler {","    \/\/\/ Generic input type","    \/\/\/ The body of the request sent to Lambda will be decoded into this type for the handler to consume","    associatedtype Event","    \/\/\/ Generic output type","    \/\/\/ This is the return type of the handle() function.","    associatedtype Output","","    \/\/\/ The business logic of the Lambda function. Receives a generic input type and returns a generic output type.","    \/\/\/ Agnostic to encoding\/decoding","    mutating func handle(_ event: Event, context: LambdaContext) async throws -> Output","}"],"type":"codeListing","syntax":"swift"},{"text":"LambdaWithBackgroundProcessingHandler:","type":"heading","level":4,"anchor":"LambdaWithBackgroundProcessingHandler"},{"inlineContent":[{"type":"text","text":"This protocol is exactly like "},{"type":"codeVoice","code":"LambdaHandler"},{"type":"text","text":", with the only difference being the added support for executing background"},{"type":"text","text":" "},{"type":"text","text":"work after the result has been sent to the AWS Lambda control plane."}],"type":"paragraph"},{"inlineContent":[{"text":"This is achieved by not having a return type in the ","type":"text"},{"type":"codeVoice","code":"handle"},{"text":" function. The output is instead written into a","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"LambdaResponseWriter"},{"type":"text","text":" that is passed in as an argument, meaning that the "},{"code":"handle","type":"codeVoice"},{"type":"text","text":" function is then free to implement"},{"text":" ","type":"text"},{"type":"text","text":"any background work after the result has been sent to the AWS Lambda control plane."}],"type":"paragraph"},{"inlineContent":[{"code":"LambdaResponseWriter","type":"codeVoice"},{"type":"text","text":" has different semantics to the "},{"code":"LambdaResponseStreamWriter","type":"codeVoice"},{"type":"text","text":". Where the "},{"type":"codeVoice","code":"write(_:)"},{"type":"text","text":" function of"},{"text":" ","type":"text"},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"type":"text","text":" means writing into a response stream, the "},{"type":"codeVoice","code":"write(_:)"},{"type":"text","text":" function of "},{"type":"codeVoice","code":"LambdaResponseWriter"},{"text":" ","type":"text"},{"type":"text","text":"simply serves as a mechanism to return the output without explicitly returning from the "},{"code":"handle","type":"codeVoice"},{"text":" function.","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["public protocol LambdaResponseWriter<Output> {","    associatedtype Output","","    \/\/\/ Sends the generic Output object (representing the computed result of the handler)","    \/\/\/ to the AWS Lambda response endpoint.","    \/\/\/ An error will be thrown if this function is called more than once.","    func write(_: Output) async throws","}","","public protocol LambdaWithBackgroundProcessingHandler {","    \/\/\/ Generic input type","    \/\/\/ The body of the request sent to Lambda will be decoded into this type for the handler to consume","    associatedtype Event","    \/\/\/ Generic output type","    \/\/\/ This is the type that the handle() function will send through the ``LambdaResponseWriter``.","    associatedtype Output","","    \/\/\/ The business logic of the Lambda function. Receives a generic input type and returns a generic output type.","    \/\/\/ Agnostic to JSON encoding\/decoding","    func handle(","        _ event: Event,","        outputWriter: some LambdaResponseWriter<Output>,","        context: LambdaContext","    ) async throws","}"]},{"text":"Example Usage:","level":5,"anchor":"Example-Usage","type":"heading"},{"code":["struct BackgroundProcessingHandler: LambdaWithBackgroundProcessingHandler {","    struct Input: Decodable {","        let message: String","    }","","    struct Greeting: Encodable {","        let echoedMessage: String","    }","","    typealias Event = Input","    typealias Output = Greeting","","    func handle(","        _ event: Event,","        outputWriter: some LambdaResponseWriter<Output>,","        context: LambdaContext","    ) async throws {","        \/\/ Return result to the Lambda control plane","        try await outputWriter.write(result: Greeting(echoedMessage: event.messageToEcho))","","        \/\/ Perform some background work, e.g:","        try await Task.sleep(for: .seconds(10))","","        \/\/ Exit the function. All asynchronous work has been executed before exiting the scope of this function.","        \/\/ Follows structured concurrency principles.","        return","    }","}"],"type":"codeListing","syntax":"swift"},{"anchor":"Handler-Adapters","level":4,"type":"heading","text":"Handler Adapters"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Since the "},{"code":"StreamingLambdaHandler","type":"codeVoice"},{"text":" protocol is the base protocol the ","type":"text"},{"type":"codeVoice","code":"LambdaRuntime"},{"type":"text","text":" works with, there are adapters to"},{"text":" ","type":"text"},{"text":"make both ","type":"text"},{"type":"codeVoice","code":"LambdaHandler"},{"type":"text","text":" and "},{"code":"LambdaWithBackgroundProcessingHandler","type":"codeVoice"},{"type":"text","text":" compatible with "},{"code":"StreamingLambdaHandler","type":"codeVoice"},{"text":".","type":"text"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"code":"LambdaHandlerAdapter","type":"codeVoice"},{"text":" accepts a ","type":"text"},{"code":"LambdaHandler","type":"codeVoice"},{"text":" and conforms it to ","type":"text"},{"type":"codeVoice","code":"LambdaWithBackgroundProcessingHandler"},{"type":"text","text":". This is"},{"text":" ","type":"text"},{"text":"achieved by taking the generic ","type":"text"},{"type":"codeVoice","code":"Output"},{"type":"text","text":" object returned from the "},{"code":"handle","type":"codeVoice"},{"type":"text","text":" function of "},{"code":"LambdaHandler","type":"codeVoice"},{"type":"text","text":" and passing it"},{"text":" ","type":"text"},{"text":"to the ","type":"text"},{"type":"codeVoice","code":"write(_:)"},{"type":"text","text":" function of the "},{"type":"codeVoice","code":"LambdaResponseWriter"},{"type":"text","text":"."}]}]},{"content":[{"inlineContent":[{"code":"LambdaCodableAdapter","type":"codeVoice"},{"type":"text","text":" accepts a "},{"code":"LambdaWithBackgroundProcessingHandler","type":"codeVoice"},{"text":" and conforms it to ","type":"text"},{"code":"StreamingLambdaHandler","type":"codeVoice"},{"text":".","type":"text"},{"type":"text","text":" "},{"type":"text","text":"This is achieved by wrapping the "},{"type":"codeVoice","code":"LambdaResponseWriter"},{"type":"text","text":" with the "},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"text":" provided by","type":"text"},{"type":"text","text":" "},{"code":"StreamingLambdaHandler","type":"codeVoice"},{"type":"text","text":". A call to the "},{"type":"codeVoice","code":"write(_:)"},{"text":" function of ","type":"text"},{"code":"LambdaResponseWriter","type":"codeVoice"},{"text":" is translated into a call to","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"the "},{"type":"codeVoice","code":"writeAndFinish(_:)"},{"type":"text","text":" function of "},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"type":"text","text":"."}],"type":"paragraph"}]}],"type":"orderedList"},{"inlineContent":[{"text":"Both ","type":"text"},{"type":"codeVoice","code":"LambdaHandlerAdapter"},{"type":"text","text":" and "},{"code":"LambdaCodableAdapter","type":"codeVoice"},{"type":"text","text":" are described in greater detail in the "},{"type":"strong","inlineContent":[{"text":"Codable Support","type":"text"}]},{"text":" ","type":"text"},{"type":"text","text":"section."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"To summarize, "},{"type":"codeVoice","code":"LambdaHandler"},{"text":" can be used with the ","type":"text"},{"type":"codeVoice","code":"LambdaRuntime"},{"text":" by first going through ","type":"text"},{"type":"codeVoice","code":"LambdaHandlerAdapter"},{"type":"text","text":" and"},{"type":"text","text":" "},{"type":"text","text":"then through "},{"type":"codeVoice","code":"LambdaCodableAdapter"},{"type":"text","text":". "},{"type":"codeVoice","code":"LambdaWithBackgroundHandler"},{"type":"text","text":" just requires "},{"code":"LambdaCodableAdapter","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"For the common JSON-in and JSON-out use-case, there is an extension on "},{"code":"LambdaRuntime","type":"codeVoice"},{"type":"text","text":" that abstracts away this wrapping"},{"text":" ","type":"text"},{"type":"text","text":"from the user."}],"type":"paragraph"},{"text":"LambdaRuntime","anchor":"LambdaRuntime","type":"heading","level":3},{"inlineContent":[{"type":"codeVoice","code":"LambdaRuntime"},{"type":"text","text":" is the class that communicates with the Lambda control plane as defined in"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"https:\/\/docs.aws.amazon.com\/lambda\/latest\/dg\/runtimes-custom.html"},{"type":"text","text":" and"},{"type":"text","text":" "},{"type":"text","text":"forward the invocations to the provided "},{"code":"StreamingLambdaHandler","type":"codeVoice"},{"type":"text","text":". It will conform to "},{"code":"ServiceLifecycle.Service","type":"codeVoice"},{"text":" to","type":"text"},{"type":"text","text":" "},{"text":"provide support for ","type":"text"},{"type":"codeVoice","code":"swift-service-lifecycle"},{"type":"text","text":"."}],"type":"paragraph"},{"code":["\/\/\/ The LambdaRuntime object. This object communicates with the Lambda control plane","\/\/\/ to fetch work and report errors.","public final class LambdaRuntime<Handler>: ServiceLifecycle.Service, Sendable","    where Handler: StreamingLambdaHandler","{","","    \/\/\/ Create a LambdaRuntime by passing a handler, an eventLoop and a logger.","    \/\/\/ - Parameter handler: A ``StreamingLambdaHandler`` that will be invoked","    \/\/\/ - Parameter eventLoop: An ``EventLoop`` on which the LambdaRuntime will be","    \/\/\/                        executed. Defaults to an EventLoop from","    \/\/\/                        ``NIOSingletons.posixEventLoopGroup``.","    \/\/\/ - Parameter logger: A logger","    public init(","        handler: sending Handler,","        eventLoop: EventLoop = Lambda.defaultEventLoop,","        logger: Logger = Logger(label: \"Lambda\")","    )","","    \/\/\/ Create a LambdaRuntime by passing a ``StreamingLambdaHandler``.","    public convenience init(handler: sending Handler)","","    \/\/\/ Starts the LambdaRuntime by connecting to the Lambda control plane to ask","    \/\/\/ for events to process. If the environment variable AWS_LAMBDA_RUNTIME_API is","    \/\/\/ set, the LambdaRuntime will connect to the Lambda control plane. Otherwise","    \/\/\/ it will start a mock server that can be used for testing at port 8080","    \/\/\/ locally.","    \/\/\/ Cancel the task that runs this function to close the communication with","    \/\/\/ the Lambda control plane or close the local mock server. This function","    \/\/\/ only returns once cancelled.","    public func run() async throws","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"The current API allows for a Lambda function to be tested locally through a mock server by requiring an environment","type":"text"},{"type":"text","text":" "},{"text":"variable named ","type":"text"},{"type":"codeVoice","code":"LOCAL_LAMBDA_SERVER_ENABLED"},{"text":" to be set to ","type":"text"},{"type":"codeVoice","code":"true"},{"type":"text","text":". If this environment variable is not set, the program"},{"text":" ","type":"text"},{"type":"text","text":"immediately crashes as the user will not have the "},{"type":"codeVoice","code":"AWS_LAMBDA_RUNTIME_API"},{"type":"text","text":" environment variable on their local machine"},{"type":"text","text":" "},{"type":"text","text":"(set automatically when deployed to AWS Lambda). However, making the user set the "},{"code":"LOCAL_LAMBDA_SERVER_ENABLED","type":"codeVoice"},{"type":"text","text":" "},{"type":"text","text":"environment variable is an unnecessary step that can be avoided. In the v2 API, the "},{"type":"codeVoice","code":"run()"},{"type":"text","text":" function will automatically"},{"type":"text","text":" "},{"text":"start the mock server when the ","type":"text"},{"type":"codeVoice","code":"AWS_LAMBDA_RUNTIME_API"},{"type":"text","text":" environment variable cannot be found."}]},{"type":"heading","level":3,"text":"Lambda","anchor":"Lambda"},{"type":"paragraph","inlineContent":[{"type":"text","text":"We also add an enum to store a static function and a property on. We put this on the static "},{"type":"codeVoice","code":"Lambda"},{"type":"text","text":" because"},{"type":"text","text":" "},{"type":"codeVoice","code":"LambdaRuntime"},{"text":" is generic and thus has bad ergonomics for static properties and functions.","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["enum Lambda {","    \/\/\/ This returns the default EventLoop that a LambdaRuntime is scheduled on.","    \/\/\/ It uses `NIOSingletons.posixEventLoopGroup.next()` under the hood.","    public static var defaultEventLoop: any EventLoop { get }","","    \/\/\/ Report a startup error to the Lambda Control Plane API","    public static func reportStartupError(any Error) async","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Since the library now provides ownership of the "},{"code":"main()","type":"codeVoice"},{"text":" function and allows users to initialize services before the","type":"text"},{"text":" ","type":"text"},{"type":"codeVoice","code":"LambdaRuntime"},{"type":"text","text":" is initialized, the library cannot implicitly report"},{"text":" ","type":"text"},{"identifier":"https:\/\/docs.aws.amazon.com\/lambda\/latest\/dg\/runtimes-api.html#runtimes-api-initerror","isActive":true,"type":"reference"},{"text":" ","type":"text"},{"type":"text","text":"like it currently does through the "},{"type":"codeVoice","code":"initialize()"},{"type":"text","text":" function of "},{"type":"codeVoice","code":"LambdaRunner"},{"type":"text","text":" which wraps the handler’s "},{"code":"init(...)","type":"codeVoice"},{"type":"text","text":" and"},{"type":"text","text":" "},{"text":"handles any errors thrown by reporting it to the dedicated AWS endpoint.","type":"text"}]},{"inlineContent":[{"text":"To retain support for initialization error reporting, the ","type":"text"},{"type":"codeVoice","code":"Lambda.reportStartupError(any Error)"},{"text":" function gives users","type":"text"},{"type":"text","text":" "},{"text":"the option to manually report initialization errors in their closure handler. Although this should ideally happen","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"implicitly like it currently does in v1, we believe this is a small compromise in comparison to the benefits gained in"},{"type":"text","text":" "},{"type":"text","text":"now being able to cleanly manage the lifecycles of required services in a structured concurrency manner."}],"type":"paragraph"},{"type":"aside","style":"note","content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"}]},{"inlineContent":[{"type":"text","text":"Assume we want to load a secret for the Lambda function from a secret vault first. If this fails, we want to report"},{"text":" ","type":"text"},{"type":"text","text":"the error to the control plane:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["let secretVault = SecretVault()","","do {","   \/\/\/ !!! Error thrown: secret \"foo\" does not exist !!!","   let secret = try await secretVault.getSecret(\"foo\")","","   let runtime = LambdaRuntime { (event: Input, context: LambdaContext) in","       \/\/\/ Lambda business logic","   }","","   let serviceGroup = ServiceGroup(","       services: [postgresClient, runtime],","       configuration: .init(gracefulShutdownSignals: [.sigterm]),","       logger: logger","   )","   try await serviceGroup.run()","} catch {","   \/\/\/ Report startup error straight away to the dedicated initialization error endpoint","   try await Lambda.reportStartupError(error)","}"]}],"name":"Use-case"},{"text":"Codable support","type":"heading","anchor":"Codable-support","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"LambdaHandler"},{"text":" and ","type":"text"},{"code":"LambdaWithBackgroundProcessingHandler","type":"codeVoice"},{"type":"text","text":" protocols abstract away encoding\/decoding logic from the"},{"type":"text","text":" "},{"type":"text","text":"conformers as they are generic over custom "},{"code":"Event","type":"codeVoice"},{"type":"text","text":" and "},{"code":"Output","type":"codeVoice"},{"type":"text","text":" types. We introduce two adapters "},{"type":"codeVoice","code":"LambdaHandlerAdapter"},{"type":"text","text":" "},{"text":"and ","type":"text"},{"code":"CodableLambdaAdapter","type":"codeVoice"},{"type":"text","text":" that implement the encoding\/decoding logic and in turn allow the respective handlers to"},{"type":"text","text":" "},{"text":"conform to ","type":"text"},{"type":"codeVoice","code":"StreamingLambdaHandler"},{"text":".","type":"text"}]},{"level":4,"text":"LambdaHandlerAdapter","anchor":"LambdaHandlerAdapter","type":"heading"},{"inlineContent":[{"type":"text","text":"Any handler conforming to "},{"type":"codeVoice","code":"LambdaHandler"},{"text":" can be conformed to ","type":"text"},{"code":"LambdaWithBackgroundProcessingHandler","type":"codeVoice"},{"type":"text","text":" through"},{"type":"text","text":" "},{"type":"codeVoice","code":"LambdaHandlerAdapter"},{"type":"text","text":"."}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["\/\/\/ Wraps an underlying handler conforming to ``LambdaHandler``","\/\/\/ with ``LambdaWithBackgroundProcessingHandler``.","public struct LambdaHandlerAdapter<","    Event: Decodable,","    Output,","    Handler: LambdaHandler",">: LambdaWithBackgroundProcessingHandler where Handler.Event == Event, Handler.Output == Output {","    let handler: Handler","","    \/\/\/ Register the concrete handler.","    public init(handler: Handler)","","    \/\/\/ 1. Call the `self.handler.handle(...)` with `event` and `context`.","    \/\/\/ 2. Pass the generic `Output` object returned from `self.handler.handle(...)` to `outputWriter.write(_:)`","    public func handle(_ event: Event, outputWriter: some LambdaResponseWriter<Output>, context: LambdaContext) async throws","}"]},{"anchor":"LambdaCodableAdapter","type":"heading","level":4,"text":"LambdaCodableAdapter"},{"inlineContent":[{"type":"codeVoice","code":"LambdaCodableAdapter"},{"text":" accepts any generic underlying handler conforming to ","type":"text"},{"type":"codeVoice","code":"LambdaWithBackgroundProcessingHandler"},{"type":"text","text":". It"},{"type":"text","text":" "},{"type":"text","text":"also accepts "},{"type":"emphasis","inlineContent":[{"type":"text","text":"any"}]},{"type":"text","text":" encoder and decoder object conforming to the "},{"type":"codeVoice","code":"LambdaEventDecoder"},{"type":"text","text":" and "},{"code":"LambdaOutputEncoder","type":"codeVoice"},{"text":" ","type":"text"},{"text":"protocols:","type":"text"}],"type":"paragraph"},{"level":5,"text":"LambdaEventDecoder and LambdaOutputEncoder protocols","type":"heading","anchor":"LambdaEventDecoder-and-LambdaOutputEncoder-protocols"},{"syntax":"swift","type":"codeListing","code":["public protocol LambdaEventDecoder {","    \/\/\/ Decode the ByteBuffer representing the received event into the generic type Event","    \/\/\/ the handler will receive","    func decode<Event: Decodable>(_ type: Event.Type, from buffer: ByteBuffer) throws -> Event","}","","public protocol LambdaOutputEncoder {","    \/\/\/ Encode the generic type Output the handler has produced into a ByteBuffer","    func encode<Output: Encodable>(_ value: Output, into buffer: inout ByteBuffer) throws","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"We provide conformances for Foundation’s "},{"code":"JSONDecoder","type":"codeVoice"},{"text":" to ","type":"text"},{"code":"LambdaEventDecoder","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"JSONEncoder","type":"codeVoice"},{"type":"text","text":" to"},{"text":" ","type":"text"},{"type":"codeVoice","code":"LambdaOutputEncoder"},{"text":".","type":"text"}]},{"inlineContent":[{"type":"codeVoice","code":"LambdaCodableAdapter"},{"type":"text","text":" implements its "},{"code":"handle()","type":"codeVoice"},{"type":"text","text":" method by:"}],"type":"paragraph"},{"type":"orderedList","items":[{"content":[{"inlineContent":[{"text":"Decoding the ","type":"text"},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":" event into the generic "},{"type":"codeVoice","code":"Event"},{"text":" type.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Wrapping the ","type":"text"},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"text":" with a concrete ","type":"text"},{"type":"codeVoice","code":"LambdaResponseWriter"},{"type":"text","text":" such that calls to"},{"text":" ","type":"text"},{"code":"LambdaResponseWriter","type":"codeVoice"},{"text":"s ","type":"text"},{"type":"codeVoice","code":"write(_:)"},{"type":"text","text":" are mapped to "},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"text":"s ","type":"text"},{"type":"codeVoice","code":"writeAndFinish(_:)"},{"type":"text","text":"."}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Note that the argument to ","type":"text"},{"type":"codeVoice","code":"LambdaResponseWriter"},{"type":"text","text":"s "},{"type":"codeVoice","code":"write(_:)"},{"text":" is a generic ","type":"text"},{"type":"codeVoice","code":"Output"},{"type":"text","text":" object whereas"},{"text":" ","type":"text"},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"type":"text","text":"s "},{"code":"writeAndFinish(_:)","type":"codeVoice"},{"type":"text","text":" requires a "},{"code":"ByteBuffer","type":"codeVoice"},{"type":"text","text":"."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Therefore, the concrete implementation of ","type":"text"},{"type":"codeVoice","code":"LambdaResponseWriter"},{"text":" also accepts an encoder. Its ","type":"text"},{"type":"codeVoice","code":"write(_:)"},{"type":"text","text":" function"},{"type":"text","text":" "},{"type":"text","text":"first encodes the generic "},{"type":"codeVoice","code":"Output"},{"text":" object and then passes it to the underlying ","type":"text"},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"text":".","type":"text"}]}]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Passing the generic ","type":"text"},{"code":"Event","type":"codeVoice"},{"text":" instance, the concrete ","type":"text"},{"type":"codeVoice","code":"LambdaResponseWriter"},{"text":", as well as the ","type":"text"},{"type":"codeVoice","code":"LambdaContext"},{"text":" to the","type":"text"},{"type":"text","text":" "},{"text":"underlying handler’s ","type":"text"},{"code":"handle()","type":"codeVoice"},{"type":"text","text":" method."}]}]}]},{"inlineContent":[{"type":"codeVoice","code":"LambdaCodableAdapter"},{"type":"text","text":" can implement encoding\/decoding for "},{"inlineContent":[{"type":"text","text":"any"}],"type":"emphasis"},{"text":" handler conforming to","type":"text"},{"type":"text","text":" "},{"code":"LambdaWithBackgroundProcessingHandler","type":"codeVoice"},{"text":" if ","type":"text"},{"type":"codeVoice","code":"Event"},{"type":"text","text":" is "},{"code":"Decodable","type":"codeVoice"},{"type":"text","text":" and the "},{"type":"codeVoice","code":"Output"},{"text":" is ","type":"text"},{"code":"Encodable","type":"codeVoice"},{"text":" or ","type":"text"},{"type":"codeVoice","code":"Void"},{"type":"text","text":", meaning"},{"text":" ","type":"text"},{"text":"that the encoding\/decoding stubs do not need to be implemented by the user.","type":"text"}],"type":"paragraph"},{"code":["\/\/\/ Wraps an underlying handler conforming to `LambdaWithBackgroundProcessingHandler`","\/\/\/ with encoding\/decoding logic","public struct LambdaCodableAdapter<","    Handler: LambdaWithBackgroundProcessingHandler,","    Event: Decodable,","    Output,","    Decoder: LambdaEventDecoder,","    Encoder: LambdaOutputEncoder",">: StreamingLambdaHandler where Handler.Output == Output, Handler.Event == Event {","","    \/\/\/ Register the concrete handler, encoder, and decoder.","    public init(","        handler: Handler,","        encoder: Encoder,","        decoder: Decoder","    ) where Output: Encodable","","    \/\/\/ For handler with a void output -- the user doesn't specify an encoder.","    public init(","        handler: Handler,","        decoder: Decoder","    ) where Output == Void, Encoder == VoidEncoder","","    \/\/\/ 1. Decode the invocation event using `self.decoder`","    \/\/\/ 2. Create a concrete `LambdaResponseWriter` that maps calls to `write(_:)` with the `responseWriter`s `writeAndFinish(_:)`","    \/\/\/ 2. Call the underlying `self.handler.handle()` method with the decoded event data, the concrete `LambdaResponseWriter`,","    \/\/\/ and the `LambdaContext`.","    public mutating func handle(","        _ request: ByteBuffer,","        responseWriter: some LambdaResponseStreamWriter,","        context: LambdaContext","    ) async throws","}"],"type":"codeListing","syntax":"swift"},{"anchor":"Handler-as-a-Closure","level":3,"text":"Handler as a Closure","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"To create a Lambda function using the current API, a user first has to create an object and conform it to one of the","type":"text"},{"type":"text","text":" "},{"type":"text","text":"handler protocols by implementing the initializer and the "},{"type":"codeVoice","code":"handle(...)"},{"text":" function. Now that ","type":"text"},{"code":"LambdaRuntime","type":"codeVoice"},{"text":" is public,","type":"text"},{"text":" ","type":"text"},{"text":"this verbosity can very easily be simplified.","type":"text"}]},{"type":"heading","anchor":"ClosureHandler","level":4,"text":"ClosureHandler"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This handler is generic over any "},{"code":"Event","type":"codeVoice"},{"text":" type conforming to ","type":"text"},{"code":"Decodable","type":"codeVoice"},{"type":"text","text":" and any "},{"code":"Output","type":"codeVoice"},{"type":"text","text":" type conforming to "},{"code":"Encodable","type":"codeVoice"},{"text":" ","type":"text"},{"type":"text","text":"or "},{"type":"codeVoice","code":"Void"},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"swift","code":["public struct ClosureHandler<Event, Output>: LambdaHandler {","    \/\/\/ Initialize with a closure handler over generic Input and Output types","    public init(body: @escaping (Event, LambdaContext) async throws -> Output) where Output: Encodable","    \/\/\/ Initialize with a closure handler over a generic Input type (Void Output).","    public init(body: @escaping (Event, LambdaContext) async throws -> Void) where Output == Void","    \/\/\/ The business logic of the Lambda function.","    public func handle(_ event: Event, context: LambdaContext) async throws -> Output","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Given that "},{"code":"ClosureHandler","type":"codeVoice"},{"text":" conforms to ","type":"text"},{"type":"codeVoice","code":"LambdaHandler"},{"text":":","type":"text"}]},{"type":"orderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"We can extend the "},{"type":"codeVoice","code":"LambdaRuntime"},{"text":" initializer such that it accepts a closure as an argument.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Within the initializer, the closure handler is wrapped with "},{"code":"LambdaCodableAdapter","type":"codeVoice"},{"type":"text","text":"."}]}]}]},{"code":["extension LambdaRuntime {","    \/\/\/ Initialize a LambdaRuntime with a closure handler over generic Event and Output types.","    \/\/\/ This initializer bolts on encoding\/decoding logic by wrapping the closure handler with","    \/\/\/ LambdaCodableAdapter.","    public init<Event: Decodable, Output: Encodable>(","        body: @escaping (Event, LambdaContext) async throws -> Output","    ) where Handler == LambdaCodableAdapter<ClosureHandler<Event, Output>, Event, Output, JSONDecoder, JSONEncoder>","","    \/\/\/ Same as above but for handlers with a void output","    public init<Event: Decodable>(","        body: @escaping (Event, LambdaContext) async throws -> Void","    ) where Handler == LambdaCodableAdapter<ClosureHandler<Event, Void>, Event, Void, JSONDecoder, VoidEncoder>","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"We can now significantly reduce the verbosity and leverage Swift’s trailing closure syntax to cleanly create and run a"},{"type":"text","text":" "},{"text":"Lambda function, abstracting away the decoding and encoding logic from the user:","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["\/\/\/ The type the handler will use as input","struct Input: Decodable {","    var message: String","}","","\/\/\/ The type the handler will output","struct Greeting: Encodable {","    var echoedMessage: String","}","","\/\/\/ A simple Lambda function that echoes the input","let runtime = LambdaRuntime { (event: Input, context: LambdaContext) in","    Greeting(echoedMessage: event.message)","}","","try await runtime.run()"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"We also add a "},{"type":"codeVoice","code":"StreamingClosureHandler"},{"type":"text","text":" conforming to "},{"code":"StreamingLambdaHandler","type":"codeVoice"},{"type":"text","text":" for use-cases where the user wants to"},{"type":"text","text":" "},{"type":"text","text":"handle encoding\/decoding themselves:"}]},{"type":"codeListing","syntax":"swift","code":["public struct StreamingClosureHandler: StreamingLambdaHandler {","","    public init(","        body: @escaping sending (ByteBuffer, LambdaResponseStreamWriter, LambdaContext) async throws -> ()","    )","","    public func handle(","        _ request: ByteBuffer,","        responseWriter: LambdaResponseStreamWriter,","        context: LambdaContext","    ) async throws","}","","extension LambdaRuntime {","    public init(","        body: @escaping sending (ByteBuffer, LambdaResponseStreamWriter, LambdaContext) async throws -> ()","    )","}"]},{"type":"heading","text":"Alternatives considered","level":2,"anchor":"Alternatives-considered"},{"level":3,"type":"heading","text":"[UInt8] instead of ByteBuffer","anchor":"UInt8-instead-of-ByteBuffer"},{"type":"paragraph","inlineContent":[{"type":"text","text":"We considered using "},{"code":"[UInt8]","type":"codeVoice"},{"text":" instead of ","type":"text"},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":" in the base "},{"code":"LambdaHandler","type":"codeVoice"},{"type":"text","text":" API. We decided to use "},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":" "},{"text":"for two reasons.","type":"text"}]},{"type":"orderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"99% of use-cases will use the JSON codable API and will not directly get in touch with ByteBuffer anyway. For those"},{"type":"text","text":" "},{"type":"text","text":"users it does not matter if the base API uses "},{"type":"codeVoice","code":"ByteBuffer"},{"text":" or ","type":"text"},{"type":"codeVoice","code":"[UInt8]"},{"type":"text","text":"."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"The incoming and outgoing data must be in the ","type":"text"},{"code":"ByteBuffer","type":"codeVoice"},{"type":"text","text":" format anyway, as Lambda uses SwiftNIO under the hood and"},{"type":"text","text":" "},{"type":"text","text":"SwiftNIO uses "},{"code":"ByteBuffer","type":"codeVoice"},{"text":" in its APIs. By using ","type":"text"},{"code":"ByteBuffer","type":"codeVoice"},{"type":"text","text":" we can save a copies to and from "},{"type":"codeVoice","code":"[UInt8]"},{"type":"text","text":". This will"},{"text":" ","type":"text"},{"type":"text","text":"reduce the invocation time for all users."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The base "},{"code":"LambdaHandler","type":"codeVoice"},{"type":"text","text":" API is most likely mainly being used by developers that want to integrate their web"},{"type":"text","text":" "},{"text":"framework with Lambda (examples: Vapor, Hummingbird, …). Those developers will most likely prefer to get the data","type":"text"},{"type":"text","text":" "},{"text":"in the ","type":"text"},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":" format anyway, as their lower level networking stack also depends on SwiftNIO."}]}]}]},{"level":3,"text":"Users create a LambdaResponse, that supports streaming instead of being passed a LambdaResponseStreamWriter","type":"heading","anchor":"Users-create-a-LambdaResponse-that-supports-streaming-instead-of-being-passed-a-LambdaResponseStreamWriter"},{"type":"paragraph","inlineContent":[{"text":"Instead of passing the ","type":"text"},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"type":"text","text":" in the invocation we considered a new type "},{"type":"codeVoice","code":"LambdaResponse"},{"type":"text","text":", that"},{"type":"text","text":" "},{"text":"users must return in the ","type":"text"},{"type":"codeVoice","code":"StreamingLambdaHandler"},{"text":".","type":"text"}]},{"inlineContent":[{"text":"Its API would look like this:","type":"text"}],"type":"paragraph"},{"code":["\/\/\/ A response returned from a ``LambdaHandler``.","\/\/\/ The response can be empty, a single ByteBuffer or a response stream.","public struct LambdaResponse {","    \/\/\/ A writer to be used when creating a streamed response.","    public struct Writer {","        \/\/\/ Writes data to the response stream","        public func write(_ byteBuffer: ByteBuffer) async throws","        \/\/\/ Closes off the response stream","        public func finish() async throws","        \/\/\/ Writes the `byteBuffer` to the response stream and subsequently closes the stream","        public func writeAndFinish(_ byteBuffer: ByteBuffer) async throws","    }","","    \/\/\/ Creates an empty lambda response","    public init()","","    \/\/\/ Creates a LambdaResponse with a fixed ByteBuffer.","    public init(_ byteBuffer: ByteBuffer)","","    \/\/\/ Creates a streamed lambda response. Use the ``Writer`` to send","    \/\/\/ response chunks on the stream.","    public init(_ stream: @escaping sending (Writer) async throws -> ())","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"StreamingLambdaHandler"},{"type":"text","text":" would look like this:"}]},{"syntax":"swift","code":["\/\/\/ The base LambdaHandler protocol","public protocol StreamingLambdaHandler {","    \/\/\/ The business logic of the Lambda function","    \/\/\/ - Parameters:","    \/\/\/   - event: The invocation's input data","    \/\/\/   - context: The LambdaContext containing the invocation's metadata","    \/\/\/ - Returns: A LambdaResponse, that can be streamed","    mutating func handle(","        _ event: ByteBuffer,","        context: LambdaContext","    ) async throws -> LambdaResponse","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"There are pros and cons for the API that returns the ","type":"text"},{"code":"LambdaResponses","type":"codeVoice"},{"text":" and there are pros and cons for the API that","type":"text"},{"type":"text","text":" "},{"text":"receives a ","type":"text"},{"code":"LambdaResponseStreamWriter","type":"codeVoice"},{"type":"text","text":" as a parameter."}]},{"type":"paragraph","inlineContent":[{"text":"Concerning following structured concurrency principles the approach that receives a ","type":"text"},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"text":" as a","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"parameter has benefits as the lifetime of the handle function is tied to the invocation runtime. The approach that"},{"type":"text","text":" "},{"type":"text","text":"returns a "},{"code":"LambdaResponse","type":"codeVoice"},{"text":" splits the invocation into two separate function calls. First the handle method is invoked,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"second the "},{"type":"codeVoice","code":"LambdaResponse"},{"text":" writer closure is invoked. This means that it is impossible to use Swift APIs that use","type":"text"},{"type":"text","text":" "},{"code":"with","type":"codeVoice"},{"text":" style lifecycle management patterns from before creating the response until sending the full response stream off.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"For example, users instrumenting their lambdas with Swift tracing likely can not use the "},{"type":"codeVoice","code":"withSpan"},{"type":"text","text":" API for the full"},{"text":" ","type":"text"},{"type":"text","text":"lifetime of the request, if they return a streamed response."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"However, if it comes to consistency with the larger Swift on server ecosystem, the API that returns a "},{"type":"codeVoice","code":"LambdaResponse"},{"text":" ","type":"text"},{"text":"is likely the better choice. Hummingbird v2, OpenAPI and the new Swift gRPC v2 implementation all use this approach.","type":"text"},{"type":"text","text":" "},{"text":"This might be due to the fact that writing middleware becomes easier, if a Response is explicitly returned.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"We decided to implement the approach in which a "},{"code":"LambdaResponseStreamWriter","type":"codeVoice"},{"text":" is passed to the function, since the","type":"text"},{"type":"text","text":" "},{"text":"approach in which a ","type":"text"},{"type":"codeVoice","code":"LambdaResponse"},{"type":"text","text":" is returned can trivially be built on top of it. This is not true vice versa."}]},{"inlineContent":[{"type":"text","text":"We welcome the discussion on this topic and are open to change our minds and API here."}],"type":"paragraph"},{"text":"Adding a function `addBackgroundTask(_ body: sending @escaping () async -> ())` in `LambdaContext`","type":"heading","level":3,"anchor":"Adding-a-function-addBackgroundTask-body-sending-escaping--async-%3E--in-LambdaContext"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Initially we proposed an explicit "},{"code":"addBackgroundTask(_:)","type":"codeVoice"},{"text":" function in ","type":"text"},{"type":"codeVoice","code":"LambdaContext"},{"text":" that users could call from their","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"handler object to schedule a background task to be run after the result is reported to AWS. We received feedback that"},{"type":"text","text":" "},{"text":"this approach for supporting background tasks does not exhibit structured concurrency, as code could still be in","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"execution after leaving the scope of the "},{"type":"codeVoice","code":"handle(...)"},{"type":"text","text":" function."}]},{"type":"paragraph","inlineContent":[{"text":"For handlers conforming to the ","type":"text"},{"code":"StreamingLambdaHandler","type":"codeVoice"},{"type":"text","text":", "},{"type":"codeVoice","code":"addBackgroundTask(_:)"},{"type":"text","text":" was anyways unnecessary as background"},{"text":" ","type":"text"},{"type":"text","text":"work could be executed in a structured concurrency manner within the "},{"code":"handle(...)","type":"codeVoice"},{"type":"text","text":" function after the call to"},{"type":"text","text":" "},{"type":"codeVoice","code":"LambdaResponseStreamWriter.finish()"},{"type":"text","text":"."}]},{"inlineContent":[{"type":"text","text":"For handlers conforming to the "},{"type":"codeVoice","code":"LambdaHandler"},{"type":"text","text":" protocol, we considered extending "},{"code":"LambdaHandler","type":"codeVoice"},{"type":"text","text":" with a"},{"type":"text","text":" "},{"type":"codeVoice","code":"performPostHandleWork(...)"},{"type":"text","text":" function that will be called after the "},{"code":"handle","type":"codeVoice"},{"text":" function by the library. Users wishing to","type":"text"},{"type":"text","text":" "},{"type":"text","text":"add background work can override this function in their "},{"type":"codeVoice","code":"LambdaHandler"},{"type":"text","text":" conforming object."}],"type":"paragraph"},{"syntax":"swift","code":["public protocol LambdaHandler {","    associatedtype Event","    associatedtype Output","","    func handle(_ event: Event, context: LambdaContext) async throws -> Output","","    func performPostHandleWork(...) async throws -> Void","}","","extension LambdaHandler {","    \/\/ User's can override this function if they wish to perform background work","    \/\/ after returning a response from ``handle``.","    func performPostHandleWork(...) async throws -> Void {","        \/\/ nothing to do","    }","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"Yet this poses difficulties when the user wishes to use any state created in the "},{"type":"codeVoice","code":"handle(...)"},{"type":"text","text":" function as part of the"},{"text":" ","type":"text"},{"text":"background work.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"In general, the most common use-case for this library will be to implement simple Lambda functions that do not have","type":"text"},{"type":"text","text":" "},{"type":"text","text":"requirements for response streaming, nor to perform any background work after returning the output. To keep things easy"},{"text":" ","type":"text"},{"type":"text","text":"for the common use-case, and with Swift’s principle of progressive disclosure of complexity in mind, we settled on three"},{"type":"text","text":" "},{"text":"handler protocols:","type":"text"}],"type":"paragraph"},{"type":"orderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"code":"LambdaHandler","type":"codeVoice"},{"text":": Most common use-case. JSON-in, JSON-out. Does not support background work execution. An intuitive","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"handle(event: Event, context: LambdaContext) -> Output"},{"text":" API that is simple to understand, i.e. users are not exposed","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"to the concept of sending their response through a writer. "},{"code":"LambdaHandler","type":"codeVoice"},{"type":"text","text":" can be very cleanly implemented and used"},{"text":" ","type":"text"},{"type":"text","text":"with "},{"type":"codeVoice","code":"LambdaRuntime"},{"type":"text","text":", especially with "},{"code":"ClosureHandler","type":"codeVoice"},{"text":".","type":"text"}]}]},{"content":[{"inlineContent":[{"code":"LambdaWithBackgroundProcessingHandler","type":"codeVoice"},{"text":": If users wish to augment their ","type":"text"},{"code":"LambdaHandler","type":"codeVoice"},{"type":"text","text":" with the ability to run"},{"type":"text","text":" "},{"type":"text","text":"background tasks, they can easily migrate. A user simply has to:"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"text":"Change the conformance to ","type":"text"},{"code":"LambdaWithBackgroundProcessingHandler","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Add an additional "},{"type":"codeVoice","code":"outputWriter: some LambdaResponseWriter<Output>"},{"type":"text","text":" argument to the "},{"code":"handle","type":"codeVoice"},{"type":"text","text":" function."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Replace the "},{"code":"return ...","type":"codeVoice"},{"text":" with ","type":"text"},{"type":"codeVoice","code":"outputWriter.write(...)"},{"text":".","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"Implement any background work after ","type":"text"},{"type":"codeVoice","code":"outputWriter.write(...)"},{"text":".","type":"text"}],"type":"paragraph"}]}],"type":"orderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"StreamingLambdaHandler"},{"type":"text","text":": This is the base handler protocol which is intended to be used directly only for advanced"},{"type":"text","text":" "},{"type":"text","text":"use-cases. Users are provided the invocation event as a "},{"code":"ByteBuffer","type":"codeVoice"},{"text":" and a ","type":"text"},{"type":"codeVoice","code":"LambdaResponseStreamWriter"},{"type":"text","text":" where the"},{"text":" ","type":"text"},{"text":"computed result (as ","type":"text"},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":") can either be streamed (with repeated calls to "},{"type":"codeVoice","code":"write(_:)"},{"text":") or sent all at once","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"(with a single call to "},{"type":"codeVoice","code":"writeAndFinish(_:)"},{"type":"text","text":"). After closing the "},{"code":"LambdaResponseStreamWriter","type":"codeVoice"},{"type":"text","text":", any background work can"},{"type":"text","text":" "},{"type":"text","text":"be implemented."}]}]}]},{"type":"heading","anchor":"Making-LambdaResponseStreamWriter-and-LambdaResponseWriter-~Copyable","text":"Making LambdaResponseStreamWriter and LambdaResponseWriter ~Copyable","level":3},{"inlineContent":[{"type":"text","text":"We initially proposed to make the "},{"code":"LambdaResponseStreamWriter","type":"codeVoice"},{"type":"text","text":" and "},{"code":"LambdaResponseWriter","type":"codeVoice"},{"text":" protocols ","type":"text"},{"code":"~Copyable","type":"codeVoice"},{"type":"text","text":", with"},{"type":"text","text":" "},{"text":"the functions that close the response having the ","type":"text"},{"type":"codeVoice","code":"consuming"},{"type":"text","text":" ownership keyword. This was so that the compiler could"},{"text":" ","type":"text"},{"type":"text","text":"enforce the restriction of not being able to interact with the writer after the response stream has closed."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"However, non-copyable types do not compose nicely and add complexity for users. Further, for the compiler to actually"},{"type":"text","text":" "},{"type":"text","text":"enforce the "},{"code":"consuming","type":"codeVoice"},{"text":" restrictions, user’s have to explicitly mark the writer argument as ","type":"text"},{"type":"codeVoice","code":"consuming"},{"text":" in the ","type":"text"},{"code":"handle","type":"codeVoice"},{"text":" ","type":"text"},{"type":"text","text":"function."}]},{"type":"paragraph","inlineContent":[{"text":"Therefore, throwing appropriate errors to prevent abnormal interaction with the writers seems to be the simplest","type":"text"},{"type":"text","text":" "},{"type":"text","text":"approach."}]},{"text":"A word about versioning","level":2,"anchor":"A-word-about-versioning","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"We are aware that AWS Lambda Runtime has not reached a proper 1.0. We intend to keep the current implementation around"},{"text":" ","type":"text"},{"type":"text","text":"at 1.0-alpha. We don’t want to change the current API without releasing a new major. We think there are lots of adopters"},{"text":" ","type":"text"},{"text":"out there that depend on the API in v1. Because of this we intend to release the proposed API here as AWS Lambda Runtime","type":"text"},{"text":" ","type":"text"},{"text":"v2.","type":"text"}]}]}],"identifier":{"url":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore\/0001-v2-api","interfaceLanguage":"swift"},"kind":"article","sections":[],"references":{"https://aws.amazon.com/blogs/compute/introducing-aws-lambda-response-streaming/":{"url":"https:\/\/aws.amazon.com\/blogs\/compute\/introducing-aws-lambda-response-streaming\/","type":"link","identifier":"https:\/\/aws.amazon.com\/blogs\/compute\/introducing-aws-lambda-response-streaming\/","title":"AWS introduced support for response streaming","titleInlineContent":[{"text":"AWS introduced support for response streaming","type":"text"}]},"https://aws.amazon.com/blogs/compute/running-code-after-returning-a-response-from-an-aws-lambda-function/":{"url":"https:\/\/aws.amazon.com\/blogs\/compute\/running-code-after-returning-a-response-from-an-aws-lambda-function\/","type":"link","identifier":"https:\/\/aws.amazon.com\/blogs\/compute\/running-code-after-returning-a-response-from-an-aws-lambda-function\/","title":"AWS described in a blog post that you can run background tasks in Lambda","titleInlineContent":[{"text":"AWS described in a blog post that you can run background tasks in Lambda","type":"text"}]},"https://docs.aws.amazon.com/lambda/latest/dg/runtimes-api.html#runtimes-api-initerror":{"url":"https:\/\/docs.aws.amazon.com\/lambda\/latest\/dg\/runtimes-api.html#runtimes-api-initerror","type":"link","identifier":"https:\/\/docs.aws.amazon.com\/lambda\/latest\/dg\/runtimes-api.html#runtimes-api-initerror","title":"errors that occur during initialization to the dedicated endpoint AWS exposes","titleInlineContent":[{"text":"errors that occur during initialization to the dedicated endpoint AWS exposes","type":"text"}]},"doc://AWSLambdaRuntimeCore/documentation/AWSLambdaRuntimeCore":{"url":"\/documentation\/awslambdaruntimecore","type":"topic","abstract":[{"type":"text","text":"An AWS Lambda runtime for the Swift programming language"}],"identifier":"doc:\/\/AWSLambdaRuntimeCore\/documentation\/AWSLambdaRuntimeCore","title":"AWSLambdaRuntimeCore","kind":"symbol","role":"collection"},"https://github.com/swift-server/swift-aws-lambda-runtime/issues/265":{"url":"https:\/\/github.com\/swift-server\/swift-aws-lambda-runtime\/issues\/265","type":"link","identifier":"https:\/\/github.com\/swift-server\/swift-aws-lambda-runtime\/issues\/265","title":"set up global properties before the Lambda starts-up","titleInlineContent":[{"text":"set up global properties before the Lambda starts-up","type":"text"}]},"https://docs.aws.amazon.com/lambda/latest/dg/runtimes-custom.html":{"url":"https:\/\/docs.aws.amazon.com\/lambda\/latest\/dg\/runtimes-custom.html","type":"link","identifier":"https:\/\/docs.aws.amazon.com\/lambda\/latest\/dg\/runtimes-custom.html","title":"Building a custom runtime for AWS Lambda","titleInlineContent":[{"text":"Building a custom runtime for AWS Lambda","type":"text"}]}}}